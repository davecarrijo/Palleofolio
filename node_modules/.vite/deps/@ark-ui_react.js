import {
  require_jsx_runtime
} from "./chunk-5KNCR67R.js";
import {
  require_react_dom
} from "./chunk-QIO56VBJ.js";
import {
  __export,
  __toESM,
  require_react
} from "./chunk-XL6B45XM.js";

// node_modules/@ark-ui/react/dist/utils/create-context.js
var import_react = __toESM(require_react(), 1);
function getErrorMessage(hook, provider) {
  return `${hook} returned \`undefined\`. Seems you forgot to wrap component within ${provider}`;
}
function createContext(options = {}) {
  const {
    name,
    strict = true,
    hookName = "useContext",
    providerName = "Provider",
    errorMessage,
    defaultValue
  } = options;
  const Context = (0, import_react.createContext)(defaultValue);
  Context.displayName = name;
  function useContext$1() {
    var _a;
    const context = (0, import_react.useContext)(Context);
    if (!context && strict) {
      const error = new Error(errorMessage ?? getErrorMessage(hookName, providerName));
      error.name = "ContextError";
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, useContext$1);
      throw error;
    }
    return context;
  }
  return [Context.Provider, useContext$1, Context];
}

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-context.js
var [AccordionProvider, useAccordionContext] = createContext({
  name: "AccordionContext",
  hookName: "useAccordionContext",
  providerName: "<AccordionProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-context.js
var AccordionContext = (props29) => props29.children(useAccordionContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/anatomy/dist/index.mjs
var createAnatomy = (name, parts34 = []) => ({
  parts: (...values) => {
    if (isEmpty(parts34)) {
      return createAnatomy(name, values);
    }
    throw new Error("createAnatomy().parts(...) should only be called once. Did you mean to use .extendWith(...) ?");
  },
  extendWith: (...values) => createAnatomy(name, [...parts34, ...values]),
  rename: (newName) => createAnatomy(newName, parts34),
  keys: () => parts34,
  build: () => [...new Set(parts34)].reduce(
    (prev, part) => Object.assign(prev, {
      [part]: {
        selector: [
          `&[data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`,
          `& [data-scope="${toKebabCase(name)}"][data-part="${toKebabCase(part)}"]`
        ].join(", "),
        attrs: { "data-scope": toKebabCase(name), "data-part": toKebabCase(part) }
      }
    }),
    {}
  )
});
var toKebabCase = (value) => value.replace(/([A-Z])([A-Z])/g, "$1-$2").replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
var isEmpty = (v) => v.length === 0;

// node_modules/@zag-js/dom-query/dist/index.mjs
var dataAttr = (guard) => guard ? "" : void 0;
var ariaAttr = (guard) => guard ? "true" : void 0;
var MAX_Z_INDEX = 2147483647;
var isHTMLElement = (v) => typeof v === "object" && (v == null ? void 0 : v.nodeType) === Node.ELEMENT_NODE && typeof (v == null ? void 0 : v.nodeName) === "string";
var isDocument = (el) => el.nodeType === Node.DOCUMENT_NODE;
var isWindow = (el) => el != null && el === el.window;
var getNodeName = (node) => {
  if (isHTMLElement(node))
    return node.localName || "";
  return "#document";
};
function isRootElement(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
var isNode = (el) => el.nodeType !== void 0;
var isShadowRoot = (el) => el && isNode(el) && el.nodeType === Node.DOCUMENT_FRAGMENT_NODE && "host" in el;
function contains(parent, child) {
  if (!parent || !child)
    return false;
  if (!isHTMLElement(parent) || !isHTMLElement(child))
    return false;
  return parent === child || parent.contains(child);
}
function getDocument(el) {
  if (isDocument(el))
    return el;
  if (isWindow(el))
    return el.document;
  return (el == null ? void 0 : el.ownerDocument) ?? document;
}
function getDocumentElement(el) {
  return getDocument(el).documentElement;
}
function getWindow(el) {
  var _a;
  if (isShadowRoot(el))
    return getWindow(el.host);
  if (isDocument(el))
    return el.defaultView ?? window;
  if (isHTMLElement(el))
    return ((_a = el.ownerDocument) == null ? void 0 : _a.defaultView) ?? window;
  return window;
}
function getDataUrl(svg, opts) {
  const { type, quality = 0.92 } = opts;
  if (!svg)
    throw new Error("[get-data-url]: could not find the svg element");
  const win = getWindow(svg);
  const doc = win.document;
  const serializer = new win.XMLSerializer();
  const source = '<?xml version="1.0" standalone="no"?>\r\n' + serializer.serializeToString(svg);
  const svgString = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(source);
  if (type === "image/svg+xml") {
    return Promise.resolve(svgString);
  }
  const svgBounds = svg.getBoundingClientRect();
  const dpr = win.devicePixelRatio || 1;
  const canvas = doc.createElement("canvas");
  const image = new win.Image();
  image.src = svgString;
  canvas.width = svgBounds.width * dpr;
  canvas.height = svgBounds.height * dpr;
  const context = canvas.getContext("2d");
  context.scale(dpr, dpr);
  return new Promise((resolve) => {
    image.onload = () => {
      context.drawImage(image, 0, 0);
      resolve(canvas.toDataURL(type, quality));
    };
  });
}
var isDom = () => typeof document !== "undefined";
function getPlatform() {
  const agent = navigator.userAgentData;
  return (agent == null ? void 0 : agent.platform) ?? navigator.platform;
}
var pt = (v) => isDom() && v.test(getPlatform());
var ua = (v) => isDom() && v.test(navigator.userAgent);
var vn = (v) => isDom() && v.test(navigator.vendor);
var isMac = () => pt(/^Mac/);
var isSafari = () => isApple() && vn(/apple/i);
var isFirefox = () => ua(/firefox\//i);
var isApple = () => pt(/mac|iphone|ipad|ipod/i);
var isIos = () => pt(/iP(hone|ad|od)|iOS/);
var isModKey = (event) => isApple() ? event.metaKey : event.ctrlKey;
function getBeforeInputValue(event) {
  const { selectionStart, selectionEnd, value } = event.currentTarget;
  return value.slice(0, selectionStart) + event.data + value.slice(selectionEnd);
}
function getComposedPath(event) {
  var _a, _b, _c;
  return ((_a = event.composedPath) == null ? void 0 : _a.call(event)) ?? ((_c = (_b = event.nativeEvent) == null ? void 0 : _b.composedPath) == null ? void 0 : _c.call(_b));
}
function getEventTarget(event) {
  const composedPath = getComposedPath(event);
  return (composedPath == null ? void 0 : composedPath[0]) ?? event.target;
}
var isSelfTarget = (event) => {
  return contains(event.currentTarget, getEventTarget(event));
};
function isOpeningInNewTab(event) {
  const element = event.currentTarget;
  if (!element)
    return false;
  const isAppleDevice = isApple();
  if (isAppleDevice && !event.metaKey)
    return false;
  if (!isAppleDevice && !event.ctrlKey)
    return false;
  const localName = element.localName;
  if (localName === "a")
    return true;
  if (localName === "button" && element.type === "submit")
    return true;
  if (localName === "input" && element.type === "submit")
    return true;
  return false;
}
function isDownloadingEvent(event) {
  const element = event.currentTarget;
  if (!element)
    return false;
  const localName = element.localName;
  if (!event.altKey)
    return false;
  if (localName === "a")
    return true;
  if (localName === "button" && element.type === "submit")
    return true;
  if (localName === "input" && element.type === "submit")
    return true;
  return false;
}
function isComposingEvent(event) {
  var _a;
  return ((_a = event.nativeEvent) == null ? void 0 : _a.isComposing) ?? event.isComposing;
}
var defaultItemToId = (v) => v.id;
function itemById(v, id, itemToId = defaultItemToId) {
  return v.find((item) => itemToId(item) === id);
}
function indexOfId(v, id, itemToId = defaultItemToId) {
  const item = itemById(v, id, itemToId);
  return item ? v.indexOf(item) : -1;
}
function nextById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  idx = loop ? (idx + 1) % v.length : Math.min(idx + 1, v.length - 1);
  return v[idx];
}
function prevById(v, id, loop = true) {
  let idx = indexOfId(v, id);
  if (idx === -1)
    return loop ? v[v.length - 1] : null;
  idx = loop ? (idx - 1 + v.length) % v.length : Math.max(0, idx - 1);
  return v[idx];
}
var sanitize = (str) => str.split("").map((char) => {
  const code = char.charCodeAt(0);
  if (code > 0 && code < 128)
    return char;
  if (code >= 128 && code <= 255)
    return `/x${code.toString(16)}`.replace("/", "\\");
  return "";
}).join("").trim();
var getValueText = (item) => sanitize(item.dataset.valuetext ?? item.textContent ?? "");
var match = (valueText, query2) => valueText.trim().toLowerCase().startsWith(query2.toLowerCase());
var wrap = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};
function getByText(v, text, currentId, itemToId = defaultItemToId) {
  const index = currentId ? indexOfId(v, currentId, itemToId) : -1;
  let items = currentId ? wrap(v, index) : v;
  const isSingleKey = text.length === 1;
  if (isSingleKey) {
    items = items.filter((item) => itemToId(item) !== currentId);
  }
  return items.find((item) => match(getValueText(item), text));
}
function getByTypeaheadImpl(_items, options) {
  const { state: state2, activeId, key, timeout = 350, itemToId } = options;
  const search = state2.keysSoFar + key;
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const query2 = isRepeated ? search[0] : search;
  let items = _items.slice();
  const next = getByText(items, query2, activeId, itemToId);
  function cleanup() {
    clearTimeout(state2.timer);
    state2.timer = -1;
  }
  function update(value) {
    state2.keysSoFar = value;
    cleanup();
    if (value !== "") {
      state2.timer = +setTimeout(() => {
        update("");
        cleanup();
      }, timeout);
    }
  }
  update(search);
  return next;
}
var getByTypeahead = Object.assign(getByTypeaheadImpl, {
  defaultOptions: { keysSoFar: "", timer: -1 },
  isValidEvent: isValidTypeaheadEvent
});
function isValidTypeaheadEvent(event) {
  return event.key.length === 1 && !event.ctrlKey && !event.metaKey;
}
var styleCache = /* @__PURE__ */ new WeakMap();
function getComputedStyle2(el) {
  if (!styleCache.has(el)) {
    styleCache.set(el, getWindow(el).getComputedStyle(el));
  }
  return styleCache.get(el);
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
var isHTMLElement2 = (element) => typeof element === "object" && element !== null && element.nodeType === 1;
var isFrame = (element) => isHTMLElement2(element) && element.tagName === "IFRAME";
function isVisible(el) {
  if (!isHTMLElement2(el))
    return false;
  return el.offsetWidth > 0 || el.offsetHeight > 0 || el.getClientRects().length > 0;
}
function hasNegativeTabIndex(element) {
  const tabIndex = parseInt(element.getAttribute("tabindex") || "0", 10);
  return tabIndex < 0;
}
var focusableSelector = "input:not([type='hidden']):not([disabled]), select:not([disabled]), textarea:not([disabled]), a[href], button:not([disabled]), [tabindex], iframe, object, embed, area[href], audio[controls], video[controls], [contenteditable]:not([contenteditable='false']), details > summary:first-of-type";
var getFocusables = (container, includeContainer = false) => {
  if (!container)
    return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const include = includeContainer == true || includeContainer == "if-empty" && elements.length === 0;
  if (include && isHTMLElement2(container) && isFocusable(container)) {
    elements.unshift(container);
  }
  const focusableElements = elements.filter(isFocusable);
  focusableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      focusableElements.splice(i, 1, ...getFocusables(frameBody));
    }
  });
  return focusableElements;
};
function isFocusable(element) {
  if (!element || element.closest("[inert]"))
    return false;
  return element.matches(focusableSelector) && isVisible(element);
}
function getTabbables(container, includeContainer) {
  if (!container)
    return [];
  const elements = Array.from(container.querySelectorAll(focusableSelector));
  const tabbableElements = elements.filter(isTabbable);
  if (includeContainer && isTabbable(container)) {
    tabbableElements.unshift(container);
  }
  tabbableElements.forEach((element, i) => {
    if (isFrame(element) && element.contentDocument) {
      const frameBody = element.contentDocument.body;
      const allFrameTabbable = getTabbables(frameBody);
      tabbableElements.splice(i, 1, ...allFrameTabbable);
    }
  });
  if (!tabbableElements.length && includeContainer) {
    return elements;
  }
  return tabbableElements;
}
function isTabbable(el) {
  if (el != null && el.tabIndex > 0)
    return true;
  return isFocusable(el) && !hasNegativeTabIndex(el);
}
function getTabbableEdges(container, includeContainer) {
  const elements = getTabbables(container, includeContainer);
  const first2 = elements[0] || null;
  const last2 = elements[elements.length - 1] || null;
  return [first2, last2];
}
function getNextTabbable(container, current) {
  const tabbables = getTabbables(container);
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const currentElement = current ?? doc.activeElement;
  if (!currentElement)
    return null;
  const index = tabbables.indexOf(currentElement);
  return tabbables[index + 1] || null;
}
function getInitialFocus(options) {
  const { root, getInitialEl, filter, enabled = true } = options;
  if (!enabled)
    return;
  let node = null;
  node || (node = typeof getInitialEl === "function" ? getInitialEl() : getInitialEl);
  node || (node = root == null ? void 0 : root.querySelector("[data-autofocus],[autofocus]"));
  if (!node) {
    const tabbables = getTabbables(root);
    node = filter ? tabbables.filter(filter)[0] : tabbables[0];
  }
  return node || root || void 0;
}
function isValidTabEvent(event) {
  const container = event.currentTarget;
  if (!container)
    return false;
  const [firstTabbable, lastTabbable] = getTabbableEdges(container);
  const doc = container.ownerDocument || document;
  if (doc.activeElement === firstTabbable && event.shiftKey)
    return false;
  if (doc.activeElement === lastTabbable && !event.shiftKey)
    return false;
  if (!firstTabbable && !lastTabbable)
    return false;
  return true;
}
function isEditableElement(el) {
  if (el == null || !isHTMLElement(el)) {
    return false;
  }
  try {
    const win = getWindow(el);
    return el instanceof win.HTMLInputElement && el.selectionStart != null || /(textarea|select)/.test(el.localName) || el.isContentEditable;
  } catch {
    return false;
  }
}
function isHiddenElement(node) {
  if (node.parentElement && isHiddenElement(node.parentElement))
    return true;
  return node.hidden;
}
var OVERFLOW_RE = /auto|scroll|overlay|hidden|clip/;
function isOverflowElement(el) {
  const win = getWindow(el);
  const { overflow, overflowX, overflowY, display } = win.getComputedStyle(el);
  return OVERFLOW_RE.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function nextTick(fn) {
  const set24 = /* @__PURE__ */ new Set();
  function raf2(fn2) {
    const id = globalThis.requestAnimationFrame(fn2);
    set24.add(() => globalThis.cancelAnimationFrame(id));
  }
  raf2(() => raf2(fn));
  return function cleanup() {
    set24.forEach((fn2) => fn2());
  };
}
function raf(fn) {
  const id = globalThis.requestAnimationFrame(fn);
  return () => {
    globalThis.cancelAnimationFrame(id);
  };
}
function observeAttributesImpl(node, options) {
  if (!node)
    return;
  const { attributes, callback: fn } = options;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver((changes) => {
    for (const change of changes) {
      if (change.type === "attributes" && change.attributeName && attributes.includes(change.attributeName)) {
        fn(change);
      }
    }
  });
  obs.observe(node, { attributes: true, attributeFilter: attributes });
  return () => obs.disconnect();
}
function observeAttributes(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeAttributesImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function observeChildrenImpl(node, options) {
  const { callback: fn } = options;
  if (!node)
    return;
  const win = node.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(fn);
  obs.observe(node, { childList: true, subtree: true });
  return () => obs.disconnect();
}
function observeChildren(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(observeChildrenImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function getNearestOverflowAncestor(el) {
  const parentNode = getParentNode(el);
  if (isRootElement(parentNode)) {
    return getDocument(parentNode).body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(el, list = []) {
  const scrollableAncestor = getNearestOverflowAncestor(el);
  const isBody = scrollableAncestor === el.ownerDocument.body;
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, []));
}
function proxyTabFocusImpl(container, options = {}) {
  const { triggerElement, onFocus } = options;
  const doc = (container == null ? void 0 : container.ownerDocument) || document;
  const body = doc.body;
  function onKeyDown(event) {
    if (event.key !== "Tab")
      return;
    let elementToFocus = null;
    const [firstTabbable, lastTabbable] = getTabbableEdges(container, true);
    const noTabbableElements = !firstTabbable && !lastTabbable;
    if (event.shiftKey && (doc.activeElement === firstTabbable || noTabbableElements)) {
      elementToFocus = triggerElement;
    } else if (!event.shiftKey && doc.activeElement === triggerElement) {
      elementToFocus = firstTabbable;
    } else if (!event.shiftKey && (doc.activeElement === lastTabbable || noTabbableElements)) {
      elementToFocus = getNextTabbable(body, triggerElement);
    }
    if (!elementToFocus)
      return;
    event.preventDefault();
    if (typeof onFocus === "function") {
      onFocus(elementToFocus);
    } else {
      elementToFocus.focus();
    }
  }
  doc == null ? void 0 : doc.addEventListener("keydown", onKeyDown, true);
  return () => {
    doc == null ? void 0 : doc.removeEventListener("keydown", onKeyDown, true);
  };
}
function proxyTabFocus(container, options) {
  const { defer, triggerElement, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof container === "function" ? container() : container;
      const trigger = typeof triggerElement === "function" ? triggerElement() : triggerElement;
      cleanups2.push(proxyTabFocusImpl(node, { triggerElement: trigger, ...restOptions }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function queryAll(root, selector) {
  return Array.from((root == null ? void 0 : root.querySelectorAll(selector)) ?? []);
}
function query(root, selector) {
  return (root == null ? void 0 : root.querySelector(selector)) ?? null;
}
function createScope(methods) {
  const screen = {
    getRootNode: (ctx) => {
      var _a;
      return ((_a = ctx.getRootNode) == null ? void 0 : _a.call(ctx)) ?? document;
    },
    getDoc: (ctx) => getDocument(screen.getRootNode(ctx)),
    getWin: (ctx) => screen.getDoc(ctx).defaultView ?? window,
    getActiveElement: (ctx) => screen.getDoc(ctx).activeElement,
    isActiveElement: (ctx, elem) => elem === screen.getActiveElement(ctx),
    getById: (ctx, id) => screen.getRootNode(ctx).getElementById(id),
    setValue: (elem, value) => {
      if (elem == null || value == null)
        return;
      const valueAsString = value.toString();
      if (elem.value === valueAsString)
        return;
      elem.value = value.toString();
    }
  };
  return { ...screen, ...methods };
}
function isScrollable(el) {
  return el.scrollHeight > el.clientHeight || el.scrollWidth > el.clientWidth;
}
function scrollIntoView(el, options) {
  const { rootEl, ...scrollOptions } = options || {};
  if (!el || !rootEl) {
    return;
  }
  if (!isOverflowElement(rootEl) || !isScrollable(rootEl)) {
    return;
  }
  el.scrollIntoView(scrollOptions);
}
var cleanups = /* @__PURE__ */ new WeakMap();
function set(element, key, setup) {
  if (!cleanups.has(element)) {
    cleanups.set(element, /* @__PURE__ */ new Map());
  }
  const elementCleanups = cleanups.get(element);
  const prevCleanup = elementCleanups.get(key);
  if (!prevCleanup) {
    elementCleanups.set(key, setup());
    return () => {
      var _a;
      (_a = elementCleanups.get(key)) == null ? void 0 : _a();
      elementCleanups.delete(key);
    };
  }
  const cleanup = setup();
  const nextCleanup = () => {
    cleanup();
    prevCleanup();
    elementCleanups.delete(key);
  };
  elementCleanups.set(key, nextCleanup);
  return () => {
    const isCurrent = elementCleanups.get(key) === nextCleanup;
    if (!isCurrent)
      return;
    cleanup();
    elementCleanups.set(key, prevCleanup);
  };
}
function setStyle(element, style) {
  if (!element)
    return () => {
    };
  const setup = () => {
    const prevStyle = element.style.cssText;
    Object.assign(element.style, style);
    return () => {
      element.style.cssText = prevStyle;
    };
  };
  return set(element, "style", setup);
}
var visuallyHiddenStyle = {
  border: "0",
  clip: "rect(0 0 0 0)",
  height: "1px",
  margin: "-1px",
  overflow: "hidden",
  padding: "0",
  position: "absolute",
  width: "1px",
  whiteSpace: "nowrap",
  wordWrap: "normal"
};
var fps = 1e3 / 60;
function waitForElement(query2, cb) {
  const el = query2();
  if (isHTMLElement(el) && el.isConnected) {
    cb(el);
    return () => void 0;
  } else {
    const timerId = setInterval(() => {
      const el2 = query2();
      if (isHTMLElement(el2) && el2.isConnected) {
        cb(el2);
        clearInterval(timerId);
      }
    }, fps);
    return () => clearInterval(timerId);
  }
}
function waitForElements(queries, cb) {
  const cleanups2 = [];
  queries == null ? void 0 : queries.forEach((query2) => {
    const clean = waitForElement(query2, cb);
    cleanups2.push(clean);
  });
  return () => {
    cleanups2.forEach((fn) => fn());
  };
}

// node_modules/@zag-js/text-selection/dist/index.mjs
var state = "default";
var userSelect = "";
var elementMap = /* @__PURE__ */ new WeakMap();
function disableTextSelectionImpl(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state === "default") {
      userSelect = rootEl.style.webkitUserSelect;
      rootEl.style.webkitUserSelect = "none";
    }
    state = "disabled";
  } else if (target) {
    elementMap.set(target, target.style.userSelect);
    target.style.userSelect = "none";
  }
  return () => restoreTextSelection({ target, doc: docNode });
}
function restoreTextSelection(options = {}) {
  const { target, doc } = options;
  const docNode = doc ?? document;
  const rootEl = docNode.documentElement;
  if (isIos()) {
    if (state !== "disabled")
      return;
    state = "restoring";
    setTimeout(() => {
      nextTick(() => {
        if (state === "restoring") {
          if (rootEl.style.webkitUserSelect === "none") {
            rootEl.style.webkitUserSelect = userSelect || "";
          }
          userSelect = "";
          state = "default";
        }
      });
    }, 300);
  } else {
    if (target && elementMap.has(target)) {
      const prevUserSelect = elementMap.get(target);
      if (target.style.userSelect === "none") {
        target.style.userSelect = prevUserSelect ?? "";
      }
      if (target.getAttribute("style") === "") {
        target.removeAttribute("style");
      }
      elementMap.delete(target);
    }
  }
}
function disableTextSelection(options = {}) {
  const { defer, target, ...restOptions } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof target === "function" ? target() : target;
      cleanups2.push(disableTextSelectionImpl({ ...restOptions, target: node }));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/dom-event/dist/index.mjs
var addDomEvent = (target, eventName, handler, options) => {
  const node = typeof target === "function" ? target() : target;
  node == null ? void 0 : node.addEventListener(eventName, handler, options);
  return () => {
    node == null ? void 0 : node.removeEventListener(eventName, handler, options);
  };
};
function isPrintableKey(e) {
  return e.key.length === 1 && !e.ctrlKey && !e.metaKey;
}
var isLeftClick = (e) => e.button === 0;
var isContextMenuEvent = (e) => {
  return e.button === 2 || isMac() && e.ctrlKey && e.button === 0;
};
var isModifierKey = (e) => e.ctrlKey || e.altKey || e.metaKey;
function queueBeforeEvent(element, type, cb) {
  const createTimer = (callback) => {
    const timerId = requestAnimationFrame(callback);
    return () => cancelAnimationFrame(timerId);
  };
  const cancelTimer = createTimer(() => {
    element.removeEventListener(type, callSync, true);
    cb();
  });
  const callSync = () => {
    cancelTimer();
    cb();
  };
  element.addEventListener(type, callSync, { once: true, capture: true });
  return cancelTimer;
}
function isLinkElement(element) {
  return (element == null ? void 0 : element.matches("a[href]")) ?? false;
}
function clickIfLink(element) {
  if (!isLinkElement(element))
    return;
  const click = () => element.click();
  if (isFirefox()) {
    queueBeforeEvent(element, "keyup", click);
  } else {
    queueMicrotask(click);
  }
}
function fireCustomEvent(el, type, init) {
  if (!el)
    return;
  const win = el.ownerDocument.defaultView || window;
  const event = new win.CustomEvent(type, init);
  return el.dispatchEvent(event);
}
var keyMap = {
  Up: "ArrowUp",
  Down: "ArrowDown",
  Esc: "Escape",
  " ": "Space",
  ",": "Comma",
  Left: "ArrowLeft",
  Right: "ArrowRight"
};
var rtlKeyMap = {
  ArrowLeft: "ArrowRight",
  ArrowRight: "ArrowLeft"
};
function getEventKey(event, options = {}) {
  const { dir = "ltr", orientation = "horizontal" } = options;
  let { key } = event;
  key = keyMap[key] ?? key;
  const isRtl = dir === "rtl" && orientation === "horizontal";
  if (isRtl && key in rtlKeyMap) {
    key = rtlKeyMap[key];
  }
  return key;
}
function pointFromTouch(e, type = "client") {
  const point = e.touches[0] || e.changedTouches[0];
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
function pointFromMouse(point, type = "client") {
  return { x: point[`${type}X`], y: point[`${type}Y`] };
}
var isTouchEvent = (event) => "touches" in event && event.touches.length > 0;
function getEventPoint(event, type = "client") {
  return isTouchEvent(event) ? pointFromTouch(event, type) : pointFromMouse(event, type);
}
var PAGE_KEYS = /* @__PURE__ */ new Set(["PageUp", "PageDown"]);
var ARROW_KEYS = /* @__PURE__ */ new Set(["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"]);
function getEventStep(event) {
  if (event.ctrlKey || event.metaKey) {
    return 0.1;
  } else {
    const isPageKey = PAGE_KEYS.has(event.key);
    const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.has(event.key);
    return isSkipKey ? 10 : 1;
  }
}
function getNativeEvent(event) {
  return event.nativeEvent ?? event;
}
function clamp(value) {
  return Math.max(0, Math.min(1, value));
}
function getRelativePoint(point, element) {
  const { left, top, width, height } = element.getBoundingClientRect();
  const offset3 = { x: point.x - left, y: point.y - top };
  const percent = { x: clamp(offset3.x / width), y: clamp(offset3.y / height) };
  function getPercentValue2(options = {}) {
    const { dir = "ltr", orientation = "horizontal", inverted } = options;
    const invertX = typeof inverted === "object" ? inverted.x : inverted;
    const invertY = typeof inverted === "object" ? inverted.y : inverted;
    if (orientation === "horizontal") {
      return dir === "rtl" || invertX ? 1 - percent.x : percent.x;
    }
    return invertY ? 1 - percent.y : percent.y;
  }
  return { offset: offset3, percent, getPercentValue: getPercentValue2 };
}
function requestPointerLock(doc, fn) {
  const body = doc.body;
  const supported = "pointerLockElement" in doc || "mozPointerLockElement" in doc;
  const isLocked = () => !!doc.pointerLockElement;
  function onPointerChange() {
    fn == null ? void 0 : fn(isLocked());
  }
  function onPointerError(event) {
    if (isLocked())
      fn == null ? void 0 : fn(false);
    console.error("PointerLock error occured:", event);
    doc.exitPointerLock();
  }
  if (!supported)
    return;
  try {
    body.requestPointerLock();
  } catch {
  }
  const cleanup = [
    addDomEvent(doc, "pointerlockchange", onPointerChange, false),
    addDomEvent(doc, "pointerlockerror", onPointerError, false)
  ];
  return () => {
    cleanup.forEach((cleanup2) => cleanup2());
    doc.exitPointerLock();
  };
}
var pipe = (...fns) => (arg) => fns.reduce((acc, fn) => fn(acc), arg);
var noop = () => void 0;
var isValidKey = (e) => {
  return !(e.metaKey || !isMac() && e.altKey || e.ctrlKey || e.key === "Control" || e.key === "Shift" || e.key === "Meta");
};
function trackFocusVisible(node, options) {
  if (!node)
    return;
  const { onFocus, onBlur } = options;
  const win = getWindow(node);
  let focused = false;
  const handleFocus = (e) => {
    let isFocusVisible = false;
    try {
      isFocusVisible = node.matches(":focus-visible");
    } catch {
      isFocusVisible = true;
    }
    if (!isFocusVisible)
      return;
    focused = true;
    onFocus == null ? void 0 : onFocus(e);
  };
  const handleBlur = (e) => {
    if (!focused)
      return;
    focused = false;
    onBlur == null ? void 0 : onBlur(e);
  };
  const handleKeydown = (e) => {
    if (!node.matches(":focus") || !isValidKey(e))
      return;
    focused = true;
    const evt = new win.FocusEvent("focus");
    onFocus == null ? void 0 : onFocus(evt);
  };
  return pipe(
    addDomEvent(node, "focusin", handleFocus),
    addDomEvent(node, "focusout", handleBlur),
    addDomEvent(node, "keydown", handleKeydown, true)
  );
}
function trackPointerMove(doc, handlers) {
  const { onPointerMove, onPointerUp } = handlers;
  const history = [];
  const handleMove = (event) => {
    const point = getEventPoint(event);
    history.push({ ...point, timestamp: performance.now() });
    const distance = Math.sqrt(point.x ** 2 + point.y ** 2);
    const moveBuffer = event.pointerType === "touch" ? 10 : 5;
    if (distance < moveBuffer)
      return;
    if (event.pointerType === "mouse" && event.button === 0) {
      onPointerUp();
      return;
    }
    onPointerMove({ point, event, velocity: getVelocity(history, 0.1) });
  };
  const cleanups2 = [
    addDomEvent(doc, "pointermove", handleMove, false),
    addDomEvent(doc, "pointerup", onPointerUp, false),
    addDomEvent(doc, "pointercancel", onPointerUp, false),
    addDomEvent(doc, "contextmenu", onPointerUp, false),
    disableTextSelection({ doc })
  ];
  return () => {
    cleanups2.forEach((cleanup) => cleanup());
    history.length = 0;
  };
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function ms(seconds) {
  return seconds * 1e3;
}
function sec(milliseconds) {
  return milliseconds / 1e3;
}
function getVelocity(history, timeDelta) {
  if (history.length < 2)
    return { x: 0, y: 0 };
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > ms(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint)
    return { x: 0, y: 0 };
  const time = sec(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0)
    return { x: 0, y: 0 };
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity)
    currentVelocity.x = 0;
  if (currentVelocity.y === Infinity)
    currentVelocity.y = 0;
  return {
    x: Math.abs(currentVelocity.x),
    y: Math.abs(currentVelocity.y)
  };
}
function trackPress(options) {
  const {
    pointerNode,
    keyboardNode = pointerNode,
    onPress,
    onPressStart,
    onPressEnd,
    isValidKey: isValidKey2 = (e) => e.key === "Enter"
  } = options;
  if (!pointerNode)
    return noop;
  const win = getWindow(pointerNode);
  const doc = getDocument(pointerNode);
  let removeStartListeners = noop;
  let removeEndListeners = noop;
  let removeAccessibleListeners = noop;
  const getInfo = (event) => ({
    point: getEventPoint(event),
    event
  });
  function startPress(event) {
    onPressStart == null ? void 0 : onPressStart(getInfo(event));
  }
  function cancelPress(event) {
    onPressEnd == null ? void 0 : onPressEnd(getInfo(event));
  }
  const startPointerPress = (startEvent) => {
    removeEndListeners();
    const endPointerPress = (endEvent) => {
      const target = getEventTarget(endEvent);
      if (contains(pointerNode, target)) {
        onPress == null ? void 0 : onPress(getInfo(endEvent));
      } else {
        onPressEnd == null ? void 0 : onPressEnd(getInfo(endEvent));
      }
    };
    const removePointerUpListener = addDomEvent(win, "pointerup", endPointerPress, { passive: !onPress });
    const removePointerCancelListener = addDomEvent(win, "pointercancel", cancelPress, { passive: !onPressEnd });
    removeEndListeners = pipe(removePointerUpListener, removePointerCancelListener);
    if (doc.activeElement === keyboardNode && startEvent.pointerType === "mouse") {
      startEvent.preventDefault();
    }
    startPress(startEvent);
  };
  const removePointerListener = addDomEvent(pointerNode, "pointerdown", startPointerPress, { passive: !onPressStart });
  const removeFocusListener = addDomEvent(keyboardNode, "focus", startAccessiblePress);
  removeStartListeners = pipe(removePointerListener, removeFocusListener);
  function startAccessiblePress() {
    const handleKeydown = (keydownEvent) => {
      if (!isValidKey2(keydownEvent))
        return;
      const handleKeyup = (keyupEvent) => {
        if (!isValidKey2(keyupEvent))
          return;
        const evt2 = new win.PointerEvent("pointerup");
        const info = getInfo(evt2);
        onPress == null ? void 0 : onPress(info);
        onPressEnd == null ? void 0 : onPressEnd(info);
      };
      removeEndListeners();
      removeEndListeners = addDomEvent(keyboardNode, "keyup", handleKeyup);
      const evt = new win.PointerEvent("pointerdown");
      startPress(evt);
    };
    const handleBlur = () => {
      const evt = new win.PointerEvent("pointercancel");
      cancelPress(evt);
    };
    const removeKeydownListener = addDomEvent(keyboardNode, "keydown", handleKeydown);
    const removeBlurListener = addDomEvent(keyboardNode, "blur", handleBlur);
    removeAccessibleListeners = pipe(removeKeydownListener, removeBlurListener);
  }
  return function() {
    removeStartListeners();
    removeEndListeners();
    removeAccessibleListeners();
  };
}

// node_modules/@zag-js/utils/dist/index.mjs
var first = (v) => v[0];
var last = (v) => v[v.length - 1];
var has = (v, t) => v.indexOf(t) !== -1;
var add = (v, ...items) => v.concat(items);
var remove = (v, item) => v.filter((t) => t !== item);
var removeAt = (v, i) => v.filter((_, idx) => idx !== i);
var addOrRemove = (v, item) => {
  if (has(v, item))
    return remove(v, item);
  return add(v, item);
};
function nextIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  const next2 = idx + step;
  const len = v.length;
  const last2 = len - 1;
  if (idx === -1)
    return step > 0 ? 0 : last2;
  if (next2 < 0)
    return loop ? last2 : 0;
  if (next2 >= len)
    return loop ? 0 : idx > len ? len : idx;
  return next2;
}
function prevIndex(v, idx, opts = {}) {
  const { step = 1, loop = true } = opts;
  return nextIndex(v, idx, { step: -step, loop });
}
var chunk = (v, size3) => {
  const res = [];
  return v.reduce((rows, value, index) => {
    var _a;
    if (index % size3 === 0)
      rows.push([value]);
    else
      (_a = last(rows)) == null ? void 0 : _a.push(value);
    return rows;
  }, res);
};
var isArrayLike = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isEqual = (a2, b2) => {
  if (Object.is(a2, b2))
    return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null)
    return false;
  if (typeof (a2 == null ? void 0 : a2.isEqual) === "function" && typeof (b2 == null ? void 0 : b2.isEqual) === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike(a2) && isArrayLike(b2)) {
    return Array.from(a2).toString() === Array.from(b2).toString();
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object"))
    return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey2 = Reflect.has(a2, keys[i]);
    if (!hasKey2)
      return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual(a2[key], b2[key]))
      return false;
  }
  return true;
};
var runIfFn = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res ?? void 0;
};
var cast = (v) => v;
var noop2 = () => {
};
var callAll = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var uuid = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
function match2(key, record, ...args) {
  var _a;
  if (key in record) {
    const fn = record[key];
    return typeof fn === "function" ? fn(...args) : fn;
  }
  const error = new Error(`No matching key: ${JSON.stringify(key)} in ${JSON.stringify(Object.keys(record))}`);
  (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, match2);
  throw error;
}
var tryCatch = (fn, fallback2) => {
  var _a;
  try {
    return fn();
  } catch (error) {
    if (error instanceof Error) {
      (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, tryCatch);
    }
    return fallback2 == null ? void 0 : fallback2();
  }
};
var isArray = (v) => Array.isArray(v);
var isBoolean = (v) => v === true || v === false;
var isNumber = (v) => typeof v === "number" && !Number.isNaN(v);
var isString = (v) => typeof v === "string";
var isFunction = (v) => typeof v === "function";
var isNull = (v) => v == null;
function compact(obj) {
  if (!isPlainObject(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact(value);
    }
  }
  return filtered;
}
var isPlainObject = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function splitProps(props29, keys) {
  const rest = {};
  const result = {};
  const keySet = new Set(keys);
  for (const key in props29) {
    if (keySet.has(key)) {
      result[key] = props29[key];
    } else {
      rest[key] = props29[key];
    }
  }
  return [result, rest];
}
var createSplitProps = (keys) => {
  return function split(props29) {
    return splitProps(props29, keys);
  };
};
function warn(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}

// node_modules/proxy-compare/dist/index.js
var TRACK_MEMO_SYMBOL = Symbol();
var GET_ORIGINAL_SYMBOL = Symbol();
var AFFECTED_PROPERTY = "a";
var IS_TARGET_COPIED_PROPERTY = "f";
var PROXY_PROPERTY = "p";
var PROXY_CACHE_PROPERTY = "c";
var TARGET_CACHE_PROPERTY = "t";
var NEXT_OBJECT_PROPERTY = "n";
var CHANGED_PROPERTY = "g";
var HAS_KEY_PROPERTY = "h";
var ALL_OWN_KEYS_PROPERTY = "w";
var HAS_OWN_KEY_PROPERTY = "o";
var KEYS_PROPERTY = "k";
var newProxy = (target, handler) => new Proxy(target, handler);
var getProto = Object.getPrototypeOf;
var objectsToTrack = /* @__PURE__ */ new WeakMap();
var isObjectToTrack = (obj) => obj && (objectsToTrack.has(obj) ? objectsToTrack.get(obj) : getProto(obj) === Object.prototype || getProto(obj) === Array.prototype);
var isObject = (x) => typeof x === "object" && x !== null;
var needsToCopyTargetObject = (obj) => Object.values(Object.getOwnPropertyDescriptors(obj)).some((descriptor) => !descriptor.configurable && !descriptor.writable);
var copyTargetObject = (obj) => {
  if (Array.isArray(obj)) {
    return Array.from(obj);
  }
  const descriptors = Object.getOwnPropertyDescriptors(obj);
  Object.values(descriptors).forEach((desc) => {
    desc.configurable = true;
  });
  return Object.create(getProto(obj), descriptors);
};
var createProxyHandler = (origObj, isTargetCopied) => {
  const state2 = {
    [IS_TARGET_COPIED_PROPERTY]: isTargetCopied
  };
  let trackObject = false;
  const recordUsage = (type, key) => {
    if (!trackObject) {
      let used = state2[AFFECTED_PROPERTY].get(origObj);
      if (!used) {
        used = {};
        state2[AFFECTED_PROPERTY].set(origObj, used);
      }
      if (type === ALL_OWN_KEYS_PROPERTY) {
        used[ALL_OWN_KEYS_PROPERTY] = true;
      } else {
        let set24 = used[type];
        if (!set24) {
          set24 = /* @__PURE__ */ new Set();
          used[type] = set24;
        }
        set24.add(key);
      }
    }
  };
  const recordObjectAsUsed = () => {
    trackObject = true;
    state2[AFFECTED_PROPERTY].delete(origObj);
  };
  const handler = {
    get(target, key) {
      if (key === GET_ORIGINAL_SYMBOL) {
        return origObj;
      }
      recordUsage(KEYS_PROPERTY, key);
      return createProxy(Reflect.get(target, key), state2[AFFECTED_PROPERTY], state2[PROXY_CACHE_PROPERTY], state2[TARGET_CACHE_PROPERTY]);
    },
    has(target, key) {
      if (key === TRACK_MEMO_SYMBOL) {
        recordObjectAsUsed();
        return true;
      }
      recordUsage(HAS_KEY_PROPERTY, key);
      return Reflect.has(target, key);
    },
    getOwnPropertyDescriptor(target, key) {
      recordUsage(HAS_OWN_KEY_PROPERTY, key);
      return Reflect.getOwnPropertyDescriptor(target, key);
    },
    ownKeys(target) {
      recordUsage(ALL_OWN_KEYS_PROPERTY);
      return Reflect.ownKeys(target);
    }
  };
  if (isTargetCopied) {
    handler.set = handler.deleteProperty = () => false;
  }
  return [handler, state2];
};
var getOriginalObject = (obj) => (
  // unwrap proxy
  obj[GET_ORIGINAL_SYMBOL] || // otherwise
  obj
);
var createProxy = (obj, affected, proxyCache, targetCache3) => {
  if (!isObjectToTrack(obj))
    return obj;
  let targetAndCopied = targetCache3 && targetCache3.get(obj);
  if (!targetAndCopied) {
    const target2 = getOriginalObject(obj);
    if (needsToCopyTargetObject(target2)) {
      targetAndCopied = [target2, copyTargetObject(target2)];
    } else {
      targetAndCopied = [target2];
    }
    targetCache3 === null || targetCache3 === void 0 ? void 0 : targetCache3.set(obj, targetAndCopied);
  }
  const [target, copiedTarget] = targetAndCopied;
  let handlerAndState = proxyCache && proxyCache.get(target);
  if (!handlerAndState || handlerAndState[1][IS_TARGET_COPIED_PROPERTY] !== !!copiedTarget) {
    handlerAndState = createProxyHandler(target, !!copiedTarget);
    handlerAndState[1][PROXY_PROPERTY] = newProxy(copiedTarget || target, handlerAndState[0]);
    if (proxyCache) {
      proxyCache.set(target, handlerAndState);
    }
  }
  handlerAndState[1][AFFECTED_PROPERTY] = affected;
  handlerAndState[1][PROXY_CACHE_PROPERTY] = proxyCache;
  handlerAndState[1][TARGET_CACHE_PROPERTY] = targetCache3;
  return handlerAndState[1][PROXY_PROPERTY];
};
var isAllOwnKeysChanged = (prevObj, nextObj) => {
  const prevKeys = Reflect.ownKeys(prevObj);
  const nextKeys = Reflect.ownKeys(nextObj);
  return prevKeys.length !== nextKeys.length || prevKeys.some((k, i) => k !== nextKeys[i]);
};
var isChanged = (prevObj, nextObj, affected, cache, isEqual3 = Object.is) => {
  if (isEqual3(prevObj, nextObj)) {
    return false;
  }
  if (!isObject(prevObj) || !isObject(nextObj))
    return true;
  const used = affected.get(getOriginalObject(prevObj));
  if (!used)
    return true;
  if (cache) {
    const hit = cache.get(prevObj);
    if (hit && hit[NEXT_OBJECT_PROPERTY] === nextObj) {
      return hit[CHANGED_PROPERTY];
    }
    cache.set(prevObj, {
      [NEXT_OBJECT_PROPERTY]: nextObj,
      [CHANGED_PROPERTY]: false
    });
  }
  let changed = null;
  try {
    for (const key of used[HAS_KEY_PROPERTY] || []) {
      changed = Reflect.has(prevObj, key) !== Reflect.has(nextObj, key);
      if (changed)
        return changed;
    }
    if (used[ALL_OWN_KEYS_PROPERTY] === true) {
      changed = isAllOwnKeysChanged(prevObj, nextObj);
      if (changed)
        return changed;
    } else {
      for (const key of used[HAS_OWN_KEY_PROPERTY] || []) {
        const hasPrev = !!Reflect.getOwnPropertyDescriptor(prevObj, key);
        const hasNext = !!Reflect.getOwnPropertyDescriptor(nextObj, key);
        changed = hasPrev !== hasNext;
        if (changed)
          return changed;
      }
    }
    for (const key of used[KEYS_PROPERTY] || []) {
      changed = isChanged(prevObj[key], nextObj[key], affected, cache, isEqual3);
      if (changed)
        return changed;
    }
    if (changed === null)
      changed = true;
    return changed;
  } finally {
    if (cache) {
      cache.set(prevObj, {
        [NEXT_OBJECT_PROPERTY]: nextObj,
        [CHANGED_PROPERTY]: changed
      });
    }
  }
};
var trackMemo = (obj) => {
  if (isObjectToTrack(obj)) {
    return TRACK_MEMO_SYMBOL in obj;
  }
  return false;
};
var getUntracked = (obj) => {
  if (isObjectToTrack(obj)) {
    return obj[GET_ORIGINAL_SYMBOL] || null;
  }
  return null;
};
var markToTrack = (obj, mark = true) => {
  objectsToTrack.set(obj, mark);
};

// node_modules/@zag-js/store/dist/index.mjs
function getGlobal() {
  if (typeof globalThis !== "undefined")
    return globalThis;
  if (typeof self !== "undefined")
    return self;
  if (typeof window !== "undefined")
    return window;
  if (typeof global !== "undefined")
    return global;
}
function makeGlobal(key, value) {
  const g = getGlobal();
  if (!g)
    return value();
  g[key] || (g[key] = value());
  return g[key];
}
var isDev = true;
var isObject2 = (x) => typeof x === "object" && x !== null;
var proxyStateMap = makeGlobal("__zag__proxyStateMap", () => /* @__PURE__ */ new WeakMap());
var refSet = makeGlobal("__zag__refSet", () => /* @__PURE__ */ new WeakSet());
var buildProxyFunction = (objectIs = Object.is, newProxy2 = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject2(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {
  switch (promise.status) {
    case "fulfilled":
      return promise.value;
    case "rejected":
      throw promise.reason;
    default:
      throw promise;
  }
}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {
  const cache = snapCache.get(target);
  if ((cache == null ? void 0 : cache[0]) === version) {
    return cache[1];
  }
  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));
  markToTrack(snap, true);
  snapCache.set(target, [version, snap]);
  Reflect.ownKeys(target).forEach((key) => {
    const value = Reflect.get(target, key);
    if (refSet.has(value)) {
      markToTrack(value, false);
      snap[key] = value;
    } else if (value instanceof Promise) {
      Object.defineProperty(snap, key, {
        get() {
          return handlePromise(value);
        }
      });
    } else if (proxyStateMap.has(value)) {
      snap[key] = snapshot(value, handlePromise);
    } else {
      snap[key] = value;
    }
  });
  return Object.freeze(snap);
}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {
  if (!isObject2(initialObject)) {
    throw new Error("object required");
  }
  const found = proxyCache.get(initialObject);
  if (found) {
    return found;
  }
  let version = versionHolder[0];
  const listeners = /* @__PURE__ */ new Set();
  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {
    if (version !== nextVersion) {
      version = nextVersion;
      listeners.forEach((listener) => listener(op, nextVersion));
    }
  };
  let checkVersion = versionHolder[1];
  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {
    if (checkVersion !== nextCheckVersion && !listeners.size) {
      checkVersion = nextCheckVersion;
      propProxyStates.forEach(([propProxyState]) => {
        const propVersion = propProxyState[1](nextCheckVersion);
        if (propVersion > version) {
          version = propVersion;
        }
      });
    }
    return version;
  };
  const createPropListener = (prop) => (op, nextVersion) => {
    const newOp = [...op];
    newOp[1] = [prop, ...newOp[1]];
    notifyUpdate(newOp, nextVersion);
  };
  const propProxyStates = /* @__PURE__ */ new Map();
  const addPropListener = (prop, propProxyState) => {
    if (isDev && propProxyStates.has(prop)) {
      throw new Error("prop listener already exists");
    }
    if (listeners.size) {
      const remove2 = propProxyState[3](createPropListener(prop));
      propProxyStates.set(prop, [propProxyState, remove2]);
    } else {
      propProxyStates.set(prop, [propProxyState]);
    }
  };
  const removePropListener = (prop) => {
    var _a;
    const entry = propProxyStates.get(prop);
    if (entry) {
      propProxyStates.delete(prop);
      (_a = entry[1]) == null ? void 0 : _a.call(entry);
    }
  };
  const addListener = (listener) => {
    listeners.add(listener);
    if (listeners.size === 1) {
      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {
        if (isDev && prevRemove) {
          throw new Error("remove already exists");
        }
        const remove2 = propProxyState[3](createPropListener(prop));
        propProxyStates.set(prop, [propProxyState, remove2]);
      });
    }
    const removeListener = () => {
      listeners.delete(listener);
      if (listeners.size === 0) {
        propProxyStates.forEach(([propProxyState, remove2], prop) => {
          if (remove2) {
            remove2();
            propProxyStates.set(prop, [propProxyState]);
          }
        });
      }
    };
    return removeListener;
  };
  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));
  const handler = {
    deleteProperty(target, prop) {
      const prevValue = Reflect.get(target, prop);
      removePropListener(prop);
      const deleted = Reflect.deleteProperty(target, prop);
      if (deleted) {
        notifyUpdate(["delete", [prop], prevValue]);
      }
      return deleted;
    },
    set(target, prop, value, receiver) {
      var _a;
      const hasPrevValue = Reflect.has(target, prop);
      const prevValue = Reflect.get(target, prop, receiver);
      if (hasPrevValue && (objectIs(prevValue, value) || proxyCache.has(value) && objectIs(prevValue, proxyCache.get(value)))) {
        return true;
      }
      removePropListener(prop);
      if (isObject2(value)) {
        value = getUntracked(value) || value;
      }
      let nextValue = value;
      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) {
      } else if (value instanceof Promise) {
        value.then((v) => {
          Object.assign(value, { status: "fulfilled", value: v });
          notifyUpdate(["resolve", [prop], v]);
        }).catch((e) => {
          Object.assign(value, { status: "rejected", reason: e });
          notifyUpdate(["reject", [prop], e]);
        });
      } else {
        if (!proxyStateMap.has(value) && canProxy(value)) {
          nextValue = proxy(value);
        }
        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);
        if (childProxyState) {
          addPropListener(prop, childProxyState);
        }
      }
      Reflect.set(target, prop, nextValue, receiver);
      notifyUpdate(["set", [prop], value, prevValue]);
      return true;
    }
  };
  const proxyObject = newProxy2(baseObject, handler);
  proxyCache.set(initialObject, proxyObject);
  const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];
  proxyStateMap.set(proxyObject, proxyState);
  Reflect.ownKeys(initialObject).forEach((key) => {
    const desc = Object.getOwnPropertyDescriptor(initialObject, key);
    if (desc.get || desc.set) {
      Object.defineProperty(baseObject, key, desc);
    } else {
      proxyObject[key] = initialObject[key];
    }
  });
  return proxyObject;
}) => [
  // public functions
  proxyFunction2,
  // shared state
  proxyStateMap,
  refSet,
  // internal things
  objectIs,
  newProxy2,
  canProxy,
  defaultHandlePromise,
  snapCache,
  createSnapshot,
  proxyCache,
  versionHolder
];
var [proxyFunction] = buildProxyFunction();
function proxy(initialObject = {}) {
  return proxyFunction(initialObject);
}
function subscribe(proxyObject, callback, notifyInSync) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev && !proxyState) {
    console.warn("Please use proxy object");
  }
  let promise;
  const ops = [];
  const addListener = proxyState[3];
  let isListenerActive = false;
  const listener = (op) => {
    ops.push(op);
    if (notifyInSync) {
      callback(ops.splice(0));
      return;
    }
    if (!promise) {
      promise = Promise.resolve().then(() => {
        promise = void 0;
        if (isListenerActive) {
          callback(ops.splice(0));
        }
      });
    }
  };
  const removeListener = addListener(listener);
  isListenerActive = true;
  return () => {
    isListenerActive = false;
    removeListener();
  };
}
function snapshot(proxyObject, handlePromise) {
  const proxyState = proxyStateMap.get(proxyObject);
  if (isDev && !proxyState) {
    console.warn("Please use proxy object");
  }
  const [target, ensureVersion, createSnapshot] = proxyState;
  return createSnapshot(target, ensureVersion(), handlePromise);
}
function ref(obj) {
  refSet.add(obj);
  return obj;
}
function proxyWithComputed(initialObject, computedFns) {
  const keys = Object.keys(computedFns);
  keys.forEach((key) => {
    if (Object.getOwnPropertyDescriptor(initialObject, key)) {
      throw new Error("object property already defined");
    }
    const computedFn = computedFns[key];
    const { get, set: set24 } = typeof computedFn === "function" ? { get: computedFn } : computedFn;
    const desc = {};
    desc.get = () => get(snapshot(proxyObject));
    if (set24) {
      desc.set = (newValue) => set24(proxyObject, newValue);
    }
    Object.defineProperty(initialObject, key, desc);
  });
  const proxyObject = proxy(initialObject);
  return proxyObject;
}

// node_modules/klona/full/index.mjs
function set2(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object")
    return x;
  var i = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i < list.length; i++) {
      set2(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));
    }
    for (i = 0, list = Object.getOwnPropertyNames(x); i < list.length; i++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i]) && tmp[k] === x[k])
        continue;
      set2(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}

// node_modules/@zag-js/core/dist/index.mjs
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
function clear(v) {
  while (v.length > 0)
    v.pop();
  return v;
}
var runIfFn2 = (v, ...a2) => {
  const res = typeof v === "function" ? v(...a2) : v;
  return res ?? void 0;
};
var cast2 = (v) => v;
var noop3 = () => {
};
var callAll2 = (...fns) => (...a2) => {
  fns.forEach(function(fn) {
    fn == null ? void 0 : fn(...a2);
  });
};
var uuid2 = /* @__PURE__ */ (() => {
  let id = 0;
  return () => {
    id++;
    return id.toString(36);
  };
})();
var isDev2 = () => true;
var isArray2 = (v) => Array.isArray(v);
var isObject3 = (v) => !(v == null || typeof v !== "object" || isArray2(v));
var isNumber2 = (v) => typeof v === "number" && !Number.isNaN(v);
var isString2 = (v) => typeof v === "string";
var isFunction2 = (v) => typeof v === "function";
var hasProp = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
function compact2(obj) {
  if (!isPlainObject2(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact2(value);
    }
  }
  return filtered;
}
var isPlainObject2 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function warn2(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    console.warn(m);
  }
}
function invariant2(...a2) {
  const m = a2.length === 1 ? a2[0] : a2[1];
  const c = a2.length === 2 ? a2[0] : true;
  if (c && true) {
    throw new Error(m);
  }
}
function deepMerge(source, ...objects) {
  for (const obj of objects) {
    const target = compact2(obj);
    for (const key in target) {
      if (isObject3(obj[key])) {
        if (!source[key]) {
          source[key] = {};
        }
        deepMerge(source[key], obj[key]);
      } else {
        source[key] = obj[key];
      }
    }
  }
  return source;
}
function structuredClone(v) {
  return klona(v);
}
function toEvent(event) {
  const obj = isString2(event) ? { type: event } : event;
  return obj;
}
function toArray(value) {
  if (!value)
    return [];
  return isArray2(value) ? value.slice() : [value];
}
function isGuardHelper(value) {
  return isObject3(value) && value.predicate != null;
}
var Truthy = () => true;
function exec(guardMap, ctx, event, meta) {
  return (guard) => {
    var _a;
    if (isString2(guard)) {
      return !!((_a = guardMap[guard]) == null ? void 0 : _a.call(guardMap, ctx, event, meta));
    }
    if (isFunction2(guard)) {
      return guard(ctx, event, meta);
    }
    return guard.predicate(guardMap)(ctx, event, meta);
  };
}
function or(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).some(Boolean)
  };
}
function and(...conditions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => conditions.map(exec(guardMap, ctx, event, meta)).every(Boolean)
  };
}
function not(condition) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      return !exec(guardMap, ctx, event, meta)(condition);
    }
  };
}
function stateIn(...values) {
  return (_ctx, _evt, meta) => meta.state.matches(...values);
}
var guards = { or, and, not, stateIn };
function choose(actions) {
  return {
    predicate: (guardMap) => (ctx, event, meta) => {
      var _a;
      return (_a = actions.find((def) => {
        const guard = def.guard ?? Truthy;
        return exec(guardMap, ctx, event, meta)(guard);
      })) == null ? void 0 : _a.actions;
    }
  };
}
function determineGuardFn(guard, guardMap) {
  guard = guard ?? Truthy;
  return (context, event, meta) => {
    if (isString2(guard)) {
      const value = guardMap[guard];
      return isFunction2(value) ? value(context, event, meta) : value;
    }
    if (isGuardHelper(guard)) {
      return guard.predicate(guardMap)(context, event, meta);
    }
    return guard == null ? void 0 : guard(context, event, meta);
  };
}
function determineActionsFn(values, guardMap) {
  return (context, event, meta) => {
    if (isGuardHelper(values)) {
      return values.predicate(guardMap)(context, event, meta);
    }
    return values;
  };
}
function createProxy2(config) {
  var _a, _b;
  const computedContext = config.computed ?? cast2({});
  const initialContext = config.context ?? cast2({});
  const initialTags = config.initial ? (_b = (_a = config.states) == null ? void 0 : _a[config.initial]) == null ? void 0 : _b.tags : [];
  const state2 = proxy({
    value: config.initial ?? "",
    previousValue: "",
    event: cast2({}),
    previousEvent: cast2({}),
    context: proxyWithComputed(initialContext, computedContext),
    done: false,
    tags: initialTags ?? [],
    hasTag(tag) {
      return this.tags.includes(tag);
    },
    matches(...value) {
      return value.includes(this.value);
    },
    can(event) {
      return cast2(this).nextEvents.includes(event);
    },
    get nextEvents() {
      var _a2, _b2;
      const stateEvents = ((_b2 = (_a2 = config.states) == null ? void 0 : _a2[this.value]) == null ? void 0 : _b2["on"]) ?? {};
      const globalEvents = (config == null ? void 0 : config.on) ?? {};
      return Object.keys({ ...stateEvents, ...globalEvents });
    },
    get changed() {
      if (this.event.value === "machine.init" || !this.previousValue)
        return false;
      return this.value !== this.previousValue;
    }
  });
  return cast2(state2);
}
function determineDelayFn(delay3, delaysMap) {
  return (context, event) => {
    if (isNumber2(delay3))
      return delay3;
    if (isFunction2(delay3)) {
      return delay3(context, event);
    }
    if (isString2(delay3)) {
      const value = Number.parseFloat(delay3);
      if (!Number.isNaN(value)) {
        return value;
      }
      if (delaysMap) {
        const valueOrFn = delaysMap == null ? void 0 : delaysMap[delay3];
        invariant2(
          valueOrFn == null,
          `[@zag-js/core > determine-delay] Cannot determine delay for \`${delay3}\`. It doesn't exist in \`options.delays\``
        );
        return isFunction2(valueOrFn) ? valueOrFn(context, event) : valueOrFn;
      }
    }
  };
}
function toTarget(target) {
  return isString2(target) ? { target } : target;
}
function determineTransitionFn(transitions, guardMap) {
  return (context, event, meta) => {
    return toArray(transitions).map(toTarget).find((transition) => {
      const determineGuard = determineGuardFn(transition.guard, guardMap);
      const guard = determineGuard(context, event, meta);
      return guard ?? transition.target ?? transition.actions;
    });
  };
}
var Machine = class {
  // Let's get started!
  constructor(config, options) {
    var _a, _b, _c, _d, _e2;
    __publicField(
      this,
      "status",
      "Not Started"
      /* NotStarted */
    );
    __publicField(this, "state");
    __publicField(this, "initialState");
    __publicField(this, "initialContext");
    __publicField(this, "id");
    __publicField(
      this,
      "type",
      "machine"
      /* Machine */
    );
    __publicField(this, "activityEvents", /* @__PURE__ */ new Map());
    __publicField(this, "delayedEvents", /* @__PURE__ */ new Map());
    __publicField(this, "stateListeners", /* @__PURE__ */ new Set());
    __publicField(this, "doneListeners", /* @__PURE__ */ new Set());
    __publicField(this, "contextWatchers", /* @__PURE__ */ new Set());
    __publicField(this, "removeStateListener", noop3);
    __publicField(this, "parent");
    __publicField(this, "children", /* @__PURE__ */ new Map());
    __publicField(this, "guardMap");
    __publicField(this, "actionMap");
    __publicField(this, "delayMap");
    __publicField(this, "activityMap");
    __publicField(this, "sync");
    __publicField(this, "options");
    __publicField(this, "config");
    __publicField(this, "_created", () => {
      var _a2;
      const event = toEvent(
        "machine.created"
        /* Created */
      );
      this.executeActions((_a2 = this.config) == null ? void 0 : _a2.created, event);
    });
    __publicField(this, "start", (init) => {
      this.state.value = "";
      this.state.tags = [];
      if (this.status === "Running") {
        return this;
      }
      this.status = "Running";
      this.removeStateListener = subscribe(
        this.state,
        () => {
          this.stateListeners.forEach((listener) => {
            listener(this.stateSnapshot);
          });
        },
        this.sync
      );
      this.setupContextWatchers();
      this.executeActivities(
        toEvent(
          "machine.start"
          /* Start */
        ),
        toArray(this.config.activities),
        "machine.start"
        /* Start */
      );
      this.executeActions(this.config.entry, toEvent(
        "machine.start"
        /* Start */
      ));
      const event = toEvent(
        "machine.init"
        /* Init */
      );
      const target = isObject3(init) ? init.value : init;
      const context = isObject3(init) ? init.context : void 0;
      if (context) {
        this.setContext(context);
      }
      const transition = {
        target: target ?? this.config.initial
      };
      const next = this.getNextStateInfo(transition, event);
      this.initialState = next;
      this.performStateChangeEffects(this.state.value, next, event);
      return this;
    });
    __publicField(this, "setupContextWatchers", () => {
      const { watch } = this.config;
      if (!watch)
        return;
      let prev = snapshot(this.state.context);
      const cleanup = subscribe(this.state.context, () => {
        var _a2;
        const next = snapshot(this.state.context);
        for (const [key, fn] of Object.entries(watch)) {
          const isEqual3 = ((_a2 = this.options.compareFns) == null ? void 0 : _a2[key]) ?? Object.is;
          if (isEqual3(prev[key], next[key]))
            continue;
          this.executeActions(fn, this.state.event);
        }
        prev = next;
      });
      this.contextWatchers.add(cleanup);
    });
    __publicField(this, "stop", () => {
      if (this.status === "Stopped")
        return;
      this.performExitEffects(this.state.value, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.executeActions(this.config.exit, toEvent(
        "machine.stop"
        /* Stop */
      ));
      this.setState("");
      this.setEvent(
        "machine.stop"
        /* Stop */
      );
      this.stopStateListeners();
      this.stopChildren();
      this.stopActivities();
      this.stopDelayedEvents();
      this.stopContextWatchers();
      this.status = "Stopped";
      return this;
    });
    __publicField(this, "stopStateListeners", () => {
      this.removeStateListener();
      this.stateListeners.clear();
    });
    __publicField(this, "stopContextWatchers", () => {
      this.contextWatchers.forEach((fn) => fn());
      this.contextWatchers.clear();
    });
    __publicField(this, "stopDelayedEvents", () => {
      this.delayedEvents.forEach((state2) => {
        state2.forEach((stop) => stop());
      });
      this.delayedEvents.clear();
    });
    __publicField(this, "stopActivities", (state2) => {
      var _a2, _b2;
      if (state2) {
        (_a2 = this.activityEvents.get(state2)) == null ? void 0 : _a2.forEach((stop) => stop());
        (_b2 = this.activityEvents.get(state2)) == null ? void 0 : _b2.clear();
        this.activityEvents.delete(state2);
      } else {
        this.activityEvents.forEach((state22) => {
          state22.forEach((stop) => stop());
          state22.clear();
        });
        this.activityEvents.clear();
      }
    });
    __publicField(this, "sendChild", (evt, to) => {
      const event = toEvent(evt);
      const id = runIfFn2(to, this.contextSnapshot);
      const child = this.children.get(id);
      if (!child) {
        invariant2(`[@zag-js/core] Cannot send '${event.type}' event to unknown child`);
      }
      child.send(event);
    });
    __publicField(this, "stopChild", (id) => {
      if (!this.children.has(id)) {
        invariant2(`[@zag-js/core > stop-child] Cannot stop unknown child ${id}`);
      }
      this.children.get(id).stop();
      this.children.delete(id);
    });
    __publicField(this, "removeChild", (id) => {
      this.children.delete(id);
    });
    __publicField(this, "stopChildren", () => {
      this.children.forEach((child) => child.stop());
      this.children.clear();
    });
    __publicField(this, "setParent", (parent) => {
      this.parent = parent;
    });
    __publicField(this, "spawn", (src, id) => {
      const actor = runIfFn2(src);
      if (id)
        actor.id = id;
      actor.type = "machine.actor";
      actor.setParent(this);
      this.children.set(actor.id, cast2(actor));
      actor.onDone(() => {
        this.removeChild(actor.id);
      }).start();
      return cast2(ref(actor));
    });
    __publicField(this, "stopActivity", (key) => {
      var _a2;
      if (!this.state.value)
        return;
      const cleanups2 = this.activityEvents.get(this.state.value);
      (_a2 = cleanups2 == null ? void 0 : cleanups2.get(key)) == null ? void 0 : _a2();
      cleanups2 == null ? void 0 : cleanups2.delete(key);
    });
    __publicField(this, "addActivityCleanup", (state2, key, cleanup) => {
      var _a2;
      if (!state2)
        return;
      if (!this.activityEvents.has(state2)) {
        this.activityEvents.set(state2, /* @__PURE__ */ new Map([[key, cleanup]]));
      } else {
        (_a2 = this.activityEvents.get(state2)) == null ? void 0 : _a2.set(key, cleanup);
      }
    });
    __publicField(this, "setState", (target) => {
      this.state.previousValue = this.state.value;
      this.state.value = target;
      const stateNode = this.getStateNode(target);
      if (target == null) {
        clear(this.state.tags);
      } else {
        this.state.tags = toArray(stateNode == null ? void 0 : stateNode.tags);
      }
    });
    __publicField(this, "setContext", (context) => {
      if (!context)
        return;
      deepMerge(this.state.context, compact2(context));
    });
    __publicField(this, "setOptions", (options2) => {
      const opts = compact2(options2);
      this.actionMap = { ...this.actionMap, ...opts.actions };
      this.delayMap = { ...this.delayMap, ...opts.delays };
      this.activityMap = { ...this.activityMap, ...opts.activities };
      this.guardMap = { ...this.guardMap, ...opts.guards };
    });
    __publicField(this, "getStateNode", (state2) => {
      var _a2;
      if (!state2)
        return;
      return (_a2 = this.config.states) == null ? void 0 : _a2[state2];
    });
    __publicField(this, "getNextStateInfo", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      const isTargetless = !(transition == null ? void 0 : transition.target);
      const target = (transition == null ? void 0 : transition.target) ?? this.state.value;
      const changed = this.state.value !== target;
      const stateNode = this.getStateNode(target);
      const reenter = !isTargetless && !changed && !(transition == null ? void 0 : transition.internal);
      const info = {
        reenter,
        transition,
        stateNode,
        target,
        changed
      };
      this.log("NextState:", `[${event.type}]`, this.state.value, "---->", info.target);
      return info;
    });
    __publicField(this, "getAfterActions", (transition, delay3) => {
      let id;
      return {
        entry: () => {
          id = globalThis.setTimeout(() => {
            const next = this.getNextStateInfo(transition, this.state.event);
            this.performStateChangeEffects(this.state.value, next, this.state.event);
          }, delay3);
        },
        exit: () => {
          globalThis.clearTimeout(id);
        }
      };
    });
    __publicField(this, "getDelayedEventActions", (state2) => {
      const stateNode = this.getStateNode(state2);
      const event = this.state.event;
      if (!stateNode || !stateNode.after)
        return;
      const entries = [];
      const exits = [];
      if (isArray2(stateNode.after)) {
        const transition = this.determineTransition(stateNode.after, event);
        if (!transition)
          return;
        if (!hasProp(transition, "delay")) {
          throw new Error(`[@zag-js/core > after] Delay is required for after transition: ${JSON.stringify(transition)}`);
        }
        const determineDelay = determineDelayFn(transition.delay, this.delayMap);
        const __delay = determineDelay(this.contextSnapshot, event);
        const actions = this.getAfterActions(transition, __delay);
        entries.push(actions.entry);
        exits.push(actions.exit);
        return { entries, exits };
      }
      if (isObject3(stateNode.after)) {
        for (const delay3 in stateNode.after) {
          const transition = stateNode.after[delay3];
          const determineDelay = determineDelayFn(delay3, this.delayMap);
          const __delay = determineDelay(this.contextSnapshot, event);
          const actions = this.getAfterActions(transition, __delay);
          entries.push(actions.entry);
          exits.push(actions.exit);
        }
      }
      return { entries, exits };
    });
    __publicField(this, "executeActions", (actions, event) => {
      var _a2;
      const pickedActions = determineActionsFn(actions, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      for (const action of toArray(pickedActions)) {
        const fn = isString2(action) ? (_a2 = this.actionMap) == null ? void 0 : _a2[action] : action;
        warn2(
          isString2(action) && !fn,
          `[@zag-js/core > execute-actions] No implementation found for action: \`${action}\``
        );
        fn == null ? void 0 : fn(this.state.context, event, this.meta);
      }
    });
    __publicField(this, "executeActivities", (event, activities, state2) => {
      var _a2;
      for (const activity of activities) {
        const fn = isString2(activity) ? (_a2 = this.activityMap) == null ? void 0 : _a2[activity] : activity;
        if (!fn) {
          warn2(`[@zag-js/core > execute-activity] No implementation found for activity: \`${activity}\``);
          continue;
        }
        const cleanup = fn(this.state.context, event, this.meta);
        if (cleanup) {
          const key = isString2(activity) ? activity : activity.name || uuid2();
          this.addActivityCleanup(state2 ?? this.state.value, key, cleanup);
        }
      }
    });
    __publicField(this, "createEveryActivities", (every, callbackfn) => {
      if (!every)
        return;
      if (isArray2(every)) {
        const picked = toArray(every).find((transition) => {
          const delayOrFn = transition.delay;
          const determineDelay2 = determineDelayFn(delayOrFn, this.delayMap);
          const delay22 = determineDelay2(this.contextSnapshot, this.state.event);
          const determineGuard = determineGuardFn(transition.guard, this.guardMap);
          const guard = determineGuard(this.contextSnapshot, this.state.event, this.guardMeta);
          return guard ?? delay22 != null;
        });
        if (!picked)
          return;
        const determineDelay = determineDelayFn(picked.delay, this.delayMap);
        const delay3 = determineDelay(this.contextSnapshot, this.state.event);
        const activity = () => {
          const id = globalThis.setInterval(() => {
            this.executeActions(picked.actions, this.state.event);
          }, delay3);
          return () => {
            globalThis.clearInterval(id);
          };
        };
        callbackfn(activity);
      } else {
        for (const interval in every) {
          const actions = every == null ? void 0 : every[interval];
          const determineDelay = determineDelayFn(interval, this.delayMap);
          const delay3 = determineDelay(this.contextSnapshot, this.state.event);
          const activity = () => {
            const id = globalThis.setInterval(() => {
              this.executeActions(actions, this.state.event);
            }, delay3);
            return () => {
              globalThis.clearInterval(id);
            };
          };
          callbackfn(activity);
        }
      }
    });
    __publicField(this, "setEvent", (event) => {
      this.state.previousEvent = this.state.event;
      this.state.event = ref(toEvent(event));
    });
    __publicField(this, "performExitEffects", (current, event) => {
      const currentState = this.state.value;
      if (currentState === "")
        return;
      const stateNode = current ? this.getStateNode(current) : void 0;
      this.stopActivities(currentState);
      const _exit = determineActionsFn(stateNode == null ? void 0 : stateNode.exit, this.guardMap)(this.contextSnapshot, event, this.guardMeta);
      const exitActions = toArray(_exit);
      const afterExitActions = this.delayedEvents.get(currentState);
      if (afterExitActions) {
        exitActions.push(...afterExitActions);
      }
      this.executeActions(exitActions, event);
    });
    __publicField(this, "performEntryEffects", (next, event) => {
      const stateNode = this.getStateNode(next);
      const activities = toArray(stateNode == null ? void 0 : stateNode.activities);
      this.createEveryActivities(stateNode == null ? void 0 : stateNode.every, (activity) => {
        activities.unshift(activity);
      });
      if (activities.length > 0) {
        this.executeActivities(event, activities);
      }
      const pickedActions = determineActionsFn(stateNode == null ? void 0 : stateNode.entry, this.guardMap)(
        this.contextSnapshot,
        event,
        this.guardMeta
      );
      const entryActions = toArray(pickedActions);
      const afterActions = this.getDelayedEventActions(next);
      if ((stateNode == null ? void 0 : stateNode.after) && afterActions) {
        this.delayedEvents.set(next, afterActions == null ? void 0 : afterActions.exits);
        entryActions.push(...afterActions.entries);
      }
      this.executeActions(entryActions, event);
      if ((stateNode == null ? void 0 : stateNode.type) === "final") {
        this.state.done = true;
        this.doneListeners.forEach((listener) => {
          listener(this.stateSnapshot);
        });
        this.stop();
      }
    });
    __publicField(this, "performTransitionEffects", (transitions, event) => {
      const transition = this.determineTransition(transitions, event);
      this.executeActions(transition == null ? void 0 : transition.actions, event);
    });
    __publicField(this, "performStateChangeEffects", (current, next, event) => {
      this.setEvent(event);
      const changed = next.changed || next.reenter;
      if (changed) {
        this.performExitEffects(current, event);
      }
      this.performTransitionEffects(next.transition, event);
      this.setState(next.target);
      if (changed) {
        this.performEntryEffects(next.target, event);
      }
    });
    __publicField(this, "determineTransition", (transition, event) => {
      const fn = determineTransitionFn(transition, this.guardMap);
      return fn == null ? void 0 : fn(this.contextSnapshot, event, this.guardMeta);
    });
    __publicField(this, "sendParent", (evt) => {
      var _a2;
      if (!this.parent) {
        invariant2("[@zag-js/core > send-parent] Cannot send event to an unknown parent");
      }
      const event = toEvent(evt);
      (_a2 = this.parent) == null ? void 0 : _a2.send(event);
    });
    __publicField(this, "log", (...args) => {
      if (isDev2() && this.options.debug) {
        console.log(...args);
      }
    });
    __publicField(this, "send", (evt) => {
      const event = toEvent(evt);
      this.transition(this.state.value, event);
    });
    __publicField(this, "transition", (state2, evt) => {
      var _a2, _b2;
      const stateNode = isString2(state2) ? this.getStateNode(state2) : state2 == null ? void 0 : state2.stateNode;
      const event = toEvent(evt);
      if (!stateNode && !this.config.on) {
        const msg = this.status === "Stopped" ? "[@zag-js/core > transition] Cannot transition a stopped machine" : `[@zag-js/core > transition] State does not have a definition for \`state\`: ${state2}, \`event\`: ${event.type}`;
        warn2(msg);
        return;
      }
      const transitions = ((_a2 = stateNode == null ? void 0 : stateNode.on) == null ? void 0 : _a2[event.type]) ?? ((_b2 = this.config.on) == null ? void 0 : _b2[event.type]);
      const next = this.getNextStateInfo(transitions, event);
      this.performStateChangeEffects(this.state.value, next, event);
      return next.stateNode;
    });
    __publicField(this, "subscribe", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return () => {
        this.stateListeners.delete(listener);
      };
    });
    __publicField(this, "onDone", (listener) => {
      this.doneListeners.add(listener);
      return this;
    });
    __publicField(this, "onTransition", (listener) => {
      this.stateListeners.add(listener);
      if (this.status === "Running") {
        listener(this.stateSnapshot);
      }
      return this;
    });
    this.config = structuredClone(config);
    this.options = structuredClone(options ?? {});
    this.id = this.config.id ?? `machine-${uuid2()}`;
    this.guardMap = ((_a = this.options) == null ? void 0 : _a.guards) ?? {};
    this.actionMap = ((_b = this.options) == null ? void 0 : _b.actions) ?? {};
    this.delayMap = ((_c = this.options) == null ? void 0 : _c.delays) ?? {};
    this.activityMap = ((_d = this.options) == null ? void 0 : _d.activities) ?? {};
    this.sync = ((_e2 = this.options) == null ? void 0 : _e2.sync) ?? false;
    this.state = createProxy2(this.config);
    this.initialContext = snapshot(this.state.context);
  }
  // immutable state value
  get stateSnapshot() {
    return cast2(snapshot(this.state));
  }
  getState() {
    return this.stateSnapshot;
  }
  // immutable context value
  get contextSnapshot() {
    return this.stateSnapshot.context;
  }
  /**
   * A reference to the instance methods of the machine.
   * Useful when spawning child machines and managing the communication between them.
   */
  get self() {
    const self2 = this;
    return {
      id: this.id,
      send: this.send.bind(this),
      sendParent: this.sendParent.bind(this),
      sendChild: this.sendChild.bind(this),
      stop: this.stop.bind(this),
      stopChild: this.stopChild.bind(this),
      spawn: this.spawn.bind(this),
      stopActivity: this.stopActivity.bind(this),
      get state() {
        return self2.stateSnapshot;
      },
      get initialContext() {
        return self2.initialContext;
      },
      get initialState() {
        var _a;
        return ((_a = self2.initialState) == null ? void 0 : _a.target) ?? "";
      }
    };
  }
  get meta() {
    var _a;
    return {
      state: this.stateSnapshot,
      guards: this.guardMap,
      send: this.send.bind(this),
      self: this.self,
      initialContext: this.initialContext,
      initialState: ((_a = this.initialState) == null ? void 0 : _a.target) ?? "",
      getState: () => this.stateSnapshot,
      getAction: (key) => this.actionMap[key],
      getGuard: (key) => this.guardMap[key]
    };
  }
  get guardMeta() {
    return {
      state: this.stateSnapshot
    };
  }
  get [Symbol.toStringTag]() {
    return "Machine";
  }
};
var createMachine = (config, options) => new Machine(config, options);
var isMachine = (value) => {
  return value instanceof Machine || (value == null ? void 0 : value.type) === "machine";
};
var clsx = (...args) => args.map((str) => {
  var _a;
  return (_a = str == null ? void 0 : str.trim) == null ? void 0 : _a.call(str);
}).filter(Boolean).join(" ");
var CSS_REGEX = /((?:--)?(?:\w+-?)+)\s*:\s*([^;]*)/g;
var serialize = (style) => {
  const res = {};
  let match4;
  while (match4 = CSS_REGEX.exec(style)) {
    res[match4[1]] = match4[2];
  }
  return res;
};
var css = (a2, b2) => {
  if (isString2(a2)) {
    if (isString2(b2))
      return `${a2};${b2}`;
    a2 = serialize(a2);
  } else if (isString2(b2)) {
    b2 = serialize(b2);
  }
  return Object.assign({}, a2 ?? {}, b2 ?? {});
};
function mergeProps(...args) {
  let result = {};
  for (let props29 of args) {
    for (let key in result) {
      if (key.startsWith("on") && typeof result[key] === "function" && typeof props29[key] === "function") {
        result[key] = callAll2(props29[key], result[key]);
        continue;
      }
      if (key === "className" || key === "class") {
        result[key] = clsx(result[key], props29[key]);
        continue;
      }
      if (key === "style") {
        result[key] = css(result[key], props29[key]);
        continue;
      }
      result[key] = props29[key] !== void 0 ? props29[key] : result[key];
    }
    for (let key in props29) {
      if (result[key] === void 0) {
        result[key] = props29[key];
      }
    }
  }
  return result;
}

// node_modules/@zag-js/types/dist/index.mjs
function createNormalizer(fn) {
  return new Proxy({}, {
    get() {
      return fn;
    }
  });
}
var createProps = () => (props29) => Array.from(new Set(props29));

// node_modules/@zag-js/accordion/dist/index.mjs
var anatomy = createAnatomy("accordion").parts("root", "item", "itemTrigger", "itemContent", "itemIndicator");
var parts = anatomy.build();
var dom = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `accordion:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, value)) ?? `accordion:${ctx.id}:item:${value}`;
  },
  getItemContentId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.content) == null ? void 0 : _b.call(_a, value)) ?? `accordion:${ctx.id}:content:${value}`;
  },
  getItemTriggerId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.trigger) == null ? void 0 : _b.call(_a, value)) ?? `accordion:${ctx.id}:trigger:${value}`;
  },
  getRootEl: (ctx) => dom.getById(ctx, dom.getRootId(ctx)),
  getTriggers: (ctx) => {
    const ownerId = CSS.escape(dom.getRootId(ctx));
    const selector = `[aria-controls][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom.getRootEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom.getTriggers(ctx)),
  getLastTriggerEl: (ctx) => last(dom.getTriggers(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom.getTriggers(ctx), dom.getItemTriggerId(ctx, id)),
  getPrevTriggerEl: (ctx, id) => prevById(dom.getTriggers(ctx), dom.getItemTriggerId(ctx, id))
});
function connect(state2, send, normalize) {
  const focusedValue = state2.context.focusedValue;
  const value = state2.context.value;
  const multiple = state2.context.multiple;
  function setValue(value2) {
    let nextValue = value2;
    if (multiple && nextValue.length > 1) {
      nextValue = [nextValue[0]];
    }
    send({ type: "VALUE.SET", value: nextValue });
  }
  function getItemState(props29) {
    return {
      expanded: value.includes(props29.value),
      focused: focusedValue === props29.value,
      disabled: Boolean(props29.disabled ?? state2.context.disabled)
    };
  }
  return {
    focusedValue,
    value,
    setValue,
    getItemState,
    getRootProps() {
      return normalize.element({
        ...parts.root.attrs,
        dir: state2.context.dir,
        id: dom.getRootId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getItemProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts.item.attrs,
        dir: state2.context.dir,
        id: dom.getItemId(state2.context, props29.value),
        "data-state": itemState.expanded ? "open" : "closed",
        "data-focus": dataAttr(itemState.focused),
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation
      });
    },
    getItemContentProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts.itemContent.attrs,
        dir: state2.context.dir,
        role: "region",
        id: dom.getItemContentId(state2.context, props29.value),
        "aria-labelledby": dom.getItemTriggerId(state2.context, props29.value),
        hidden: !itemState.expanded,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemIndicatorProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts.itemIndicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(itemState.disabled),
        "data-focus": dataAttr(itemState.focused),
        "data-orientation": state2.context.orientation
      });
    },
    getItemTriggerProps(props29) {
      const { value: value2 } = props29;
      const itemState = getItemState(props29);
      return normalize.button({
        ...parts.itemTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        id: dom.getItemTriggerId(state2.context, value2),
        "aria-controls": dom.getItemContentId(state2.context, value2),
        "aria-expanded": itemState.expanded,
        disabled: itemState.disabled,
        "data-orientation": state2.context.orientation,
        "aria-disabled": itemState.disabled,
        "data-state": itemState.expanded ? "open" : "closed",
        "data-ownedby": dom.getRootId(state2.context),
        onFocus() {
          if (itemState.disabled)
            return;
          send({ type: "TRIGGER.FOCUS", value: value2 });
        },
        onBlur() {
          if (itemState.disabled)
            return;
          send("TRIGGER.BLUR");
        },
        onClick(event) {
          if (itemState.disabled)
            return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TRIGGER.CLICK", value: value2 });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (itemState.disabled)
            return;
          const keyMap2 = {
            ArrowDown() {
              if (state2.context.isHorizontal)
                return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowUp() {
              if (state2.context.isHorizontal)
                return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            ArrowRight() {
              if (!state2.context.isHorizontal)
                return;
              send({ type: "GOTO.NEXT", value: value2 });
            },
            ArrowLeft() {
              if (!state2.context.isHorizontal)
                return;
              send({ type: "GOTO.PREV", value: value2 });
            },
            Home() {
              send({ type: "GOTO.FIRST", value: value2 });
            },
            End() {
              send({ type: "GOTO.LAST", value: value2 });
            }
          };
          const key = getEventKey(event, {
            dir: state2.context.dir,
            orientation: state2.context.orientation
          });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
var { and: and2, not: not2 } = guards;
function machine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "accordion",
      initial: "idle",
      context: {
        focusedValue: null,
        value: [],
        collapsible: false,
        multiple: false,
        orientation: "vertical",
        ...ctx
      },
      watch: {
        value: "coarseValue",
        multiple: "coarseValue"
      },
      created: "coarseValue",
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal"
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.FOCUS": {
              target: "focused",
              actions: "setFocusedValue"
            }
          }
        },
        focused: {
          on: {
            "GOTO.NEXT": {
              actions: "focusNextTrigger"
            },
            "GOTO.PREV": {
              actions: "focusPrevTrigger"
            },
            "TRIGGER.CLICK": [
              {
                guard: and2("isExpanded", "canToggle"),
                actions: ["collapse"]
              },
              {
                guard: not2("isExpanded"),
                actions: ["expand"]
              }
            ],
            "GOTO.FIRST": {
              actions: "focusFirstTrigger"
            },
            "GOTO.LAST": {
              actions: "focusLastTrigger"
            },
            "TRIGGER.BLUR": {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        canToggle: (ctx2) => !!ctx2.collapsible || !!ctx2.multiple,
        isExpanded: (ctx2, evt) => ctx2.value.includes(evt.value)
      },
      actions: {
        collapse(ctx2, evt) {
          const next = ctx2.multiple ? remove(ctx2.value, evt.value) : [];
          set3.value(ctx2, ctx2.multiple ? next : []);
        },
        expand(ctx2, evt) {
          const next = ctx2.multiple ? add(ctx2.value, evt.value) : [evt.value];
          set3.value(ctx2, next);
        },
        focusFirstTrigger(ctx2) {
          var _a;
          (_a = dom.getFirstTriggerEl(ctx2)) == null ? void 0 : _a.focus();
        },
        focusLastTrigger(ctx2) {
          var _a;
          (_a = dom.getLastTriggerEl(ctx2)) == null ? void 0 : _a.focus();
        },
        focusNextTrigger(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const triggerEl = dom.getNextTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        focusPrevTrigger(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const triggerEl = dom.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          triggerEl == null ? void 0 : triggerEl.focus();
        },
        setFocusedValue(ctx2, evt) {
          set3.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set3.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set3.value(ctx2, evt.value);
        },
        coarseValue(ctx2) {
          if (!ctx2.multiple && ctx2.value.length > 1) {
            warn(`The value of accordion should be a single value when multiple is false.`);
            ctx2.value = [ctx2.value[0]];
          }
        }
      }
    }
  );
}
var invoke = {
  change(ctx) {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: Array.from(ctx.value) });
  },
  focusChange(ctx) {
    var _a;
    (_a = ctx.onFocusChange) == null ? void 0 : _a.call(ctx, { value: ctx.focusedValue });
  }
};
var set3 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke.change(ctx);
  },
  focusedValue(ctx, value) {
    if (isEqual(ctx.focusedValue, value))
      return;
    ctx.focusedValue = value;
    invoke.focusChange(ctx);
  }
};
var props = createProps()([
  "collapsible",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "multiple",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "value"
]);
var splitProps2 = createSplitProps(props);
var itemProps = createProps()(["value", "disabled"]);
var splitItemProps = createSplitProps(itemProps);

// node_modules/@zag-js/react/dist/index.mjs
var import_react2 = __toESM(require_react(), 1);
var import_react_dom = __toESM(require_react_dom(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_react6 = __toESM(require_react(), 1);
var normalizeProps = createNormalizer((v) => v);
var isArrayLike2 = (value) => (value == null ? void 0 : value.constructor.name) === "Array";
var isEqual2 = (a2, b2) => {
  if (Object.is(a2, b2))
    return true;
  if (a2 == null && b2 != null || a2 != null && b2 == null)
    return false;
  if (typeof (a2 == null ? void 0 : a2.isEqual) === "function" && typeof (b2 == null ? void 0 : b2.isEqual) === "function") {
    return a2.isEqual(b2);
  }
  if (typeof a2 === "function" && typeof b2 === "function") {
    return a2.toString() === b2.toString();
  }
  if (isArrayLike2(a2) && isArrayLike2(b2)) {
    return Array.from(a2).toString() === Array.from(b2).toString();
  }
  if (!(typeof a2 === "object") || !(typeof b2 === "object"))
    return false;
  const keys = Object.keys(b2 ?? /* @__PURE__ */ Object.create(null));
  const length = keys.length;
  for (let i = 0; i < length; i++) {
    const hasKey2 = Reflect.has(a2, keys[i]);
    if (!hasKey2)
      return false;
  }
  for (let i = 0; i < length; i++) {
    const key = keys[i];
    if (!isEqual2(a2[key], b2[key]))
      return false;
  }
  return true;
};
function compact3(obj) {
  if (!isPlainObject3(obj) || obj === void 0) {
    return obj;
  }
  const keys = Reflect.ownKeys(obj).filter((key) => typeof key === "string");
  const filtered = {};
  for (const key of keys) {
    const value = obj[key];
    if (value !== void 0) {
      filtered[key] = compact3(value);
    }
  }
  return filtered;
}
var isPlainObject3 = (value) => {
  return value && typeof value === "object" && value.constructor === Object;
};
function useUpdateEffect(callback, deps) {
  const render = (0, import_react4.useRef)(false);
  const effect = (0, import_react4.useRef)(false);
  (0, import_react4.useEffect)(() => {
    const mounted = render.current;
    const run = mounted && effect.current;
    if (run) {
      return callback();
    }
    effect.current = true;
  }, deps);
  (0, import_react4.useEffect)(() => {
    render.current = true;
    return () => {
      render.current = false;
    };
  }, []);
}
var { use } = import_react3.default;
var targetCache = makeGlobal("__zag__targetCache", () => /* @__PURE__ */ new WeakMap());
function useSnapshot(service, options) {
  const { actions, context, sync: notifyInSync } = options ?? {};
  const lastSnapshot = (0, import_react3.useRef)();
  const lastAffected = (0, import_react3.useRef)();
  const currSnapshot = (0, import_react3.useSyncExternalStore)(
    (0, import_react3.useCallback)((callback) => subscribe(service.state, callback, notifyInSync), [notifyInSync]),
    () => {
      const nextSnapshot = snapshot(service.state, use);
      try {
        if (lastSnapshot.current && lastAffected.current && !isChanged(lastSnapshot.current, nextSnapshot, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
          return lastSnapshot.current;
        }
      } catch (e) {
      }
      return nextSnapshot;
    },
    () => snapshot(service.state, use)
  );
  service.setOptions({ actions });
  const ctx = (0, import_react3.useMemo)(() => compact3(context ?? {}), [context]);
  useUpdateEffect(() => {
    const entries = Object.entries(ctx);
    const previousCtx = service.contextSnapshot ?? {};
    const equality = entries.map(([key, value]) => ({
      key,
      curr: value,
      prev: previousCtx[key],
      equal: isEqual2(previousCtx[key], value)
    }));
    const allEqual = equality.every(({ equal }) => equal);
    if (!allEqual) {
      service.setContext(ctx);
    }
  }, [ctx]);
  const currAffected = /* @__PURE__ */ new WeakMap();
  (0, import_react3.useEffect)(() => {
    lastSnapshot.current = currSnapshot;
    lastAffected.current = currAffected;
  });
  const proxyCache = (0, import_react3.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
  return createProxy(currSnapshot, currAffected, proxyCache, targetCache);
}
function useActor(service) {
  const state2 = useSnapshot(service);
  return [state2, service.send];
}
function useConstant(fn) {
  const ref2 = (0, import_react5.useRef)();
  if (!ref2.current)
    ref2.current = { v: fn() };
  return ref2.current.v;
}
var useSafeLayoutEffect = typeof document !== "undefined" ? import_react6.useLayoutEffect : import_react6.useEffect;
function useService(machine34, options) {
  const { state: hydratedState, context } = options ?? {};
  const service = useConstant(() => {
    const instance = typeof machine34 === "function" ? machine34() : machine34;
    if (context)
      instance.setContext(context);
    instance._created();
    return instance;
  });
  useSafeLayoutEffect(() => {
    service.start(hydratedState);
    return () => {
      service.stop();
    };
  }, []);
  return service;
}
function useMachine(machine34, options) {
  const service = useService(machine34, options);
  const state2 = useSnapshot(service, options);
  return [state2, service.send, service];
}

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var import_react14 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-context.js
var [AccordionItemProvider, useAccordionItemContext] = createContext({
  name: "AccordionItemContext",
  hookName: "useAccordionItemContext",
  providerName: "<AccordionItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react12 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/factory.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/compose-refs.js
function setRef(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => {
    for (const ref2 of refs) {
      setRef(ref2, node);
    }
  };
}

// node_modules/@ark-ui/react/dist/components/factory.js
function getRef(child) {
  if ("ref" in child.props)
    return child.props.ref;
  if ("ref" in child)
    return child.ref;
  return null;
}
var withAsChild = (Component) => {
  const Comp = (0, import_react7.memo)(
    (0, import_react7.forwardRef)((props29, ref2) => {
      const { asChild, children, ...restProps } = props29;
      if (!asChild) {
        return (0, import_react7.createElement)(Component, { ...restProps, ref: ref2 }, children);
      }
      const onlyChild = import_react7.Children.only(children);
      if (!(0, import_react7.isValidElement)(onlyChild)) {
        return null;
      }
      const childRef = getRef(onlyChild);
      return (0, import_react7.cloneElement)(onlyChild, {
        ...mergeProps(restProps, onlyChild.props),
        ref: ref2 ? composeRefs(ref2, childRef) : childRef
      });
    })
  );
  Comp.displayName = Component.displayName || Component.name;
  return Comp;
};
var jsxFactory = () => {
  const cache = /* @__PURE__ */ new Map();
  return new Proxy(withAsChild, {
    apply(_target, _thisArg, argArray) {
      return withAsChild(argArray[0]);
    },
    get(_, element) {
      const asElement = element;
      if (!cache.has(asElement)) {
        cache.set(asElement, withAsChild(asElement));
      }
      return cache.get(asElement);
    }
  });
};
var ark = jsxFactory();

// node_modules/@ark-ui/react/dist/utils/create-split-props.js
var createSplitProps2 = () => (props29, keys) => keys.reduce(
  (previousValue, currentValue) => {
    const [target, source] = previousValue;
    const key = currentValue;
    if (source[key] !== void 0) {
      target[key] = source[key];
    }
    delete source[key];
    return [target, source];
  },
  [{}, { ...props29 }]
);

// node_modules/@ark-ui/react/dist/components/collapsible/split-collapsible-props.js
var splitCollapsibleProps = (props29) => createSplitProps2()(props29, [
  "defaultOpen",
  "disabled",
  "id",
  "ids",
  "lazyMount",
  "onExitComplete",
  "onOpenChange",
  "open",
  "unmountOnExit"
]);

// node_modules/@zag-js/collapsible/dist/index.mjs
var anatomy2 = createAnatomy("collapsible").parts("root", "trigger", "content");
var parts2 = anatomy2.build();
var dom2 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `collapsible:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `collapsible:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `collapsible:${ctx.id}:trigger`;
  },
  getRootEl: (ctx) => dom2.getById(ctx, dom2.getRootId(ctx)),
  getContentEl: (ctx) => dom2.getById(ctx, dom2.getContentId(ctx)),
  getTriggerEl: (ctx) => dom2.getById(ctx, dom2.getTriggerId(ctx))
});
function connect2(state2, send, normalize) {
  const visible = state2.matches("open", "closing");
  const open = state2.matches("open");
  const height = state2.context.height;
  const width = state2.context.width;
  const disabled = !!state2.context.disabled;
  const skip = !state2.context.initial && open;
  return {
    disabled,
    visible,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize.element({
        ...parts2.root.attrs,
        "data-state": open ? "open" : "closed",
        dir: state2.context.dir,
        id: dom2.getRootId(state2.context)
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts2.content.attrs,
        "data-state": skip ? void 0 : open ? "open" : "closed",
        id: dom2.getContentId(state2.context),
        "data-disabled": dataAttr(disabled),
        hidden: !visible,
        style: {
          "--height": height != null ? `${height}px` : void 0,
          "--width": width != null ? `${width}px` : void 0
        }
      });
    },
    getTriggerProps() {
      return normalize.element({
        ...parts2.trigger.attrs,
        id: dom2.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "aria-controls": dom2.getContentId(state2.context),
        "aria-expanded": visible || false,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (disabled)
            return;
          send({ type: open ? "CLOSE" : "OPEN", src: "trigger.click" });
        }
      });
    }
  };
}
function machine2(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "collapsible",
      initial: ctx.open ? "open" : "closed",
      context: {
        ...ctx,
        height: 0,
        width: 0,
        initial: false,
        stylesRef: null,
        unmountAnimationName: null
      },
      watch: {
        open: ["setInitial", "computeSize", "toggleVisibility"]
      },
      exit: ["clearInitial"],
      states: {
        closed: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "computeSize", "invokeOnOpen"]
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackAnimationEvents"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setInitial", "invokeOnOpen"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnExitComplete"]
              },
              {
                target: "closed",
                actions: ["setInitial", "computeSize", "invokeOnExitComplete"]
              }
            ],
            "ANIMATION.END": {
              target: "closed",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        open: {
          tags: ["open"],
          on: {
            "CONTROLLED.CLOSE": "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closing",
                actions: ["setInitial", "computeSize", "invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          let cleanup;
          const rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl)
              return;
            const animationName = getComputedStyle2(contentEl).animationName;
            const hasNoAnimation = !animationName || animationName === "none";
            if (hasNoAnimation) {
              send({ type: "ANIMATION.END" });
              return;
            }
            const onEnd = (event) => {
              const win = contentEl.ownerDocument.defaultView || window;
              const animationName2 = win.getComputedStyle(contentEl).animationName;
              if (event.target === contentEl && animationName2 === ctx2.unmountAnimationName) {
                send({ type: "ANIMATION.END" });
              }
            };
            contentEl.addEventListener("animationend", onEnd);
            cleanup = () => {
              contentEl.removeEventListener("animationend", onEnd);
            };
          });
          return () => {
            rafCleanup();
            cleanup == null ? void 0 : cleanup();
          };
        }
      },
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        computeSize(ctx2, evt) {
          var _a;
          (_a = ctx2._rafCleanup) == null ? void 0 : _a.call(ctx2);
          ctx2._rafCleanup = raf(() => {
            const contentEl = dom2.getContentEl(ctx2);
            if (!contentEl)
              return;
            ctx2.stylesRef || (ctx2.stylesRef = ref({
              animationName: contentEl.style.animationName,
              animationDuration: contentEl.style.animationDuration
            }));
            if (evt.type === "CLOSE" || !ctx2.open) {
              const win = contentEl.ownerDocument.defaultView || window;
              ctx2.unmountAnimationName = win.getComputedStyle(contentEl).animationName;
            }
            const hidden = contentEl.hidden;
            contentEl.style.animationName = "none";
            contentEl.style.animationDuration = "0s";
            contentEl.hidden = false;
            const rect = contentEl.getBoundingClientRect();
            ctx2.height = rect.height;
            ctx2.width = rect.width;
            if (ctx2.initial) {
              contentEl.style.animationName = ctx2.stylesRef.animationName;
              contentEl.style.animationDuration = ctx2.stylesRef.animationDuration;
            }
            contentEl.hidden = hidden;
          });
        },
        invokeOnOpen: (ctx2) => {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose: (ctx2) => {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        invokeOnExitComplete(ctx2) {
          var _a;
          (_a = ctx2.onExitComplete) == null ? void 0 : _a.call(ctx2);
        },
        toggleVisibility: (ctx2, _evt, { send }) => {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE" });
        }
      }
    }
  );
}
var props2 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onExitComplete",
  "onOpenChange",
  "open.controlled",
  "open"
]);
var splitProps3 = createSplitProps(props2);

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var import_react10 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/providers/environment/use-environment-context.js
var [EnvironmentContextProvider, useEnvironmentContext] = createContext({
  name: "EnvironmentContext",
  hookName: "useEnvironmentContext",
  providerName: "<EnvironmentProvider />",
  strict: false,
  defaultValue: {
    getRootNode: () => document,
    getDocument: () => document,
    getWindow: () => window
  }
});

// node_modules/@ark-ui/react/dist/providers/locale/use-locale-context.js
var [LocaleContextProvider, useLocaleContext] = createContext({
  name: "LocaleContext",
  hookName: "useLocaleContext",
  providerName: "<LocaleProvider />",
  strict: false,
  defaultValue: { dir: "ltr", locale: "en-US" }
});

// node_modules/@ark-ui/react/dist/utils/use-event.js
var import_react8 = __toESM(require_react(), 1);
function useEvent(callback, opts = {}) {
  const { sync: sync6 = false } = opts;
  const callbackRef = useLatestRef(callback);
  return (0, import_react8.useCallback)(
    // biome-ignore lint/suspicious/noExplicitAny: <explanation>
    (...args) => {
      var _a;
      if (sync6)
        return queueMicrotask(() => {
          var _a2;
          return (_a2 = callbackRef.current) == null ? void 0 : _a2.call(callbackRef, ...args);
        });
      return (_a = callbackRef.current) == null ? void 0 : _a.call(callbackRef, ...args);
    },
    [sync6, callbackRef]
  );
}
function useLatestRef(value) {
  const ref2 = (0, import_react8.useRef)(value);
  ref2.current = value;
  return ref2;
}

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible.js
var useCollapsible = (props29 = {}) => {
  const { lazyMount, unmountOnExit, ...collapsibleProps } = props29;
  const wasVisible = (0, import_react10.useRef)(false);
  const { dir } = useLocaleContext();
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react10.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...collapsibleProps
  };
  const context = {
    ...initialContext,
    open: props29.open,
    onOpenChange: useEvent(props29.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine2(initialContext), { context });
  const api = connect2(state2, send, normalizeProps);
  if (api.visible) {
    wasVisible.current = true;
  }
  const isUnmounted = !api.visible && !wasVisible.current && lazyMount || unmountOnExit && !api.visible && wasVisible.current;
  return { ...api, isUnmounted };
};

// node_modules/@ark-ui/react/dist/components/collapsible/use-collapsible-context.js
var [CollapsibleProvider, useCollapsibleContext] = createContext({
  name: "CollapsibleContext",
  hookName: "useCollapsibleContext",
  providerName: "<CollapsibleProvider />"
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root.js
var CollapsibleRoot = (0, import_react12.forwardRef)((props29, ref2) => {
  const [useCollapsibleProps, localProps] = splitCollapsibleProps(props29);
  const collapsible = useCollapsible(useCollapsibleProps);
  const mergedProps = mergeProps(collapsible.getRootProps(), localProps);
  return (0, import_jsx_runtime2.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime2.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
CollapsibleRoot.displayName = "CollapsibleRoot";

// node_modules/@ark-ui/react/dist/utils/render-strategy.js
var [RenderStrategyPropsProvider, useRenderStrategyPropsContext] = createContext({
  name: "RenderStrategyContext",
  hookName: "useRenderStrategyContext",
  providerName: "<RenderStrategyPropsProvider />"
});
var splitRenderStrategyProps = (props29) => createSplitProps2()(props29, ["lazyMount", "unmountOnExit"]);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion-item-props-context.js
var [AccordionItemPropsProvider, useAccordionItemPropsContext] = createContext({
  name: "AccordionItemPropsContext",
  hookName: "useAccordionItemPropsContext",
  providerName: "<AccordionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item.js
var AccordionItem = (0, import_react14.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = splitItemProps(props29);
  const accordion = useAccordionContext();
  const renderStrategy = useRenderStrategyPropsContext();
  const mergedProps = mergeProps(accordion.getItemProps(itemProps10), localProps);
  const item = accordion.getItemState(itemProps10);
  const itemContentProps = accordion.getItemContentProps(itemProps10);
  return (0, import_jsx_runtime3.jsx)(AccordionItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime3.jsx)(AccordionItemProvider, { value: item, children: (0, import_jsx_runtime3.jsx)(
    CollapsibleRoot,
    {
      ref: ref2,
      open: item.expanded,
      ids: { content: itemContentProps.id },
      ...renderStrategy,
      ...mergedProps
    }
  ) }) });
});
AccordionItem.displayName = "AccordionItem";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react18 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-content.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react16 = __toESM(require_react(), 1);
var CollapsibleContent = (0, import_react16.forwardRef)(
  (props29, ref2) => {
    const collapsible = useCollapsibleContext();
    if (collapsible.isUnmounted) {
      return null;
    }
    const mergedProps = mergeProps(collapsible.getContentProps(), props29);
    return (0, import_jsx_runtime4.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleContent.displayName = "CollapsibleContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-content.js
var splitVisibilityProps = createSplitProps2();
var AccordionItemContent = (0, import_react18.forwardRef)(
  (props29, ref2) => {
    const accordion = useAccordionContext();
    const itemProps10 = useAccordionItemPropsContext();
    const contentProps2 = accordion.getItemContentProps(itemProps10);
    const [, itemContentProps] = splitVisibilityProps(contentProps2, ["hidden", "data-state"]);
    const mergedProps = mergeProps(itemContentProps, props29);
    return (0, import_jsx_runtime5.jsx)(CollapsibleContent, { ref: ref2, ...mergedProps });
  }
);
AccordionItemContent.displayName = "AccordionItemContent";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-context.js
var AccordionItemContext = (props29) => props29.children(useAccordionItemContext());

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-indicator.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);
var AccordionItemIndicator = (0, import_react20.forwardRef)(
  (props29, ref2) => {
    const accordion = useAccordionContext();
    const itemProps10 = useAccordionItemPropsContext();
    const mergedProps = mergeProps(accordion.getItemIndicatorProps(itemProps10), props29);
    return (0, import_jsx_runtime6.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemIndicator.displayName = "AccordionItemIndicator";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-item-trigger.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react22 = __toESM(require_react(), 1);
var AccordionItemTrigger = (0, import_react22.forwardRef)(
  (props29, ref2) => {
    const accordion = useAccordionContext();
    const itemProps10 = useAccordionItemPropsContext();
    const collapsible = useCollapsibleContext();
    const triggerProps2 = accordion.getItemTriggerProps(itemProps10);
    const mergedProps = mergeProps(
      {
        ...triggerProps2,
        "aria-controls": collapsible.isUnmounted ? void 0 : triggerProps2["aria-controls"]
      },
      props29
    );
    return (0, import_jsx_runtime7.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
AccordionItemTrigger.displayName = "AccordionItemTrigger";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/accordion/use-accordion.js
var import_react24 = __toESM(require_react(), 1);
var useAccordion = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react24.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onFocusChange: useEvent(props29.onFocusChange),
    onValueChange: useEvent(props29.onValueChange)
  };
  const [state2, send] = useMachine(machine(initialContext), { context });
  return connect(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root.js
var AccordionRoot = (0, import_react26.forwardRef)((props29, ref2) => {
  const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props29);
  const [useAccordionProps, localProps] = createSplitProps2()(accordionProps, [
    "collapsible",
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "multiple",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "value"
  ]);
  const accordion = useAccordion(useAccordionProps);
  const mergedProps = mergeProps(accordion.getRootProps(), localProps);
  return (0, import_jsx_runtime8.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime8.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime8.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
AccordionRoot.displayName = "AccordionRoot";

// node_modules/@ark-ui/react/dist/components/accordion/accordion-root-provider.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var import_react28 = __toESM(require_react(), 1);
var AccordionRootProvider = (0, import_react28.forwardRef)(
  (props29, ref2) => {
    const [renderStrategyProps, accordionProps] = splitRenderStrategyProps(props29);
    const [{ value: accordion }, localProps] = createSplitProps2()(
      accordionProps,
      ["value"]
    );
    const mergedProps = mergeProps(accordion.getRootProps(), localProps);
    return (0, import_jsx_runtime9.jsx)(AccordionProvider, { value: accordion, children: (0, import_jsx_runtime9.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime9.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
AccordionRootProvider.displayName = "AccordionRootProvider";

// node_modules/@ark-ui/react/dist/components/accordion/accordion.js
var accordion_exports = {};
__export(accordion_exports, {
  Context: () => AccordionContext,
  Item: () => AccordionItem,
  ItemContent: () => AccordionItemContent,
  ItemContext: () => AccordionItemContext,
  ItemIndicator: () => AccordionItemIndicator,
  ItemTrigger: () => AccordionItemTrigger,
  Root: () => AccordionRoot,
  RootProvider: () => AccordionRootProvider
});

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar-context.js
var [AvatarProvider, useAvatarContext] = createContext({
  name: "AvatarContext",
  hookName: "useAvatarContext",
  providerName: "<AvatarProvider />"
});

// node_modules/@ark-ui/react/dist/components/avatar/avatar-context.js
var AvatarContext = (props29) => props29.children(useAvatarContext());

// node_modules/@ark-ui/react/dist/components/avatar/avatar-fallback.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);
var AvatarFallback = (0, import_react30.forwardRef)((props29, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps(avatar.getFallbackProps(), props29);
  return (0, import_jsx_runtime10.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
AvatarFallback.displayName = "AvatarFallback";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-image.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);
var AvatarImage = (0, import_react32.forwardRef)((props29, ref2) => {
  const avatar = useAvatarContext();
  const mergedProps = mergeProps(avatar.getImageProps(), props29);
  return (0, import_jsx_runtime11.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
AvatarImage.displayName = "AvatarImage";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var import_react36 = __toESM(require_react(), 1);

// node_modules/@zag-js/avatar/dist/index.mjs
var anatomy3 = createAnatomy("avatar").parts("root", "image", "fallback");
var parts3 = anatomy3.build();
var dom3 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `avatar:${ctx.id}`;
  },
  getImageId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.image) ?? `avatar:${ctx.id}:image`;
  },
  getFallbackId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.fallback) ?? `avatar:${ctx.id}:fallback`;
  },
  getRootEl: (ctx) => dom3.getById(ctx, dom3.getRootId(ctx)),
  getImageEl: (ctx) => dom3.getById(ctx, dom3.getImageId(ctx))
});
function connect3(state2, send, normalize) {
  const loaded = state2.matches("loaded");
  return {
    loaded,
    setSrc(src) {
      send({ type: "SRC.SET", src });
    },
    setLoaded() {
      send({ type: "IMG.LOADED", src: "api" });
    },
    setError() {
      send({ type: "IMG.ERROR", src: "api" });
    },
    getRootProps() {
      return normalize.element({
        ...parts3.root.attrs,
        dir: state2.context.dir,
        id: dom3.getRootId(state2.context)
      });
    },
    getImageProps() {
      return normalize.img({
        ...parts3.image.attrs,
        hidden: !loaded,
        dir: state2.context.dir,
        id: dom3.getImageId(state2.context),
        "data-state": loaded ? "visible" : "hidden",
        onLoad() {
          send({ type: "IMG.LOADED", src: "element" });
        },
        onError() {
          send({ type: "IMG.ERROR", src: "element" });
        }
      });
    },
    getFallbackProps() {
      return normalize.element({
        ...parts3.fallback.attrs,
        dir: state2.context.dir,
        id: dom3.getFallbackId(state2.context),
        hidden: loaded,
        "data-state": loaded ? "hidden" : "visible"
      });
    }
  };
}
function machine3(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "avatar",
      initial: "loading",
      activities: ["trackImageRemoval"],
      context: ctx,
      on: {
        "SRC.CHANGE": {
          target: "loading"
        },
        "IMG.UNMOUNT": {
          target: "error"
        }
      },
      states: {
        loading: {
          activities: ["trackSrcChange"],
          entry: ["checkImageStatus"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            },
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        },
        error: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.LOADED": {
              target: "loaded",
              actions: ["invokeOnLoad"]
            }
          }
        },
        loaded: {
          activities: ["trackSrcChange"],
          on: {
            "IMG.ERROR": {
              target: "error",
              actions: ["invokeOnError"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackSrcChange(ctx2, _evt, { send }) {
          const imageEl = dom3.getImageEl(ctx2);
          return observeAttributes(imageEl, {
            attributes: ["src", "srcset"],
            callback() {
              send({ type: "SRC.CHANGE" });
            }
          });
        },
        trackImageRemoval(ctx2, _evt, { send }) {
          const rootEl = dom3.getRootEl(ctx2);
          return observeChildren(rootEl, {
            callback(records) {
              const removedNodes = Array.from(records[0].removedNodes);
              const removed = removedNodes.find((node) => node.matches("[data-scope=avatar][data-part=image]"));
              if (removed) {
                send({ type: "IMG.UNMOUNT" });
              }
            }
          });
        }
      },
      actions: {
        invokeOnLoad(ctx2) {
          var _a;
          (_a = ctx2.onStatusChange) == null ? void 0 : _a.call(ctx2, { status: "loaded" });
        },
        invokeOnError(ctx2) {
          var _a;
          (_a = ctx2.onStatusChange) == null ? void 0 : _a.call(ctx2, { status: "error" });
        },
        checkImageStatus(ctx2, _evt, { send }) {
          const imageEl = dom3.getImageEl(ctx2);
          if (imageEl == null ? void 0 : imageEl.complete) {
            const type = hasLoaded(imageEl) ? "IMG.LOADED" : "IMG.ERROR";
            send({ type, src: "ssr" });
          }
        }
      }
    }
  );
}
function hasLoaded(image) {
  return image.complete && image.naturalWidth !== 0 && image.naturalHeight !== 0;
}
var props3 = createProps()(["dir", "id", "ids", "onStatusChange", "getRootNode"]);
var splitProps4 = createSplitProps(props3);

// node_modules/@ark-ui/react/dist/components/avatar/use-avatar.js
var import_react34 = __toESM(require_react(), 1);
var useAvatar = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react34.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props29
  };
  const context = {
    ...initialContext,
    onStatusChange: useEvent(props29.onStatusChange)
  };
  const [state2, send] = useMachine(machine3(initialContext), { context });
  return connect3(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root.js
var AvatarRoot = (0, import_react36.forwardRef)((props29, ref2) => {
  const [useAvatarProps, localProps] = createSplitProps2()(props29, [
    "id",
    "ids",
    "onStatusChange"
  ]);
  const avatar = useAvatar(useAvatarProps);
  const mergedProps = mergeProps(avatar.getRootProps(), localProps);
  return (0, import_jsx_runtime12.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime12.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
AvatarRoot.displayName = "AvatarRoot";

// node_modules/@ark-ui/react/dist/components/avatar/avatar-root-provider.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);
var AvatarRootProvider = (0, import_react38.forwardRef)(
  (props29, ref2) => {
    const [{ value: avatar }, localProps] = createSplitProps2()(props29, ["value"]);
    const mergedProps = mergeProps(avatar.getRootProps(), localProps);
    return (0, import_jsx_runtime13.jsx)(AvatarProvider, { value: avatar, children: (0, import_jsx_runtime13.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
AvatarRootProvider.displayName = "AvatarRootProvider";

// node_modules/@ark-ui/react/dist/components/avatar/avatar.js
var avatar_exports = {};
__export(avatar_exports, {
  Context: () => AvatarContext,
  Fallback: () => AvatarFallback,
  Image: () => AvatarImage,
  Root: () => AvatarRoot,
  RootProvider: () => AvatarRootProvider
});

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel-context.js
var [CarouselProvider, useCarouselContext] = createContext({
  name: "CarouselContext",
  hookName: "useCarouselContext",
  providerName: "<CarouselProvider />"
});

// node_modules/@ark-ui/react/dist/components/carousel/carousel-context.js
var CarouselContext = (props29) => props29.children(useCarouselContext());

// node_modules/@ark-ui/react/dist/components/carousel/carousel-control.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);

// node_modules/@zag-js/carousel/dist/index.mjs
var anatomy4 = createAnatomy("carousel").parts(
  "root",
  "viewport",
  "itemGroup",
  "item",
  "nextTrigger",
  "prevTrigger",
  "indicatorGroup",
  "indicator"
);
var parts4 = anatomy4.build();
var dom4 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `carousel:${ctx.id}`;
  },
  getViewportId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.viewport) ?? `carousel:${ctx.id}:viewport`;
  },
  getItemId: (ctx, index) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.slide) == null ? void 0 : _b.call(_a, index)) ?? `carousel:${ctx.id}:slide:${index}`;
  },
  getItemGroupId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.slideGroup) ?? `carousel:${ctx.id}:slide-group`;
  },
  getNextTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.nextSlideTrigger) ?? `carousel:${ctx.id}:next-slide-trigger`;
  },
  getPrevTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.prevSlideTrigger) ?? `carousel:${ctx.id}:prev-slide-trigger`;
  },
  getIndicatorGroupId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.indicatorGroup) ?? `carousel:${ctx.id}:indicator-group`;
  },
  getIndicatorId: (ctx, index) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.indicator) == null ? void 0 : _b.call(_a, index)) ?? `carousel:${ctx.id}:indicator:${index}`;
  },
  getRootEl: (ctx) => dom4.getById(ctx, dom4.getRootId(ctx)),
  getViewportEl: (ctx) => dom4.getById(ctx, dom4.getViewportId(ctx)),
  getSlideGroupEl: (ctx) => dom4.getById(ctx, dom4.getItemGroupId(ctx)),
  getSlideEls: (ctx) => queryAll(dom4.getSlideGroupEl(ctx), `[data-part=item]`)
});
function getLimit(min3, max3) {
  const length = Math.abs(min3 - max3);
  function reachedMin(n) {
    return n < min3;
  }
  function reachedMax(n) {
    return n > max3;
  }
  function reachedAny(n) {
    return reachedMin(n) || reachedMax(n);
  }
  function constrain(n) {
    if (!reachedAny(n))
      return n;
    return reachedMin(n) ? min3 : max3;
  }
  function removeOffset(n) {
    if (!length)
      return n;
    return n - length * Math.ceil((n - max3) / length);
  }
  return {
    length,
    max: max3,
    min: min3,
    constrain,
    reachedAny,
    reachedMax,
    reachedMin,
    removeOffset
  };
}
var getAlignment = (align, containerSize) => {
  const predefined = { start, center, end };
  function start() {
    return 0;
  }
  function center(n) {
    return end(n) / 2;
  }
  function end(n) {
    return containerSize - n;
  }
  function percent() {
    return containerSize * Number(align);
  }
  return (n) => {
    if (isNumber(align))
      return percent();
    return predefined[align](n);
  };
};
function getSlidesToScroll(containerSize, slideSizesWithGaps, slidesPerView) {
  function byNumber(array, groupSize) {
    return Array.from(array.keys()).filter((i) => i % groupSize === 0).map((i) => array.slice(i, i + groupSize));
  }
  function bySize(array) {
    return Array.from(array.keys()).reduce((groups, i) => {
      const chunk2 = slideSizesWithGaps.slice(groups.at(-1), i + 1);
      const chunkSize = chunk2.reduce((a2, s) => a2 + s, 0);
      return !i || chunkSize > containerSize ? groups.concat(i) : groups;
    }, []).map((start, i, groups) => array.slice(start, groups[i + 1]));
  }
  return function groupSlides(array) {
    return isNumber(slidesPerView) ? byNumber(array, slidesPerView) : bySize(array);
  };
}
function getSlideSizes(ctx) {
  const startGap = measureStartGap();
  function measureStartGap() {
    if (!ctx.containerRect)
      return 0;
    const slideRect = ctx.slideRects[0];
    return Math.abs(ctx.containerRect[ctx.startEdge] - slideRect[ctx.startEdge]);
  }
  function measureWithGaps() {
    return ctx.slideRects.map((rect, index, rects) => {
      const isFirst = !index;
      if (isFirst)
        return Math.abs(slideSizes[index] + startGap);
      const isLast = index === rects.length - 1;
      if (isLast)
        return Math.abs(slideSizes[index]);
      return Math.abs(rects[index + 1][ctx.startEdge] - rect[ctx.startEdge]);
    });
  }
  const slideSizes = ctx.slideRects.map((slideRect) => {
    return ctx.isVertical ? slideRect.height : slideRect.width;
  });
  const slideSizesWithGaps = measureWithGaps();
  return {
    slideSizes,
    slideSizesWithGaps
  };
}
var arrayLast = (array) => array[arrayLastIndex(array)];
var arrayLastIndex = (array) => Math.max(0, array.length - 1);
function getScrollSnaps(ctx) {
  const { slideSizes, slideSizesWithGaps } = getSlideSizes(ctx);
  const groupSlides = getSlidesToScroll(ctx.containerSize, slideSizesWithGaps, ctx.slidesPerView);
  function measureSizes() {
    return groupSlides(ctx.slideRects).map((rects) => arrayLast(rects)[ctx.endEdge] - rects[0][ctx.startEdge]).map(Math.abs);
  }
  function measureUnaligned() {
    return ctx.slideRects.map((slideRect) => ctx.containerRect[ctx.startEdge] - slideRect[ctx.startEdge]).map((snap) => -Math.abs(snap));
  }
  function measureAligned() {
    const measureFn = getAlignment(ctx.align, ctx.containerSize);
    const alignments2 = measureSizes().map(measureFn);
    return groupSlides(snaps).map((snap) => snap[0]).map((snap, index) => snap + alignments2[index]);
  }
  const snaps = measureUnaligned();
  const snapsAligned = measureAligned();
  const contentSize = -arrayLast(snaps) + arrayLast(slideSizesWithGaps);
  const scrollLimit = getLimit(snaps[snaps.length - 1], snaps[0]);
  const scrollProgress = (snapsAligned[ctx.index] - scrollLimit.max) / -scrollLimit.length;
  return {
    snaps,
    snapsAligned,
    slideSizes,
    slideSizesWithGaps,
    contentSize,
    scrollLimit,
    scrollProgress: Math.abs(scrollProgress)
  };
}
var slideThreshold = 0;
function getSlidesInView(ctx) {
  const roundingSafety = 0.5;
  const slideOffsets = [0];
  const { snaps, slideSizes, scrollLimit } = getScrollSnaps(ctx);
  const slideThresholds = slideSizes.map((slideSize) => {
    const thresholdLimit = getLimit(roundingSafety, slideSize - roundingSafety);
    return thresholdLimit.constrain(slideSize * slideThreshold);
  });
  const slideBounds = slideOffsets.reduce((acc, offset3) => {
    const bounds = snaps.map((snap, index) => ({
      start: snap - slideSizes[index] + slideThresholds[index] + offset3,
      end: snap + ctx.containerSize - slideThresholds[index] + offset3,
      index
    }));
    return acc.concat(bounds);
  }, []);
  return (location) => {
    const loc = scrollLimit.constrain(location);
    return slideBounds.reduce((list, bound) => {
      const { index, start, end } = bound;
      const inList = list.includes(index);
      const inView = start < loc && end > loc;
      return !inList && inView ? list.concat([index]) : list;
    }, []);
  };
}
function connect4(state2, send, normalize) {
  const canScrollNext = state2.context.canScrollNext;
  const canScrollPrev = state2.context.canScrollPrev;
  const horizontal = state2.context.isHorizontal;
  const autoPlaying = state2.matches("autoplay");
  const activeSnap = state2.context.scrollSnaps[state2.context.index];
  const slidesInView = isDom() ? getSlidesInView(state2.context)(activeSnap) : [];
  function getItemState(props29) {
    return {
      valueText: `Slide ${props29.index + 1}`,
      current: props29.index === state2.context.index,
      next: props29.index === state2.context.index + 1,
      previous: props29.index === state2.context.index - 1,
      inView: slidesInView.includes(props29.index)
    };
  }
  return {
    index: state2.context.index,
    scrollProgress: state2.context.scrollProgress,
    autoPlaying,
    canScrollNext,
    canScrollPrev,
    scrollTo(index, jump) {
      send({ type: "GOTO", index, jump });
    },
    scrollToNext() {
      send("NEXT");
    },
    scrollToPrevious() {
      send("PREV");
    },
    getItemState,
    play() {
      send("PLAY");
    },
    pause() {
      send("PAUSE");
    },
    getRootProps() {
      return normalize.element({
        ...parts4.root.attrs,
        id: dom4.getRootId(state2.context),
        role: "region",
        "aria-roledescription": "carousel",
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        "aria-label": "Carousel",
        style: {
          "--slide-spacing": state2.context.spacing,
          "--slide-size": `calc(100% / ${state2.context.slidesPerView} - var(--slide-spacing))`
        }
      });
    },
    getViewportProps() {
      return normalize.element({
        ...parts4.viewport.attrs,
        dir: state2.context.dir,
        id: dom4.getViewportId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getItemGroupProps() {
      return normalize.element({
        ...parts4.itemGroup.attrs,
        id: dom4.getItemGroupId(state2.context),
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          display: "flex",
          flexDirection: horizontal ? "row" : "column",
          [horizontal ? "height" : "width"]: "auto",
          gap: "var(--slide-spacing)",
          transform: state2.context.translateValue,
          transitionProperty: "transform",
          willChange: "transform",
          transitionTimingFunction: "cubic-bezier(0.4, 0, 0.2, 1)",
          transitionDuration: "0.3s"
        }
      });
    },
    getItemProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts4.item.attrs,
        id: dom4.getItemId(state2.context, props29.index),
        dir: state2.context.dir,
        "data-current": dataAttr(itemState.current),
        "data-inview": dataAttr(itemState.inView),
        role: "group",
        "aria-roledescription": "slide",
        "data-orientation": state2.context.orientation,
        "aria-label": itemState.valueText,
        style: {
          position: "relative",
          flex: "0 0 var(--slide-size)",
          [horizontal ? "minWidth" : "minHeight"]: "0px"
        }
      });
    },
    getPrevTriggerProps() {
      return normalize.button({
        ...parts4.prevTrigger.attrs,
        id: dom4.getPrevTriggerId(state2.context),
        type: "button",
        tabIndex: -1,
        disabled: !canScrollPrev,
        dir: state2.context.dir,
        "aria-label": "Previous Slide",
        "data-orientation": state2.context.orientation,
        "aria-controls": dom4.getItemGroupId(state2.context),
        onClick() {
          send("PREV");
        }
      });
    },
    getNextTriggerProps() {
      return normalize.button({
        ...parts4.nextTrigger.attrs,
        dir: state2.context.dir,
        id: dom4.getNextTriggerId(state2.context),
        type: "button",
        tabIndex: -1,
        "aria-label": "Next Slide",
        "data-orientation": state2.context.orientation,
        "aria-controls": dom4.getItemGroupId(state2.context),
        disabled: !canScrollNext,
        onClick() {
          send("NEXT");
        }
      });
    },
    getIndicatorGroupProps() {
      return normalize.element({
        ...parts4.indicatorGroup.attrs,
        dir: state2.context.dir,
        id: dom4.getIndicatorGroupId(state2.context),
        "data-orientation": state2.context.orientation
      });
    },
    getIndicatorProps(props29) {
      return normalize.button({
        ...parts4.indicator.attrs,
        dir: state2.context.dir,
        id: dom4.getIndicatorId(state2.context, props29.index),
        type: "button",
        "data-orientation": state2.context.orientation,
        "data-index": props29.index,
        "data-readonly": dataAttr(props29.readOnly),
        "data-current": dataAttr(props29.index === state2.context.index),
        onClick() {
          if (props29.readOnly)
            return;
          send({ type: "GOTO", index: props29.index });
        }
      });
    }
  };
}
function machine4(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "carousel",
      initial: "idle",
      context: {
        index: 0,
        orientation: "horizontal",
        align: "start",
        loop: false,
        slidesPerView: 1,
        spacing: "0px",
        ...ctx,
        scrollSnaps: [],
        scrollProgress: 0,
        containerSize: 0,
        slideRects: []
      },
      watch: {
        index: ["setScrollSnaps"]
      },
      on: {
        NEXT: {
          actions: ["scrollToNext"]
        },
        PREV: {
          actions: ["scrollToPrev"]
        },
        GOTO: {
          actions: ["scrollTo"]
        },
        MEASURE_DOM: {
          actions: ["measureElements", "setScrollSnaps"]
        },
        PLAY: "autoplay"
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: "dragging"
          }
        },
        autoplay: {
          activities: ["trackDocumentVisibility"],
          every: {
            2e3: ["scrollToNext"]
          },
          on: {
            PAUSE: "idle"
          }
        },
        dragging: {
          on: {
            POINTER_UP: "idle",
            POINTER_MOVE: {
              actions: ["setScrollSnaps"]
            }
          }
        }
      },
      activities: ["trackContainerResize", "trackSlideMutation"],
      entry: ["measureElements", "setScrollSnaps"],
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        canScrollNext: (ctx2) => ctx2.loop || ctx2.index < ctx2.scrollSnaps.length - 1,
        canScrollPrev: (ctx2) => ctx2.loop || ctx2.index > 0,
        startEdge(ctx2) {
          if (ctx2.isVertical)
            return "top";
          return ctx2.isRtl ? "right" : "left";
        },
        endEdge(ctx2) {
          if (ctx2.isVertical)
            return "bottom";
          return ctx2.isRtl ? "left" : "right";
        },
        translateValue: (ctx2) => {
          const scrollSnap = ctx2.scrollSnaps[ctx2.index];
          return ctx2.isHorizontal ? `translate3d(${scrollSnap}px, 0, 0)` : `translate3d(0, ${scrollSnap}px, 0)`;
        }
      }
    },
    {
      activities: {
        trackSlideMutation(ctx2, _evt, { send }) {
          const slideGroupEl = dom4.getSlideGroupEl(ctx2);
          if (!slideGroupEl)
            return;
          const win = dom4.getWin(ctx2);
          const observer = new win.MutationObserver(() => {
            send({ type: "MEASURE_DOM", src: "mutation" });
          });
          observer.observe(slideGroupEl, { childList: true });
          return () => {
            observer.disconnect();
          };
        },
        trackContainerResize(ctx2, _evt, { send }) {
          const slideGroupEl = dom4.getSlideGroupEl(ctx2);
          if (!slideGroupEl)
            return;
          const win = dom4.getWin(ctx2);
          const observer = new win.ResizeObserver((entries) => {
            entries.forEach((entry) => {
              if (entry.target === slideGroupEl) {
                send({ type: "MEASURE_DOM", src: "resize" });
              }
            });
          });
          observer.observe(slideGroupEl);
          return () => {
            observer.disconnect();
          };
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          const doc = dom4.getDoc(ctx2);
          const onVisibilityChange = () => {
            if (doc.visibilityState !== "visible") {
              send({ type: "PAUSE", src: "document-hidden" });
            }
          };
          doc.addEventListener("visibilitychange", onVisibilityChange);
          return () => {
            doc.removeEventListener("visibilitychange", onVisibilityChange);
          };
        }
      },
      guards: {
        loop: (ctx2) => ctx2.loop,
        isLastSlide: (ctx2) => ctx2.index === ctx2.slideRects.length - 1,
        isFirstSlide: (ctx2) => ctx2.index === 0
      },
      actions: {
        scrollToNext(ctx2) {
          const index = nextIndex(ctx2.slideRects, ctx2.index);
          set4.index(ctx2, index);
        },
        scrollToPrev(ctx2) {
          const index = prevIndex(ctx2.slideRects, ctx2.index);
          set4.index(ctx2, index);
        },
        setScrollSnaps(ctx2) {
          const { snapsAligned, scrollProgress } = getScrollSnaps(ctx2);
          ctx2.scrollSnaps = snapsAligned;
          ctx2.scrollProgress = scrollProgress;
        },
        scrollTo(ctx2, evt) {
          const index = Math.max(0, Math.min(evt.index, ctx2.slideRects.length - 1));
          set4.index(ctx2, index);
        },
        measureElements
      }
    }
  );
}
var measureElements = (ctx) => {
  const slideGroupEl = dom4.getSlideGroupEl(ctx);
  if (!slideGroupEl)
    return;
  ctx.containerRect = ref(slideGroupEl.getBoundingClientRect());
  ctx.containerSize = ctx.isHorizontal ? ctx.containerRect.width : ctx.containerRect.height;
  ctx.slideRects = ref(dom4.getSlideEls(ctx).map((slide) => slide.getBoundingClientRect()));
};
var invoke2 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onIndexChange) == null ? void 0 : _a.call(ctx, { index: ctx.index });
  }
};
var set4 = {
  index: (ctx, index) => {
    if (isEqual(ctx.index, index))
      return;
    ctx.index = index;
    invoke2.change(ctx);
  }
};
var props4 = createProps()([
  "align",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "index",
  "loop",
  "onIndexChange",
  "orientation",
  "slidesPerView",
  "spacing"
]);
var splitProps5 = createSplitProps(props4);
var indicatorProps = createProps()(["index", "readOnly"]);
var splitIndicatorProps = createSplitProps(indicatorProps);

// node_modules/@ark-ui/anatomy/dist/carousel/index.js
var anatomy5 = anatomy4.extendWith("control");

// node_modules/@zag-js/form-utils/dist/index.mjs
var getWindow2 = (el) => el.ownerDocument.defaultView || window;
function getDescriptor(el, options) {
  const { type = "HTMLInputElement", property = "value" } = options;
  const proto = getWindow2(el)[type].prototype;
  return Object.getOwnPropertyDescriptor(proto, property) ?? {};
}
function setElementValue(el, value, option = {}) {
  var _a;
  const descriptor = getDescriptor(el, option);
  (_a = descriptor.set) == null ? void 0 : _a.call(el, value);
  el.setAttribute("value", value);
}
function setElementChecked(el, checked) {
  var _a;
  const descriptor = getDescriptor(el, { type: "HTMLInputElement", property: "checked" });
  (_a = descriptor.set) == null ? void 0 : _a.call(el, checked);
  if (checked)
    el.setAttribute("checked", "");
  else
    el.removeAttribute("checked");
}
function dispatchInputValueEvent(el, options) {
  const { value, bubbles = true } = options;
  if (!el)
    return;
  const win = getWindow2(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  setElementValue(el, `${value}`);
  el.dispatchEvent(new win.Event("input", { bubbles }));
}
function dispatchInputCheckedEvent(el, options) {
  const { checked, bubbles = true } = options;
  if (!el)
    return;
  const win = getWindow2(el);
  if (!(el instanceof win.HTMLInputElement))
    return;
  setElementChecked(el, checked);
  el.dispatchEvent(new win.Event("click", { bubbles }));
  el.dispatchEvent(new win.Event("change", { bubbles }));
}
function getClosestForm(el) {
  if (isFormElement(el))
    return el.form;
  else
    return el.closest("form");
}
function isFormElement(el) {
  return el.matches("textarea, input, select, button");
}
function trackFormReset(el, callback) {
  if (!el)
    return;
  const form = getClosestForm(el);
  form == null ? void 0 : form.addEventListener("reset", callback, { passive: true });
  return () => {
    form == null ? void 0 : form.removeEventListener("reset", callback);
  };
}
function trackFieldsetDisabled(el, callback) {
  const fieldset = el == null ? void 0 : el.closest("fieldset");
  if (!fieldset)
    return;
  callback(fieldset.disabled);
  const win = fieldset.ownerDocument.defaultView || window;
  const obs = new win.MutationObserver(() => callback(fieldset.disabled));
  obs.observe(fieldset, {
    attributes: true,
    attributeFilter: ["disabled"]
  });
  return () => obs.disconnect();
}
function trackFormControl(el, options) {
  if (!el)
    return;
  const { onFieldsetDisabledChange, onFormReset } = options;
  const cleanups2 = [trackFormReset(el, onFormReset), trackFieldsetDisabled(el, onFieldsetDisabledChange)];
  return () => {
    cleanups2.forEach((cleanup) => cleanup == null ? void 0 : cleanup());
  };
}

// node_modules/@zag-js/checkbox/dist/index.mjs
var anatomy6 = createAnatomy("checkbox").parts("root", "label", "control", "indicator");
var parts5 = anatomy6.build();
var dom5 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `checkbox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `checkbox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `checkbox:${ctx.id}:control`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `checkbox:${ctx.id}:hidden`;
  },
  getRootEl: (ctx) => dom5.getById(ctx, dom5.getRootId(ctx)),
  getHiddenInputEl: (ctx) => dom5.getById(ctx, dom5.getHiddenInputId(ctx))
});
function connect5(state2, send, normalize) {
  const disabled = state2.context.isDisabled;
  const focused = !disabled && state2.context.focused;
  const checked = state2.context.isChecked;
  const indeterminate = state2.context.isIndeterminate;
  const readOnly = state2.context.readOnly;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": indeterminate ? "indeterminate" : state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    indeterminate,
    focused,
    checkedState: state2.context.checked,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize.label({
        ...parts5.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom5.getRootId(state2.context),
        htmlFor: dom5.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled)
            return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled)
            return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (event.target === dom5.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts5.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom5.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts5.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom5.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts5.indicator.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        hidden: !indeterminate && !state2.context.checked
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: dom5.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom5.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onChange(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not3 } = guards;
function machine5(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "checkbox",
      initial: "ready",
      context: {
        checked: false,
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not3("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not3("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      computed: {
        isIndeterminate: (ctx2) => isIndeterminate(ctx2.checked),
        isChecked: (ctx2) => isChecked(ctx2.checked),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled)
            return;
          return trackPress({
            pointerNode: dom5.getRootEl(ctx2),
            keyboardNode: dom5.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled)
            return;
          return trackFocusVisible(dom5.getHiddenInputEl(ctx2), {
            onFocus: () => ctx2.focused = true,
            onBlur: () => ctx2.focused = false
          });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom5.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom5.getHiddenInputEl(ctx2);
          if (!inputEl)
            return;
          setElementChecked(inputEl, ctx2.isChecked);
          inputEl.indeterminate = ctx2.isIndeterminate;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set5.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2) {
          const checked = isIndeterminate(ctx2.checked) ? true : !ctx2.checked;
          set5.checked(ctx2, checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom5.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: isChecked(ctx2.checked) });
        }
      }
    }
  );
}
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function isChecked(checked) {
  return isIndeterminate(checked) ? false : !!checked;
}
var invoke3 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onCheckedChange) == null ? void 0 : _a.call(ctx, { checked: ctx.checked });
  }
};
var set5 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked))
      return;
    ctx.checked = checked;
    invoke3.change(ctx);
  }
};
var props5 = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps6 = createSplitProps(props5);

// node_modules/@ark-ui/anatomy/dist/checkbox/index.js
var anatomy7 = anatomy6.extendWith("group");

// node_modules/@zag-js/clipboard/dist/index.mjs
var anatomy8 = createAnatomy("clipboard").parts("root", "control", "trigger", "indicator", "input", "label");
var parts6 = anatomy8.build();
var dom6 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `clip-${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `clip-input-${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `clip-label-${ctx.id}`;
  },
  getInputEl: (ctx) => dom6.getById(ctx, dom6.getInputId(ctx)),
  writeToClipboard: (ctx) => copyText(dom6.getDoc(ctx), ctx.value)
});
function createNode(doc, text) {
  const node = doc.createElement("pre");
  Object.assign(node.style, {
    width: "1px",
    height: "1px",
    position: "fixed",
    top: "5px"
  });
  node.textContent = text;
  return node;
}
function copyNode(node) {
  const win = getWindow(node);
  const selection = win.getSelection();
  if (selection == null) {
    return Promise.reject(new Error());
  }
  selection.removeAllRanges();
  const doc = node.ownerDocument;
  const range2 = doc.createRange();
  range2.selectNodeContents(node);
  selection.addRange(range2);
  doc.execCommand("copy");
  selection.removeAllRanges();
  return Promise.resolve();
}
function copyText(doc, text) {
  var _a;
  const win = doc.defaultView || window;
  if (((_a = win.navigator.clipboard) == null ? void 0 : _a.writeText) !== void 0) {
    return win.navigator.clipboard.writeText(text);
  }
  if (!doc.body) {
    return Promise.reject(new Error());
  }
  const node = createNode(doc, text);
  doc.body.appendChild(node);
  copyNode(node);
  doc.body.removeChild(node);
  return Promise.resolve();
}
function connect6(state2, send, normalize) {
  const copied = state2.matches("copied");
  return {
    copied,
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    copy() {
      send({ type: "COPY" });
    },
    getRootProps() {
      return normalize.element({
        ...parts6.root.attrs,
        "data-copied": dataAttr(copied),
        id: dom6.getRootId(state2.context)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts6.label.attrs,
        htmlFor: dom6.getInputId(state2.context),
        "data-copied": dataAttr(copied),
        id: dom6.getLabelId(state2.context)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts6.control.attrs,
        "data-copied": dataAttr(copied)
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts6.input.attrs,
        defaultValue: state2.context.value,
        "data-copied": dataAttr(copied),
        readOnly: true,
        "data-readonly": "true",
        id: dom6.getInputId(state2.context),
        onFocus(event) {
          event.currentTarget.select();
        },
        onCopy() {
          send({ type: "INPUT.COPY" });
        }
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts6.trigger.attrs,
        "aria-label": copied ? "Copied to clipboard" : "Copy to clipboard",
        "data-copied": dataAttr(copied),
        onClick() {
          send({ type: "COPY" });
        }
      });
    },
    getIndicatorProps(props29) {
      return normalize.element({
        ...parts6.indicator.attrs,
        hidden: props29.copied !== copied
      });
    }
  };
}
function machine6(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "clipboard",
      initial: "idle",
      context: {
        value: "",
        timeout: 3e3,
        ...ctx
      },
      watch: {
        value: ["syncInputElement"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        COPY: {
          target: "copied",
          actions: ["copyToClipboard", "invokeOnCopy"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.COPY": {
              target: "copied",
              actions: ["invokeOnCopy"]
            }
          }
        },
        copied: {
          after: {
            COPY_TIMEOUT: "idle"
          },
          on: {
            COPY: {
              target: "copied",
              actions: ["copyToClipboard", "invokeOnCopy"]
            },
            "INPUT.COPY": {
              actions: ["invokeOnCopy"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue(ctx2, evt) {
          ctx2.value = evt.value;
        },
        copyToClipboard(ctx2) {
          dom6.writeToClipboard(ctx2);
        },
        invokeOnCopy(ctx2) {
          var _a;
          (_a = ctx2.onStatusChange) == null ? void 0 : _a.call(ctx2, { copied: true });
        },
        syncInputElement(ctx2) {
          dom6.setValue(dom6.getInputEl(ctx2), ctx2.value);
        }
      },
      delays: {
        COPY_TIMEOUT: (ctx2) => ctx2.timeout
      }
    }
  );
}
var props6 = createProps()([
  "getRootNode",
  "id",
  "ids",
  "value",
  "timeout",
  "onStatusChange"
]);
var contextProps = createSplitProps(props6);
var indicatorProps2 = createProps()(["copied"]);
var splitIndicatorProps2 = createSplitProps(indicatorProps2);

// node_modules/@zag-js/numeric-range/dist/index.mjs
function getMinValueAtIndex(index, values, minValue) {
  return index === 0 ? minValue : values[index - 1];
}
function getMaxValueAtIndex(index, values, maxValue) {
  return index === values.length - 1 ? maxValue : values[index + 1];
}
function getRoundedValue(value, minValue, step) {
  return Math.round((value - minValue) / step) * step + minValue;
}
function clampValue(value, minValue, maxValue) {
  return Math.min(Math.max(value, minValue), maxValue);
}
function getValuePercent(value, minValue, maxValue) {
  return (value - minValue) / (maxValue - minValue);
}
function getPercentValue(percent, minValue, maxValue, step) {
  const value = percent * (maxValue - minValue) + minValue;
  const roundedValue = getRoundedValue(value, minValue, step);
  return clampValue(roundedValue, minValue, maxValue);
}
function roundToStepPrecision(value, step) {
  let roundedValue = value;
  let stepString = step.toString();
  let pointIndex = stepString.indexOf(".");
  let precision = pointIndex >= 0 ? stepString.length - pointIndex : 0;
  if (precision > 0) {
    let pow = Math.pow(10, precision);
    roundedValue = Math.round(roundedValue * pow) / pow;
  }
  return roundedValue;
}
function snapValueToStep(value, min3, max3, step) {
  min3 = Number(min3);
  max3 = Number(max3);
  let remainder = (value - (isNaN(min3) ? 0 : min3)) % step;
  let snappedValue = roundToStepPrecision(
    Math.abs(remainder) * 2 >= step ? value + Math.sign(remainder) * (step - Math.abs(remainder)) : value - remainder,
    step
  );
  if (!isNaN(min3)) {
    if (snappedValue < min3) {
      snappedValue = min3;
    } else if (!isNaN(max3) && snappedValue > max3) {
      snappedValue = min3 + Math.floor(roundToStepPrecision((max3 - min3) / step, step)) * step;
    }
  } else if (!isNaN(max3) && snappedValue > max3) {
    snappedValue = Math.floor(roundToStepPrecision(max3 / step, step)) * step;
  }
  snappedValue = roundToStepPrecision(snappedValue, step);
  return snappedValue;
}
function setValueAtIndex(values, index, value) {
  if (values[index] === value)
    return values;
  return [...values.slice(0, index), value, ...values.slice(index + 1)];
}
function getValueSetterAtIndex(index, ctx) {
  const minValueAtIndex = getMinValueAtIndex(index, ctx.values, ctx.min);
  const maxValueAtIndex = getMaxValueAtIndex(index, ctx.values, ctx.max);
  let nextValues = ctx.values.slice();
  return function setValue(value) {
    let nextValue = snapValueToStep(value, minValueAtIndex, maxValueAtIndex, ctx.step);
    nextValues = setValueAtIndex(nextValues, index, value);
    nextValues[index] = nextValue;
    return nextValues;
  };
}
function getNextStepValue(index, ctx) {
  const nextValue = ctx.values[index] + ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getPreviousStepValue(index, ctx) {
  const nextValue = ctx.values[index] - ctx.step;
  return getValueSetterAtIndex(index, ctx)(nextValue);
}
function getClosestValueIndex(values, targetValue) {
  let targetIndex = values.findIndex((value) => targetValue - value < 0);
  if (targetIndex === 0) {
    return targetIndex;
  }
  if (targetIndex === -1) {
    return values.length - 1;
  }
  let valueBefore = values[targetIndex - 1];
  let valueAfter = values[targetIndex];
  if (Math.abs(valueBefore - targetValue) < Math.abs(valueAfter - targetValue)) {
    return targetIndex - 1;
  }
  return targetIndex;
}
function getValueRanges(values, minValue, maxValue, gap) {
  return values.map((value, index) => {
    const min3 = index === 0 ? minValue : values[index - 1] + gap;
    const max3 = index === values.length - 1 ? maxValue : values[index + 1] - gap;
    return { min: min3, max: max3, value };
  });
}
function getValueTransformer(valueA, valueB) {
  const input = { min: valueA[0], max: valueA[1] };
  const output = { min: valueB[0], max: valueB[1] };
  return function getValue(value) {
    if (input.min === input.max || output.min === output.max)
      return output.min;
    const ratio = (output.max - output.min) / (input.max - input.min);
    return output.min + ratio * (value - input.min);
  };
}
function toFixedNumber(value, digits = 0, base = 10) {
  const pow = Math.pow(base, digits);
  return Math.round(value * pow) / pow;
}
function mod(value, modulo) {
  return (value % modulo + modulo) % modulo;
}

// node_modules/@zag-js/color-utils/dist/index.mjs
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField2 = (obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
var generateRGB_R = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,0),rgb(${zValue},255,0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(${zValue},0,255),rgb(${zValue},255,255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_G = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},0),rgb(255,${zValue},0))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,${zValue},255),rgb(255,${zValue},255))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateRGB_B = (orientation, dir, zValue) => {
  const maskImage = `linear-gradient(to ${orientation[Number(!dir)]}, transparent, #000)`;
  const result = {
    areaStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,0,${zValue}),rgb(255,0,${zValue}))`
    },
    areaGradientStyles: {
      backgroundImage: `linear-gradient(to ${orientation[Number(dir)]},rgb(0,255,${zValue}),rgb(255,255,${zValue}))`,
      WebkitMaskImage: maskImage,
      maskImage
    }
  };
  return result;
};
var generateHSL_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]}, hsla(0,0%,0%,1) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,1) 100%)`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,50%),hsla(0,0%,50%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSL_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]}, hsla(0,0%,0%,${alphaValue}) 0%, hsla(0,0%,0%,0) 50%, hsla(0,0%,100%,0) 50%, hsla(0,0%,100%,${alphaValue}) 100%)`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "hsl(0, 0%, 50%)"
      ].join(",")
    }
  };
  return result;
};
var generateHSL_L = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      backgroundImage: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,${zValue}%),hsla(0,0%,${zValue}%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,100%,${zValue}%),hsl(60,100%,${zValue}%),hsl(120,100%,${zValue}%),hsl(180,100%,${zValue}%),hsl(240,100%,${zValue}%),hsl(300,100%,${zValue}%),hsl(360,100%,${zValue}%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_H = (orientation, dir, zValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(dir)]},hsl(0,0%,0%),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,100%),hsla(0,0%,100%,0))`,
        `hsl(${zValue}, 100%, 50%)`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_S = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,0%,${alphaValue}),hsla(0,0%,0%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        `linear-gradient(to ${orientation[Number(!dir)]},hsl(0,0%,0%),hsl(0,0%,100%))`
      ].join(",")
    }
  };
  return result;
};
var generateHSB_B = (orientation, dir, alphaValue) => {
  const result = {
    areaStyles: {},
    areaGradientStyles: {
      background: [
        `linear-gradient(to ${orientation[Number(!dir)]},hsla(0,0%,100%,${alphaValue}),hsla(0,0%,100%,0))`,
        `linear-gradient(to ${orientation[Number(dir)]},hsla(0,100%,50%,${alphaValue}),hsla(60,100%,50%,${alphaValue}),hsla(120,100%,50%,${alphaValue}),hsla(180,100%,50%,${alphaValue}),hsla(240,100%,50%,${alphaValue}),hsla(300,100%,50%,${alphaValue}),hsla(359,100%,50%,${alphaValue}))`,
        "#000"
      ].join(",")
    }
  };
  return result;
};
function getColorAreaGradient(color, options) {
  const { xChannel, yChannel, dir: dirProp = "ltr" } = options;
  const { zChannel } = color.getColorAxes({ xChannel, yChannel });
  const zValue = color.getChannelValue(zChannel);
  const { minValue: zMin, maxValue: zMax } = color.getChannelRange(zChannel);
  const orientation = ["top", dirProp === "rtl" ? "left" : "right"];
  let dir = false;
  let background = { areaStyles: {}, areaGradientStyles: {} };
  let alphaValue = (zValue - zMin) / (zMax - zMin);
  let isHSL = color.getFormat() === "hsla";
  switch (zChannel) {
    case "red": {
      dir = xChannel === "green";
      background = generateRGB_R(orientation, dir, zValue);
      break;
    }
    case "green": {
      dir = xChannel === "red";
      background = generateRGB_G(orientation, dir, zValue);
      break;
    }
    case "blue": {
      dir = xChannel === "red";
      background = generateRGB_B(orientation, dir, zValue);
      break;
    }
    case "hue": {
      dir = xChannel !== "saturation";
      if (isHSL) {
        background = generateHSL_H(orientation, dir, zValue);
      } else {
        background = generateHSB_H(orientation, dir, zValue);
      }
      break;
    }
    case "saturation": {
      dir = xChannel === "hue";
      if (isHSL) {
        background = generateHSL_S(orientation, dir, alphaValue);
      } else {
        background = generateHSB_S(orientation, dir, alphaValue);
      }
      break;
    }
    case "brightness": {
      dir = xChannel === "hue";
      background = generateHSB_B(orientation, dir, alphaValue);
      break;
    }
    case "lightness": {
      dir = xChannel === "hue";
      background = generateHSL_L(orientation, dir, zValue);
      break;
    }
  }
  return background;
}
var isEqualObject = (a2, b2) => {
  if (Object.keys(a2).length !== Object.keys(b2).length)
    return false;
  for (let key in a2)
    if (a2[key] !== b2[key])
      return false;
  return true;
};
var Color = class {
  toHexInt() {
    return this.toFormat("rgba").toHexInt();
  }
  getChannelValue(channel) {
    if (channel in this)
      return this[channel];
    throw new Error("Unsupported color channel: " + channel);
  }
  getChannelValuePercent(channel, valueToCheck) {
    const value = valueToCheck ?? this.getChannelValue(channel);
    const { minValue, maxValue } = this.getChannelRange(channel);
    return getValuePercent(value, minValue, maxValue);
  }
  getChannelPercentValue(channel, percentToCheck) {
    const { minValue, maxValue, step } = this.getChannelRange(channel);
    const percentValue = getPercentValue(percentToCheck, minValue, maxValue, step);
    return snapValueToStep(percentValue, minValue, maxValue, step);
  }
  withChannelValue(channel, value) {
    const { minValue, maxValue } = this.getChannelRange(channel);
    if (channel in this) {
      let clone = this.clone();
      clone[channel] = clampValue(value, minValue, maxValue);
      return clone;
    }
    throw new Error("Unsupported color channel: " + channel);
  }
  getColorAxes(xyChannels) {
    let { xChannel, yChannel } = xyChannels;
    let xCh = xChannel || this.getChannels().find((c) => c !== yChannel);
    let yCh = yChannel || this.getChannels().find((c) => c !== xCh);
    let zCh = this.getChannels().find((c) => c !== xCh && c !== yCh);
    return { xChannel: xCh, yChannel: yCh, zChannel: zCh };
  }
  incrementChannel(channel, stepSize) {
    const { minValue, maxValue, step } = this.getChannelRange(channel);
    const value = snapValueToStep(
      clampValue(this.getChannelValue(channel) + stepSize, minValue, maxValue),
      minValue,
      maxValue,
      step
    );
    return this.withChannelValue(channel, value);
  }
  decrementChannel(channel, stepSize) {
    return this.incrementChannel(channel, -stepSize);
  }
  isEqual(color) {
    const isSame = isEqualObject(this.toJSON(), color.toJSON());
    return isSame && this.getChannelValue("alpha") === color.getChannelValue("alpha");
  }
};
var _RGBColor = class _RGBColor2 extends Color {
  constructor(red, green, blue, alpha) {
    super();
    this.red = red;
    this.green = green;
    this.blue = blue;
    this.alpha = alpha;
  }
  static parse(value) {
    let colors = [];
    if (/^#[\da-f]+$/i.test(value) && [4, 5, 7, 9].includes(value.length)) {
      const values = (value.length < 6 ? value.replace(/[^#]/gi, "$&$&") : value).slice(1).split("");
      while (values.length > 0) {
        colors.push(parseInt(values.splice(0, 2).join(""), 16));
      }
      colors[3] = colors[3] !== void 0 ? colors[3] / 255 : void 0;
    }
    const match4 = value.match(/^rgba?\((.*)\)$/);
    if (match4 == null ? void 0 : match4[1]) {
      colors = match4[1].split(",").map((value2) => Number(value2.trim())).map((num, i) => clampValue(num, 0, i < 3 ? 255 : 1));
    }
    return colors.length < 3 ? void 0 : new _RGBColor2(colors[0], colors[1], colors[2], colors[3] ?? 1);
  }
  toString(format) {
    switch (format) {
      case "hex":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0")).toUpperCase();
      case "hexa":
        return "#" + (this.red.toString(16).padStart(2, "0") + this.green.toString(16).padStart(2, "0") + this.blue.toString(16).padStart(2, "0") + Math.round(this.alpha * 255).toString(16).padStart(2, "0")).toUpperCase();
      case "rgb":
        return `rgb(${this.red}, ${this.green}, ${this.blue})`;
      case "css":
      case "rgba":
        return `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "hsb":
        return this.toHSB().toString("hsb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "rgba":
        return this;
      case "hsba":
        return this.toHSB();
      case "hsla":
        return this.toHSL();
      default:
        throw new Error("Unsupported color conversion: rgb -> " + format);
    }
  }
  toHexInt() {
    return this.red << 16 | this.green << 8 | this.blue;
  }
  /**
   * Converts an RGB color value to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSBColor object.
   */
  toHSB() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min3 = Math.min(red, green, blue);
    const brightness = Math.max(red, green, blue);
    const chroma = brightness - min3;
    const saturation = brightness === 0 ? 0 : chroma / brightness;
    let hue = 0;
    if (chroma !== 0) {
      switch (brightness) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSBColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts an RGB color value to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#From_RGB.
   * @returns An HSLColor object.
   */
  toHSL() {
    const red = this.red / 255;
    const green = this.green / 255;
    const blue = this.blue / 255;
    const min3 = Math.min(red, green, blue);
    const max3 = Math.max(red, green, blue);
    const lightness = (max3 + min3) / 2;
    const chroma = max3 - min3;
    let hue = -1;
    let saturation = -1;
    if (chroma === 0) {
      hue = saturation = 0;
    } else {
      saturation = chroma / (lightness < 0.5 ? max3 + min3 : 2 - max3 - min3);
      switch (max3) {
        case red:
          hue = (green - blue) / chroma + (green < blue ? 6 : 0);
          break;
        case green:
          hue = (blue - red) / chroma + 2;
          break;
        case blue:
          hue = (red - green) / chroma + 4;
          break;
      }
      hue /= 6;
    }
    return new HSLColor(
      toFixedNumber(hue * 360, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _RGBColor2(this.red, this.green, this.blue, this.alpha);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "red":
      case "green":
      case "blue":
        return { minValue: 0, maxValue: 255, step: 1, pageSize: 17 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { r: this.red, g: this.green, b: this.blue, a: this.alpha };
  }
  getFormat() {
    return "rgba";
  }
  getChannels() {
    return _RGBColor2.colorChannels;
  }
};
__publicField2(_RGBColor, "colorChannels", ["red", "green", "blue"]);
var RGBColor = _RGBColor;
var HSL_REGEX = /hsl\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsla\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSLColor = class _HSLColor2 extends Color {
  constructor(hue, saturation, lightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.lightness = lightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSL_REGEX)) {
      const [h, s, l2, a2] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSLColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(l2, 0, 100), clampValue(a2 ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsl":
        return `hsl(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%)`;
      case "css":
      case "hsla":
        return `hsla(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.lightness, 2)}%, ${this.alpha})`;
      case "hsb":
        return this.toHSB().toString("hsb");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsla":
        return this;
      case "hsba":
        return this.toHSB();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsl -> " + format);
    }
  }
  /**
   * Converts a HSL color to HSB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_HSV.
   * @returns An HSBColor object.
   */
  toHSB() {
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let brightness = lightness + saturation * Math.min(lightness, 1 - lightness);
    saturation = brightness === 0 ? 0 : 2 * (1 - lightness / brightness);
    return new HSBColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(brightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSL color to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let lightness = this.lightness / 100;
    let a2 = saturation * Math.min(lightness, 1 - lightness);
    let fn = (n, k = (n + hue / 30) % 12) => lightness - a2 * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return new RGBColor(
      Math.round(fn(0) * 255),
      Math.round(fn(8) * 255),
      Math.round(fn(4) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSLColor2(this.hue, this.saturation, this.lightness, this.alpha);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "lightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, l: this.lightness, a: this.alpha };
  }
  getFormat() {
    return "hsla";
  }
  getChannels() {
    return _HSLColor2.colorChannels;
  }
};
__publicField2(_HSLColor, "colorChannels", ["hue", "saturation", "lightness"]);
var HSLColor = _HSLColor;
var HSB_REGEX = /hsb\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%)\)|hsba\(([-+]?\d+(?:.\d+)?\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d+(?:.\d+)?%\s*,\s*[-+]?\d(.\d+)?)\)/;
var _HSBColor = class _HSBColor2 extends Color {
  constructor(hue, saturation, brightness, alpha) {
    super();
    this.hue = hue;
    this.saturation = saturation;
    this.brightness = brightness;
    this.alpha = alpha;
  }
  static parse(value) {
    let m;
    if (m = value.match(HSB_REGEX)) {
      const [h, s, b2, a2] = (m[1] ?? m[2]).split(",").map((n) => Number(n.trim().replace("%", "")));
      return new _HSBColor2(mod(h, 360), clampValue(s, 0, 100), clampValue(b2, 0, 100), clampValue(a2 ?? 1, 0, 1));
    }
  }
  toString(format) {
    switch (format) {
      case "css":
        return this.toHSL().toString("css");
      case "hex":
        return this.toRGB().toString("hex");
      case "hexa":
        return this.toRGB().toString("hexa");
      case "hsb":
        return `hsb(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%)`;
      case "hsba":
        return `hsba(${this.hue}, ${toFixedNumber(this.saturation, 2)}%, ${toFixedNumber(this.brightness, 2)}%, ${this.alpha})`;
      case "hsl":
        return this.toHSL().toString("hsl");
      case "rgb":
        return this.toRGB().toString("rgb");
      default:
        return this.toFormat(format).toString(format);
    }
  }
  toFormat(format) {
    switch (format) {
      case "hsba":
        return this;
      case "hsla":
        return this.toHSL();
      case "rgba":
        return this.toRGB();
      default:
        throw new Error("Unsupported color conversion: hsb -> " + format);
    }
  }
  /**
   * Converts a HSB color to HSL.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_HSL.
   * @returns An HSLColor object.
   */
  toHSL() {
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let lightness = brightness * (1 - saturation / 2);
    saturation = lightness === 0 || lightness === 1 ? 0 : (brightness - lightness) / Math.min(lightness, 1 - lightness);
    return new HSLColor(
      toFixedNumber(this.hue, 2),
      toFixedNumber(saturation * 100, 2),
      toFixedNumber(lightness * 100, 2),
      toFixedNumber(this.alpha, 2)
    );
  }
  /**
   * Converts a HSV color value to RGB.
   * Conversion formula adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSV_to_RGB_alternative.
   * @returns An RGBColor object.
   */
  toRGB() {
    let hue = this.hue;
    let saturation = this.saturation / 100;
    let brightness = this.brightness / 100;
    let fn = (n, k = (n + hue / 60) % 6) => brightness - saturation * brightness * Math.max(Math.min(k, 4 - k, 1), 0);
    return new RGBColor(
      Math.round(fn(5) * 255),
      Math.round(fn(3) * 255),
      Math.round(fn(1) * 255),
      toFixedNumber(this.alpha, 2)
    );
  }
  clone() {
    return new _HSBColor2(this.hue, this.saturation, this.brightness, this.alpha);
  }
  getChannelRange(channel) {
    switch (channel) {
      case "hue":
        return { minValue: 0, maxValue: 360, step: 1, pageSize: 15 };
      case "saturation":
      case "brightness":
        return { minValue: 0, maxValue: 100, step: 1, pageSize: 10 };
      case "alpha":
        return { minValue: 0, maxValue: 1, step: 0.01, pageSize: 0.1 };
      default:
        throw new Error("Unknown color channel: " + channel);
    }
  }
  toJSON() {
    return { h: this.hue, s: this.saturation, b: this.brightness, a: this.alpha };
  }
  getFormat() {
    return "hsba";
  }
  getChannels() {
    return _HSBColor2.colorChannels;
  }
};
__publicField2(_HSBColor, "colorChannels", ["hue", "saturation", "brightness"]);
var HSBColor = _HSBColor;
var nativeColors = "aliceblue:f0f8ff,antiquewhite:faebd7,aqua:00ffff,aquamarine:7fffd4,azure:f0ffff,beige:f5f5dc,bisque:ffe4c4,black:000000,blanchedalmond:ffebcd,blue:0000ff,blueviolet:8a2be2,brown:a52a2a,burlywood:deb887,cadetblue:5f9ea0,chartreuse:7fff00,chocolate:d2691e,coral:ff7f50,cornflowerblue:6495ed,cornsilk:fff8dc,crimson:dc143c,cyan:00ffff,darkblue:00008b,darkcyan:008b8b,darkgoldenrod:b8860b,darkgray:a9a9a9,darkgreen:006400,darkkhaki:bdb76b,darkmagenta:8b008b,darkolivegreen:556b2f,darkorange:ff8c00,darkorchid:9932cc,darkred:8b0000,darksalmon:e9967a,darkseagreen:8fbc8f,darkslateblue:483d8b,darkslategray:2f4f4f,darkturquoise:00ced1,darkviolet:9400d3,deeppink:ff1493,deepskyblue:00bfff,dimgray:696969,dodgerblue:1e90ff,firebrick:b22222,floralwhite:fffaf0,forestgreen:228b22,fuchsia:ff00ff,gainsboro:dcdcdc,ghostwhite:f8f8ff,gold:ffd700,goldenrod:daa520,gray:808080,green:008000,greenyellow:adff2f,honeydew:f0fff0,hotpink:ff69b4,indianred:cd5c5c,indigo:4b0082,ivory:fffff0,khaki:f0e68c,lavender:e6e6fa,lavenderblush:fff0f5,lawngreen:7cfc00,lemonchiffon:fffacd,lightblue:add8e6,lightcoral:f08080,lightcyan:e0ffff,lightgoldenrodyellow:fafad2,lightgrey:d3d3d3,lightgreen:90ee90,lightpink:ffb6c1,lightsalmon:ffa07a,lightseagreen:20b2aa,lightskyblue:87cefa,lightslategray:778899,lightsteelblue:b0c4de,lightyellow:ffffe0,lime:00ff00,limegreen:32cd32,linen:faf0e6,magenta:ff00ff,maroon:800000,mediumaquamarine:66cdaa,mediumblue:0000cd,mediumorchid:ba55d3,mediumpurple:9370d8,mediumseagreen:3cb371,mediumslateblue:7b68ee,mediumspringgreen:00fa9a,mediumturquoise:48d1cc,mediumvioletred:c71585,midnightblue:191970,mintcream:f5fffa,mistyrose:ffe4e1,moccasin:ffe4b5,navajowhite:ffdead,navy:000080,oldlace:fdf5e6,olive:808000,olivedrab:6b8e23,orange:ffa500,orangered:ff4500,orchid:da70d6,palegoldenrod:eee8aa,palegreen:98fb98,paleturquoise:afeeee,palevioletred:d87093,papayawhip:ffefd5,peachpuff:ffdab9,peru:cd853f,pink:ffc0cb,plum:dda0dd,powderblue:b0e0e6,purple:800080,red:ff0000,rosybrown:bc8f8f,royalblue:4169e1,saddlebrown:8b4513,salmon:fa8072,sandybrown:f4a460,seagreen:2e8b57,seashell:fff5ee,sienna:a0522d,silver:c0c0c0,skyblue:87ceeb,slateblue:6a5acd,slategray:708090,snow:fffafa,springgreen:00ff7f,steelblue:4682b4,tan:d2b48c,teal:008080,thistle:d8bfd8,tomato:ff6347,turquoise:40e0d0,violet:ee82ee,wheat:f5deb3,white:ffffff,whitesmoke:f5f5f5,yellow:ffff00,yellowgreen:9acd32";
var makeMap = (str) => {
  const map = /* @__PURE__ */ new Map();
  const list = str.split(",");
  for (let i = 0; i < list.length; i++) {
    const [key, val] = list[i].split(":");
    map.set(key, `#${val}`);
  }
  return map;
};
var nativeColorMap = makeMap(nativeColors);
var parseColor = (value) => {
  var _a;
  if (nativeColorMap.has(value)) {
    return parseColor(nativeColorMap.get(value));
  }
  const result = RGBColor.parse(value) || HSBColor.parse(value) || HSLColor.parse(value);
  if (!result) {
    const error = new Error("Invalid color value: " + value);
    (_a = Error.captureStackTrace) == null ? void 0 : _a.call(Error, error, parseColor);
    throw error;
  }
  return result;
};
var normalizeColor = (v) => {
  return typeof v === "string" ? parseColor(v) : v;
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var sides = ["top", "right", "bottom", "left"];
var alignments = ["start", "end"];
var placements = sides.reduce((acc, side) => acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]), []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp2(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment2(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment2(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment2(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x,
    y,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y,
    left: x,
    right: x + width,
    bottom: y + height,
    x,
    y
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment2(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state2, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state2;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state2);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x,
    y,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var arrow = (options) => ({
  name: "arrow",
  options,
  async fn(state2) {
    const {
      x,
      y,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state2;
    const {
      element,
      padding = 0
    } = evaluate(options, state2) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x,
      y
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max3 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset3 = clamp2(min$1, center, max3);
    const shouldAddOffset = !middlewareData.arrow && getAlignment2(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max3 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset3,
        centerOffset: center - offset3 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state2) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state2);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex2 = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex2];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex2,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state2, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state2;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment2(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state2);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state2) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state2;
      const diffCoords = await convertValueToCoords(state2, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state2) {
      const {
        x,
        y,
        placement
      } = state2;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min3 = mainAxisCoord + overflow[minSide];
        const max3 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp2(min3, mainAxisCoord, max3);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min3 = crossAxisCoord + overflow[minSide];
        const max3 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp2(min3, crossAxisCoord, max3);
      }
      const limitedCoords = limiter.fn({
        ...state2,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};
var limitShift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state2) {
      const {
        x,
        y,
        placement,
        rects,
        middlewareData
      } = state2;
      const {
        offset: offset3 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state2);
      const coords = {
        x,
        y
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset3, state2);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
var size = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state2) {
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state2;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state2);
      const overflow = await detectOverflow(state2, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment2(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state2.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if (isYAxis) {
        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
      } else {
        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state2,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName2(node) {
  if (isNode2(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow3(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement2(node) {
  var _ref;
  return (_ref = (isNode2(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode2(value) {
  return value instanceof Node || value instanceof getWindow3(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow3(value).Element;
}
function isHTMLElement3(value) {
  return value instanceof HTMLElement || value instanceof getWindow3(value).HTMLElement;
}
function isShadowRoot2(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow3(value).ShadowRoot;
}
function isOverflowElement2(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle3(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName2(element));
}
function isContainingBlock(element) {
  const webkit = isWebKit();
  const css2 = getComputedStyle3(element);
  return css2.transform !== "none" || css2.perspective !== "none" || (css2.containerType ? css2.containerType !== "normal" : false) || !webkit && (css2.backdropFilter ? css2.backdropFilter !== "none" : false) || !webkit && (css2.filter ? css2.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css2.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css2.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement3(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    }
    currentNode = getParentNode2(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName2(node));
}
function getComputedStyle3(element) {
  return getWindow3(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode2(node) {
  if (getNodeName2(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot2(node) && node.host || // Fallback.
    getDocumentElement2(node)
  );
  return isShadowRoot2(result) ? result.host : result;
}
function getNearestOverflowAncestor2(node) {
  const parentNode = getParentNode2(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement3(parentNode) && isOverflowElement2(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor2(parentNode);
}
function getOverflowAncestors2(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor2(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow3(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement2(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors2(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors2(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  const css2 = getComputedStyle3(element);
  let width = parseFloat(css2.width) || 0;
  let height = parseFloat(css2.height) || 0;
  const hasOffset = isHTMLElement3(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement3(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $: $2
  } = getCssDimensions(domElement);
  let x = ($2 ? round(rect.width) : rect.width) / width;
  let y = ($2 ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow3(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow3(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow3(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow3(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css2 = getComputedStyle3(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css2.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css2.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow3(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element) {
  return topLayerSelectors.some((selector) => {
    try {
      return element.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement2(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement3(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement2(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  const html = getDocumentElement2(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y = -scroll.scrollTop;
  if (getComputedStyle3(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow3(element);
  const html = getDocumentElement2(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement3(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement2(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode2(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle3(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors2(element, [], false).filter((el) => isElement(el) && getNodeName2(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle3(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode2(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle3(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement2(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode2(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement3(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName2(offsetParent) !== "body" || isOverflowElement2(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle3(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement3(element) || getComputedStyle3(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow3(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement3(element)) {
    let svgOffsetParent = getParentNode2(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode2(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle3(element).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement: getDocumentElement2,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement2(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors2(referenceEl) : [], ...getOverflowAncestors2(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var size2 = size;
var arrow2 = arrow;
var limitShift2 = limitShift;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/@zag-js/popper/dist/index.mjs
function createDOMRect(x = 0, y = 0, width = 0, height = 0) {
  if (typeof DOMRect === "function") {
    return new DOMRect(x, y, width, height);
  }
  const rect = {
    x,
    y,
    width,
    height,
    top: y,
    right: x + width,
    bottom: y + height,
    left: x
  };
  return { ...rect, toJSON: () => rect };
}
function getDOMRect(anchorRect) {
  if (!anchorRect)
    return createDOMRect();
  const { x, y, width, height } = anchorRect;
  return createDOMRect(x, y, width, height);
}
function getAnchorElement(anchorElement, getAnchorRect) {
  return {
    contextElement: isHTMLElement(anchorElement) ? anchorElement : void 0,
    getBoundingClientRect: () => {
      const anchor = anchorElement;
      const anchorRect = getAnchorRect == null ? void 0 : getAnchorRect(anchor);
      if (anchorRect || !anchor) {
        return getDOMRect(anchorRect);
      }
      return anchor.getBoundingClientRect();
    }
  };
}
var toVar = (value) => ({ variable: value, reference: `var(${value})` });
var cssVars = {
  arrowSize: toVar("--arrow-size"),
  arrowSizeHalf: toVar("--arrow-size-half"),
  arrowBg: toVar("--arrow-background"),
  transformOrigin: toVar("--transform-origin"),
  arrowOffset: toVar("--arrow-offset")
};
var getTransformOrigin = (arrow22) => ({
  top: "bottom center",
  "top-start": arrow22 ? `${arrow22.x}px bottom` : "left bottom",
  "top-end": arrow22 ? `${arrow22.x}px bottom` : "right bottom",
  bottom: "top center",
  "bottom-start": arrow22 ? `${arrow22.x}px top` : "top left",
  "bottom-end": arrow22 ? `${arrow22.x}px top` : "top right",
  left: "right center",
  "left-start": arrow22 ? `right ${arrow22.y}px` : "right top",
  "left-end": arrow22 ? `right ${arrow22.y}px` : "right bottom",
  right: "left center",
  "right-start": arrow22 ? `left ${arrow22.y}px` : "left top",
  "right-end": arrow22 ? `left ${arrow22.y}px` : "left bottom"
});
var transformOriginMiddleware = {
  name: "transformOrigin",
  fn({ placement, elements, middlewareData }) {
    const { arrow: arrow22 } = middlewareData;
    const transformOrigin = getTransformOrigin(arrow22)[placement];
    const { floating } = elements;
    floating.style.setProperty(cssVars.transformOrigin.variable, transformOrigin);
    return {
      data: { transformOrigin }
    };
  }
};
var rectMiddleware = {
  name: "rects",
  fn({ rects }) {
    return {
      data: rects
    };
  }
};
var shiftArrowMiddleware = (arrowEl) => {
  if (!arrowEl)
    return;
  return {
    name: "shiftArrow",
    fn({ placement, middlewareData }) {
      if (!middlewareData.arrow)
        return {};
      const { x, y } = middlewareData.arrow;
      const dir = placement.split("-")[0];
      Object.assign(arrowEl.style, {
        left: x != null ? `${x}px` : "",
        top: y != null ? `${y}px` : "",
        [dir]: `calc(100% + ${cssVars.arrowOffset.reference})`
      });
      return {};
    }
  };
};
function getPlacementDetails(placement) {
  const [side, align] = placement.split("-");
  return { side, align, hasAlign: align != null };
}
function getPlacementSide(placement) {
  return placement.split("-")[0];
}
var defaultOptions = {
  strategy: "absolute",
  placement: "bottom",
  listeners: true,
  gutter: 8,
  flip: true,
  slide: true,
  overlap: false,
  sameWidth: false,
  fitViewport: false,
  overflowPadding: 8,
  arrowPadding: 4
};
function roundByDpr(win, value) {
  const dpr = win.devicePixelRatio || 1;
  return Math.round(value * dpr) / dpr;
}
function getBoundaryMiddleware(opts) {
  return runIfFn(opts.boundary);
}
function getArrowMiddleware(arrowElement, opts) {
  if (!arrowElement)
    return;
  return arrow2({
    element: arrowElement,
    padding: opts.arrowPadding
  });
}
function getOffsetMiddleware(arrowElement, opts) {
  if (isNull(opts.offset ?? opts.gutter))
    return;
  return offset2(({ placement }) => {
    var _a, _b;
    const arrowOffset = ((arrowElement == null ? void 0 : arrowElement.clientHeight) || 0) / 2;
    const gutter = ((_a = opts.offset) == null ? void 0 : _a.mainAxis) ?? opts.gutter;
    const mainAxis = typeof gutter === "number" ? gutter + arrowOffset : gutter ?? arrowOffset;
    const { hasAlign } = getPlacementDetails(placement);
    const shift22 = !hasAlign ? opts.shift : void 0;
    const crossAxis = ((_b = opts.offset) == null ? void 0 : _b.crossAxis) ?? shift22;
    return compact({
      crossAxis,
      mainAxis,
      alignmentAxis: opts.shift
    });
  });
}
function getFlipMiddleware(opts) {
  if (!opts.flip)
    return;
  return flip2({
    boundary: getBoundaryMiddleware(opts),
    padding: opts.overflowPadding,
    fallbackPlacements: opts.flip === true ? void 0 : opts.flip
  });
}
function getShiftMiddleware(opts) {
  if (!opts.slide && !opts.overlap)
    return;
  return shift2({
    boundary: getBoundaryMiddleware(opts),
    mainAxis: opts.slide,
    crossAxis: opts.overlap,
    padding: opts.overflowPadding,
    limiter: limitShift2()
  });
}
function getSizeMiddleware(opts) {
  return size2({
    padding: opts.overflowPadding,
    apply({ elements, rects, availableHeight, availableWidth }) {
      const floating = elements.floating;
      const referenceWidth = Math.round(rects.reference.width);
      availableWidth = Math.floor(availableWidth);
      availableHeight = Math.floor(availableHeight);
      floating.style.setProperty("--reference-width", `${referenceWidth}px`);
      floating.style.setProperty("--available-width", `${availableWidth}px`);
      floating.style.setProperty("--available-height", `${availableHeight}px`);
    }
  });
}
function getAutoUpdateOptions(opts) {
  if (!opts)
    return {};
  if (opts === true) {
    return { ancestorResize: true, ancestorScroll: true, elementResize: true, layoutShift: true };
  }
  return opts;
}
function getPlacementImpl(referenceOrVirtual, floating, opts = {}) {
  const reference = getAnchorElement(referenceOrVirtual, opts.getAnchorRect);
  if (!floating || !reference)
    return;
  const options = Object.assign({}, defaultOptions, opts);
  const arrowEl = floating.querySelector("[data-part=arrow]");
  const middleware = [
    getOffsetMiddleware(arrowEl, options),
    getFlipMiddleware(options),
    getShiftMiddleware(options),
    getArrowMiddleware(arrowEl, options),
    shiftArrowMiddleware(arrowEl),
    transformOriginMiddleware,
    getSizeMiddleware(options),
    rectMiddleware
  ];
  const { placement, strategy, onComplete, onPositioned } = options;
  const updatePosition = async () => {
    if (!reference || !floating)
      return;
    const pos = await computePosition2(reference, floating, {
      placement,
      middleware,
      strategy
    });
    onComplete == null ? void 0 : onComplete(pos);
    onPositioned == null ? void 0 : onPositioned({ placed: true });
    const win = getWindow(floating);
    const x = roundByDpr(win, pos.x);
    const y = roundByDpr(win, pos.y);
    floating.style.setProperty("--x", `${x}px`);
    floating.style.setProperty("--y", `${y}px`);
    const contentEl = floating.firstElementChild;
    if (contentEl) {
      const zIndex = win.getComputedStyle(contentEl).zIndex;
      floating.style.setProperty("--z-index", zIndex);
    }
  };
  const update = async () => {
    if (opts.updatePosition) {
      await opts.updatePosition({ updatePosition });
      onPositioned == null ? void 0 : onPositioned({ placed: true });
    } else {
      await updatePosition();
    }
  };
  const autoUpdateOptions = getAutoUpdateOptions(options.listeners);
  const cancelAutoUpdate = options.listeners ? autoUpdate(reference, floating, update, autoUpdateOptions) : noop2;
  update();
  return () => {
    cancelAutoUpdate == null ? void 0 : cancelAutoUpdate();
    onPositioned == null ? void 0 : onPositioned({ placed: false });
  };
}
function getPlacement(referenceOrFn, floatingOrFn, opts = {}) {
  const { defer, ...options } = opts;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const reference = typeof referenceOrFn === "function" ? referenceOrFn() : referenceOrFn;
      const floating = typeof floatingOrFn === "function" ? floatingOrFn() : floatingOrFn;
      cleanups2.push(getPlacementImpl(reference, floating, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
var ARROW_FLOATING_STYLE = {
  bottom: "rotate(45deg)",
  left: "rotate(135deg)",
  top: "rotate(225deg)",
  right: "rotate(315deg)"
};
function getPlacementStyles(options = {}) {
  const { placement, sameWidth, fitViewport, strategy = "absolute" } = options;
  return {
    arrow: {
      position: "absolute",
      width: cssVars.arrowSize.reference,
      height: cssVars.arrowSize.reference,
      [cssVars.arrowSizeHalf.variable]: `calc(${cssVars.arrowSize.reference} / 2)`,
      [cssVars.arrowOffset.variable]: `calc(${cssVars.arrowSizeHalf.reference} * -1)`
    },
    arrowTip: {
      transform: placement ? ARROW_FLOATING_STYLE[placement.split("-")[0]] : void 0,
      background: cssVars.arrowBg.reference,
      top: "0",
      left: "0",
      width: "100%",
      height: "100%",
      position: "absolute",
      zIndex: "inherit"
    },
    floating: {
      position: strategy,
      isolation: "isolate",
      minWidth: sameWidth ? void 0 : "max-content",
      width: sameWidth ? "var(--reference-width)" : void 0,
      maxWidth: fitViewport ? "var(--available-width)" : void 0,
      maxHeight: fitViewport ? "var(--available-height)" : void 0,
      top: "0px",
      left: "0px",
      // move off-screen if placement is not defined
      transform: placement ? "translate3d(var(--x), var(--y), 0)" : "translate3d(0, -100vh, 0)",
      zIndex: "var(--z-index)"
    }
  };
}

// node_modules/@zag-js/interact-outside/dist/index.mjs
function getWindowFrames(win) {
  const frames = {
    each(cb) {
      var _a;
      for (let i = 0; i < ((_a = win.frames) == null ? void 0 : _a.length); i += 1) {
        const frame = win.frames[i];
        if (frame)
          cb(frame);
      }
    },
    addEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.addEventListener(event, listener, options);
        } catch {
        }
      });
      return () => {
        try {
          frames.removeEventListener(event, listener, options);
        } catch {
        }
      };
    },
    removeEventListener(event, listener, options) {
      frames.each((frame) => {
        try {
          frame.document.removeEventListener(event, listener, options);
        } catch {
        }
      });
    }
  };
  return frames;
}
var POINTER_OUTSIDE_EVENT = "pointerdown.outside";
var FOCUS_OUTSIDE_EVENT = "focus.outside";
function isComposedPathFocusable(composedPath) {
  for (const node of composedPath) {
    if (isHTMLElement(node) && isFocusable(node))
      return true;
  }
  return false;
}
var isPointerEvent = (event) => "clientY" in event;
function isEventPointWithin(node, event) {
  if (!isPointerEvent(event) || !node)
    return false;
  const rect = node.getBoundingClientRect();
  if (rect.width === 0 || rect.height === 0)
    return false;
  return rect.top <= event.clientY && event.clientY <= rect.top + rect.height && rect.left <= event.clientX && event.clientX <= rect.left + rect.width;
}
function isEventWithinScrollbar(event) {
  const target = getEventTarget(event);
  if (!target || !isPointerEvent(event))
    return false;
  const isScrollableY = target.scrollHeight > target.clientHeight;
  const onScrollbarY = isScrollableY && event.clientX > target.clientWidth;
  const isScrollableX = target.scrollWidth > target.clientWidth;
  const onScrollbarX = isScrollableX && event.clientY > target.clientHeight;
  return onScrollbarY || onScrollbarX;
}
function trackInteractOutsideImpl(node, options) {
  const { exclude, onFocusOutside, onPointerDownOutside, onInteractOutside, defer } = options;
  if (!node)
    return;
  const doc = getDocument(node);
  const win = getWindow(node);
  const frames = getWindowFrames(win);
  function isEventOutside(event) {
    const target = getEventTarget(event);
    if (!isHTMLElement(target))
      return false;
    if (contains(node, target))
      return false;
    if (isEventPointWithin(node, event))
      return false;
    if (isEventWithinScrollbar(event))
      return false;
    return !(exclude == null ? void 0 : exclude(target));
  }
  let clickHandler;
  function onPointerDown(event) {
    function handler() {
      var _a;
      const func = defer ? raf : (v) => v();
      const composedPath = ((_a = event.composedPath) == null ? void 0 : _a.call(event)) ?? [event.target];
      func(() => {
        if (!node || !isEventOutside(event))
          return;
        if (onPointerDownOutside || onInteractOutside) {
          const handler2 = callAll(onPointerDownOutside, onInteractOutside);
          node.addEventListener(POINTER_OUTSIDE_EVENT, handler2, { once: true });
        }
        fireCustomEvent(node, POINTER_OUTSIDE_EVENT, {
          bubbles: false,
          cancelable: true,
          detail: {
            originalEvent: event,
            contextmenu: isContextMenuEvent(event),
            focusable: isComposedPathFocusable(composedPath)
          }
        });
      });
    }
    if (event.pointerType === "touch") {
      frames.removeEventListener("click", handler);
      doc.removeEventListener("click", handler);
      clickHandler = handler;
      doc.addEventListener("click", handler, { once: true });
      frames.addEventListener("click", handler, { once: true });
    } else {
      handler();
    }
  }
  const cleanups2 = /* @__PURE__ */ new Set();
  const timer = setTimeout(() => {
    cleanups2.add(frames.addEventListener("pointerdown", onPointerDown, true));
    cleanups2.add(addDomEvent(doc, "pointerdown", onPointerDown, true));
  }, 0);
  function onFocusin(event) {
    const func = defer ? raf : (v) => v();
    func(() => {
      if (!node || !isEventOutside(event))
        return;
      if (onFocusOutside || onInteractOutside) {
        const handler = callAll(onFocusOutside, onInteractOutside);
        node.addEventListener(FOCUS_OUTSIDE_EVENT, handler, { once: true });
      }
      fireCustomEvent(node, FOCUS_OUTSIDE_EVENT, {
        bubbles: false,
        cancelable: true,
        detail: {
          originalEvent: event,
          contextmenu: false,
          focusable: isFocusable(getEventTarget(event))
        }
      });
    });
  }
  cleanups2.add(addDomEvent(doc, "focusin", onFocusin, true));
  cleanups2.add(frames.addEventListener("focusin", onFocusin, true));
  return () => {
    clearTimeout(timer);
    if (clickHandler) {
      frames.removeEventListener("click", clickHandler);
      doc.removeEventListener("click", clickHandler);
    }
    cleanups2.forEach((fn) => fn());
  };
}
function trackInteractOutside(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = typeof nodeOrFn === "function" ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackInteractOutsideImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/dismissable/dist/index.mjs
function trackEscapeKeydown(node, fn) {
  const handleKeyDown = (event) => {
    if (event.key !== "Escape")
      return;
    if (event.isComposing)
      return;
    fn == null ? void 0 : fn(event);
  };
  return addDomEvent(getDocument(node), "keydown", handleKeyDown, { capture: true });
}
var layerStack = {
  layers: [],
  branches: [],
  count() {
    return this.layers.length;
  },
  pointerBlockingLayers() {
    return this.layers.filter((layer) => layer.pointerBlocking);
  },
  topMostPointerBlockingLayer() {
    return [...this.pointerBlockingLayers()].slice(-1)[0];
  },
  hasPointerBlockingLayer() {
    return this.pointerBlockingLayers().length > 0;
  },
  isBelowPointerBlockingLayer(node) {
    var _a;
    const index = this.indexOf(node);
    const highestBlockingIndex = this.topMostPointerBlockingLayer() ? this.indexOf((_a = this.topMostPointerBlockingLayer()) == null ? void 0 : _a.node) : -1;
    return index < highestBlockingIndex;
  },
  isTopMost(node) {
    const layer = this.layers[this.count() - 1];
    return (layer == null ? void 0 : layer.node) === node;
  },
  getNestedLayers(node) {
    return Array.from(this.layers).slice(this.indexOf(node) + 1);
  },
  isInNestedLayer(node, target) {
    return this.getNestedLayers(node).some((layer) => contains(layer.node, target));
  },
  isInBranch(target) {
    return Array.from(this.branches).some((branch) => contains(branch, target));
  },
  add(layer) {
    const num = this.layers.push(layer);
    layer.node.style.setProperty("--layer-index", `${num}`);
  },
  addBranch(node) {
    this.branches.push(node);
  },
  remove(node) {
    const index = this.indexOf(node);
    if (index < 0)
      return;
    if (index < this.count() - 1) {
      const _layers = this.getNestedLayers(node);
      _layers.forEach((layer) => layer.dismiss());
    }
    this.layers.splice(index, 1);
    node.style.removeProperty("--layer-index");
  },
  removeBranch(node) {
    const index = this.branches.indexOf(node);
    if (index >= 0)
      this.branches.splice(index, 1);
  },
  indexOf(node) {
    return this.layers.findIndex((layer) => layer.node === node);
  },
  dismiss(node) {
    var _a;
    (_a = this.layers[this.indexOf(node)]) == null ? void 0 : _a.dismiss();
  },
  clear() {
    this.remove(this.layers[0].node);
  }
};
var originalBodyPointerEvents;
function assignPointerEventToLayers() {
  layerStack.layers.forEach(({ node }) => {
    node.style.pointerEvents = layerStack.isBelowPointerBlockingLayer(node) ? "none" : "auto";
  });
}
function clearPointerEvent(node) {
  node.style.pointerEvents = "";
}
function disablePointerEventsOutside(node, peristentElements) {
  const doc = getDocument(node);
  const cleanups2 = [];
  if (layerStack.hasPointerBlockingLayer() && !doc.body.hasAttribute("data-inert")) {
    originalBodyPointerEvents = document.body.style.pointerEvents;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = "none";
      doc.body.setAttribute("data-inert", "");
    });
  }
  if (peristentElements) {
    const persistedCleanup = waitForElements(peristentElements, (el) => {
      cleanups2.push(setStyle(el, { pointerEvents: "auto" }));
    });
    cleanups2.push(persistedCleanup);
  }
  return () => {
    if (layerStack.hasPointerBlockingLayer())
      return;
    queueMicrotask(() => {
      doc.body.style.pointerEvents = originalBodyPointerEvents;
      doc.body.removeAttribute("data-inert");
      if (doc.body.style.length === 0)
        doc.body.removeAttribute("style");
    });
    cleanups2.forEach((fn) => fn());
  };
}
function trackDismissableElementImpl(node, options) {
  if (!node) {
    warn("[@zag-js/dismissable] node is `null` or `undefined`");
    return;
  }
  const { onDismiss, pointerBlocking, exclude: excludeContainers, debug } = options;
  const layer = { dismiss: onDismiss, node, pointerBlocking };
  layerStack.add(layer);
  assignPointerEventToLayers();
  function onPointerDownOutside(event) {
    var _a, _b;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isBelowPointerBlockingLayer(node) || layerStack.isInBranch(target))
      return;
    (_a = options.onPointerDownOutside) == null ? void 0 : _a.call(options, event);
    (_b = options.onInteractOutside) == null ? void 0 : _b.call(options, event);
    if (event.defaultPrevented)
      return;
    if (debug) {
      console.log("onPointerDownOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onFocusOutside(event) {
    var _a, _b;
    const target = getEventTarget(event.detail.originalEvent);
    if (layerStack.isInBranch(target))
      return;
    (_a = options.onFocusOutside) == null ? void 0 : _a.call(options, event);
    (_b = options.onInteractOutside) == null ? void 0 : _b.call(options, event);
    if (event.defaultPrevented)
      return;
    if (debug) {
      console.log("onFocusOutside:", event.detail.originalEvent);
    }
    onDismiss == null ? void 0 : onDismiss();
  }
  function onEscapeKeyDown(event) {
    var _a;
    if (!layerStack.isTopMost(node))
      return;
    (_a = options.onEscapeKeyDown) == null ? void 0 : _a.call(options, event);
    if (!event.defaultPrevented && onDismiss) {
      event.preventDefault();
      onDismiss();
    }
  }
  function exclude(target) {
    var _a;
    if (!node)
      return false;
    const containers = typeof excludeContainers === "function" ? excludeContainers() : excludeContainers;
    const _containers = Array.isArray(containers) ? containers : [containers];
    const persistentElements = (_a = options.persistentElements) == null ? void 0 : _a.map((fn) => fn()).filter(isHTMLElement);
    if (persistentElements)
      _containers.push(...persistentElements);
    return _containers.some((node2) => contains(node2, target)) || layerStack.isInNestedLayer(node, target);
  }
  const cleanups2 = [
    pointerBlocking ? disablePointerEventsOutside(node, options.persistentElements) : void 0,
    trackEscapeKeydown(node, onEscapeKeyDown),
    trackInteractOutside(node, { exclude, onFocusOutside, onPointerDownOutside, defer: options.defer })
  ];
  return () => {
    layerStack.remove(node);
    assignPointerEventToLayers();
    clearPointerEvent(node);
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableElement(nodeOrFn, options) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      cleanups2.push(trackDismissableElementImpl(node, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}
function trackDismissableBranch(nodeOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const node = isFunction(nodeOrFn) ? nodeOrFn() : nodeOrFn;
      if (!node) {
        warn("[@zag-js/dismissable] branch node is `null` or `undefined`");
        return;
      }
      layerStack.addBranch(node);
      cleanups2.push(() => {
        layerStack.removeBranch(node);
      });
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/color-picker/dist/index.mjs
var anatomy9 = createAnatomy("color-picker", [
  "root",
  "label",
  "control",
  "trigger",
  "positioner",
  "content",
  "area",
  "areaThumb",
  "areaBackground",
  "channelSlider",
  "channelSliderTrack",
  "channelSliderThumb",
  "channelInput",
  "transparencyGrid",
  "swatchGroup",
  "swatchTrigger",
  "swatchIndicator",
  "swatch",
  "eyeDropperTrigger",
  "formatTrigger",
  "formatSelect"
]);
var parts7 = anatomy9.build();
var dom7 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `color-picker:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `color-picker:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => `color-picker:${ctx.id}:hidden-input`,
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `color-picker:${ctx.id}:control`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `color-picker:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `color-picker:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => `color-picker:${ctx.id}:positioner`,
  getFormatSelectId: (ctx) => `color-picker:${ctx.id}:format-select`,
  getAreaId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.area) ?? `color-picker:${ctx.id}:area`;
  },
  getAreaGradientId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.areaGradient) ?? `color-picker:${ctx.id}:area-gradient`;
  },
  getAreaThumbId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.areaThumb) ?? `color-picker:${ctx.id}:area-thumb`;
  },
  getChannelSliderId: (ctx, channel) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.channelSliderTrack) == null ? void 0 : _b.call(_a, channel)) ?? `color-picker:${ctx.id}:slider-track:${channel}`;
  },
  getChannelSliderThumbId: (ctx, channel) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.channelSliderThumb) == null ? void 0 : _b.call(_a, channel)) ?? `color-picker:${ctx.id}:slider-thumb:${channel}`;
  },
  getContentEl: (ctx) => dom7.getById(ctx, dom7.getContentId(ctx)),
  getAreaThumbEl: (ctx) => dom7.getById(ctx, dom7.getAreaThumbId(ctx)),
  getChannelSliderThumbEl: (ctx, channel) => dom7.getById(ctx, dom7.getChannelSliderThumbId(ctx, channel)),
  getChannelInputEl: (ctx, channel) => {
    return [
      ...queryAll(dom7.getContentEl(ctx), `input[data-channel="${channel}"]`),
      ...queryAll(dom7.getControlEl(ctx), `input[data-channel="${channel}"]`)
    ];
  },
  getFormatSelectEl: (ctx) => dom7.getById(ctx, dom7.getFormatSelectId(ctx)),
  getHiddenInputEl: (ctx) => dom7.getById(ctx, dom7.getHiddenInputId(ctx)),
  getAreaEl: (ctx) => dom7.getById(ctx, dom7.getAreaId(ctx)),
  getAreaValueFromPoint(ctx, point) {
    const areaEl = dom7.getAreaEl(ctx);
    if (!areaEl)
      return;
    const { percent } = getRelativePoint(point, areaEl);
    return percent;
  },
  getControlEl: (ctx) => dom7.getById(ctx, dom7.getControlId(ctx)),
  getTriggerEl: (ctx) => dom7.getById(ctx, dom7.getTriggerId(ctx)),
  getPositionerEl: (ctx) => dom7.getById(ctx, dom7.getPositionerId(ctx)),
  getChannelSliderTrackEl: (ctx, channel) => {
    return dom7.getById(ctx, dom7.getChannelSliderId(ctx, channel));
  },
  getChannelSliderValueFromPoint(ctx, point, channel) {
    const trackEl = dom7.getChannelSliderTrackEl(ctx, channel);
    if (!trackEl)
      return;
    const { percent } = getRelativePoint(point, trackEl);
    return percent;
  },
  getChannelInputEls: (ctx) => {
    return [
      ...queryAll(dom7.getContentEl(ctx), "input[data-channel]"),
      ...queryAll(dom7.getControlEl(ctx), "input[data-channel]")
    ];
  }
});
function getChannelDisplayColor(color, channel) {
  switch (channel) {
    case "hue":
      return parseColor(`hsl(${color.getChannelValue("hue")}, 100%, 50%)`);
    case "lightness":
    case "brightness":
    case "saturation":
    case "red":
    case "green":
    case "blue":
      return color.withChannelValue("alpha", 1);
    case "alpha": {
      return color;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
}
function getChannelValue(color, channel) {
  if (channel == null)
    return "";
  if (channel === "hex") {
    return color.toString("hex");
  }
  if (channel === "css") {
    return color.toString("css");
  }
  if (channel in color) {
    return color.getChannelValue(channel).toString();
  }
  const isHSL = color.getFormat() === "hsla";
  switch (channel) {
    case "hue":
      return isHSL ? color.toFormat("hsla").getChannelValue("hue").toString() : color.toFormat("hsba").getChannelValue("hue").toString();
    case "saturation":
      return isHSL ? color.toFormat("hsla").getChannelValue("saturation").toString() : color.toFormat("hsba").getChannelValue("saturation").toString();
    case "lightness":
      return color.toFormat("hsla").getChannelValue("lightness").toString();
    case "brightness":
      return color.toFormat("hsba").getChannelValue("brightness").toString();
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelValue(channel).toString();
    default:
      return color.getChannelValue(channel).toString();
  }
}
function getChannelRange(color, channel) {
  switch (channel) {
    case "hex":
      const minColor = parseColor("#000000");
      const maxColor = parseColor("#FFFFFF");
      return {
        minValue: minColor.toHexInt(),
        maxValue: maxColor.toHexInt(),
        pageSize: 10,
        step: 1
      };
    case "css":
      return void 0;
    case "hue":
    case "saturation":
    case "lightness":
      return color.toFormat("hsla").getChannelRange(channel);
    case "brightness":
      return color.toFormat("hsba").getChannelRange(channel);
    case "red":
    case "green":
    case "blue":
      return color.toFormat("rgba").getChannelRange(channel);
    default:
      return color.getChannelRange(channel);
  }
}
function getSliderBackgroundDirection(orientation, dir) {
  if (orientation === "vertical") {
    return "top";
  } else if (dir === "ltr") {
    return "right";
  } else {
    return "left";
  }
}
var getSliderBackground = (props29) => {
  const { channel, value, dir } = props29;
  const bgDirection = getSliderBackgroundDirection(props29.orientation, dir);
  const { minValue, maxValue } = value.getChannelRange(channel);
  switch (channel) {
    case "hue":
      return `linear-gradient(to ${bgDirection}, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)`;
    case "lightness": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let middle = value.withChannelValue(channel, (maxValue - minValue) / 2).toString("css");
      let end = value.withChannelValue(channel, maxValue).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${middle}, ${end})`;
    }
    case "saturation":
    case "brightness":
    case "red":
    case "green":
    case "blue":
    case "alpha": {
      let start = value.withChannelValue(channel, minValue).toString("css");
      let end = value.withChannelValue(channel, maxValue).toString("css");
      return `linear-gradient(to ${bgDirection}, ${start}, ${end})`;
    }
    default:
      throw new Error("Unknown color channel: " + channel);
  }
};
function connect7(state2, send, normalize) {
  const value = state2.context.value;
  const areaValue = state2.context.areaValue;
  const valueAsString = state2.context.valueAsString;
  const disabled = state2.context.isDisabled;
  const interactive = state2.context.isInteractive;
  const dragging = state2.hasTag("dragging");
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const getAreaChannels = (props29) => {
    const channels = areaValue.getChannels();
    return {
      xChannel: props29.xChannel ?? channels[1],
      yChannel: props29.yChannel ?? channels[2]
    };
  };
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  function getSwatchTriggerState(props29) {
    const color = normalizeColor(props29.value).toFormat(state2.context.format);
    return {
      value: color,
      valueAsString: color.toString("hex"),
      checked: color.isEqual(value),
      disabled: props29.disabled || !interactive
    };
  }
  return {
    dragging,
    open,
    valueAsString,
    value,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send({ type: nextOpen ? "OPEN" : "CLOSE" });
    },
    setValue(value2) {
      send({ type: "VALUE.SET", value: normalizeColor(value2), src: "set-color" });
    },
    getChannelValue(channel) {
      return getChannelValue(value, channel);
    },
    setChannelValue(channel, channelValue) {
      const color = value.withChannelValue(channel, channelValue);
      send({ type: "VALUE.SET", value: color, src: "set-channel" });
    },
    format: state2.context.format,
    setFormat(format) {
      const formatValue2 = value.toFormat(format);
      send({ type: "VALUE.SET", value: formatValue2, src: "set-format" });
    },
    alpha: value.getChannelValue("alpha"),
    setAlpha(alphaValue) {
      const color = value.withChannelValue("alpha", alphaValue);
      send({ type: "VALUE.SET", value: color, src: "set-alpha" });
    },
    getRootProps() {
      return normalize.element({
        ...parts7.root.attrs,
        dir: state2.context.dir,
        id: dom7.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        style: {
          "--value": value.toString("css")
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts7.label.attrs,
        dir: state2.context.dir,
        id: dom7.getLabelId(state2.context),
        htmlFor: dom7.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-focus": dataAttr(focused),
        onClick(event) {
          event.preventDefault();
          const inputEl = query(dom7.getControlEl(state2.context), "[data-channel=hex]");
          inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts7.control.attrs,
        id: dom7.getControlId(state2.context),
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused)
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts7.trigger.attrs,
        id: dom7.getTriggerId(state2.context),
        dir: state2.context.dir,
        disabled,
        "aria-label": `select color. current color is ${valueAsString}`,
        "aria-controls": dom7.getContentId(state2.context),
        "aria-labelledby": dom7.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "data-placement": currentPlacement,
        "aria-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        type: "button",
        onClick() {
          if (!interactive)
            return;
          send({ type: "TRIGGER.CLICK" });
        },
        onBlur() {
          if (!interactive)
            return;
          send({ type: "TRIGGER.BLUR" });
        },
        style: {
          position: "relative"
        }
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts7.positioner.attrs,
        id: dom7.getPositionerId(state2.context),
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts7.content.attrs,
        id: dom7.getContentId(state2.context),
        dir: state2.context.dir,
        "data-placement": currentPlacement,
        "data-state": open ? "open" : "closed",
        hidden: !open
      });
    },
    getAreaProps(props29 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props29);
      const { areaStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize.element({
        ...parts7.area.attrs,
        id: dom7.getAreaId(state2.context),
        role: "group",
        onPointerDown(event) {
          if (!interactive)
            return;
          if (!isLeftClick(event))
            return;
          if (isModifierKey(event))
            return;
          const point = getEventPoint(event);
          const channel = { xChannel, yChannel };
          send({ type: "AREA.POINTER_DOWN", point, channel, id: "area" });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaStyles
        }
      });
    },
    getAreaBackgroundProps(props29 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props29);
      const { areaGradientStyles } = getColorAreaGradient(areaValue, {
        xChannel,
        yChannel,
        dir: state2.context.dir
      });
      return normalize.element({
        ...parts7.areaBackground.attrs,
        id: dom7.getAreaGradientId(state2.context),
        style: {
          position: "relative",
          touchAction: "none",
          forcedColorAdjust: "none",
          ...areaGradientStyles
        }
      });
    },
    getAreaThumbProps(props29 = {}) {
      const { xChannel, yChannel } = getAreaChannels(props29);
      const channel = { xChannel, yChannel };
      const xPercent = areaValue.getChannelValuePercent(xChannel);
      const yPercent = 1 - areaValue.getChannelValuePercent(yChannel);
      const xValue = areaValue.getChannelValue(xChannel);
      const yValue = areaValue.getChannelValue(yChannel);
      return normalize.element({
        ...parts7.areaThumb.attrs,
        id: dom7.getAreaThumbId(state2.context),
        dir: state2.context.dir,
        tabIndex: disabled ? void 0 : 0,
        "data-disabled": dataAttr(disabled),
        role: "slider",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": xValue,
        "aria-label": `${xChannel} and ${yChannel}`,
        "aria-roledescription": "2d slider",
        "aria-valuetext": `${xChannel} ${xValue}, ${yChannel} ${yValue}`,
        style: {
          position: "absolute",
          left: `${xPercent * 100}%`,
          top: `${yPercent * 100}%`,
          transform: "translate(-50%, -50%)",
          touchAction: "none",
          forcedColorAdjust: "none",
          background: areaValue.withChannelValue("alpha", 1).toString("css")
        },
        onFocus() {
          if (!interactive)
            return;
          send({ type: "AREA.FOCUS", id: "area", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          const step = getEventStep(event);
          const keyMap2 = {
            ArrowUp() {
              send({ type: "AREA.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "AREA.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "AREA.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "AREA.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "AREA.PAGE_UP", channel, step });
            },
            PageDown() {
              send({ type: "AREA.PAGE_DOWN", channel, step });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getTransparencyGridProps(props29 = {}) {
      const { size: size3 = "12px" } = props29;
      return normalize.element({
        ...parts7.transparencyGrid.attrs,
        style: {
          "--size": size3,
          width: "100%",
          height: "100%",
          position: "absolute",
          backgroundColor: "#fff",
          backgroundImage: "conic-gradient(#eeeeee 0 25%, transparent 0 50%, #eeeeee 0 75%, transparent 0)",
          backgroundSize: "var(--size) var(--size)",
          inset: "0px",
          zIndex: "auto",
          pointerEvents: "none"
        }
      });
    },
    getChannelSliderProps(props29) {
      const { orientation = "horizontal", channel } = props29;
      return normalize.element({
        ...parts7.channelSlider.attrs,
        "data-channel": channel,
        "data-orientation": orientation,
        role: "presentation",
        onPointerDown(event) {
          if (!interactive)
            return;
          if (!isLeftClick(event))
            return;
          if (isModifierKey(event))
            return;
          const point = getEventPoint(event);
          send({ type: "CHANNEL_SLIDER.POINTER_DOWN", channel, point, id: channel, orientation });
          event.preventDefault();
        },
        style: {
          position: "relative",
          touchAction: "none"
        }
      });
    },
    getChannelSliderTrackProps(props29) {
      const { orientation = "horizontal", channel } = props29;
      return normalize.element({
        ...parts7.channelSliderTrack.attrs,
        id: dom7.getChannelSliderId(state2.context, channel),
        role: "group",
        "data-channel": channel,
        "data-orientation": orientation,
        style: {
          position: "relative",
          forcedColorAdjust: "none",
          backgroundImage: getSliderBackground({
            orientation,
            channel,
            dir: state2.context.dir,
            value: areaValue
          })
        }
      });
    },
    getChannelSliderThumbProps(props29) {
      const { orientation = "horizontal", channel } = props29;
      const { minValue, maxValue, step: stepValue } = areaValue.getChannelRange(channel);
      const channelValue = areaValue.getChannelValue(channel);
      const offset3 = (channelValue - minValue) / (maxValue - minValue);
      const placementStyles = orientation === "horizontal" ? { left: `${offset3 * 100}%`, top: "50%" } : { top: `${offset3 * 100}%`, left: "50%" };
      return normalize.element({
        ...parts7.channelSliderThumb.attrs,
        id: dom7.getChannelSliderThumbId(state2.context, channel),
        role: "slider",
        "aria-label": channel,
        tabIndex: disabled ? void 0 : 0,
        "data-channel": channel,
        "data-disabled": dataAttr(disabled),
        "data-orientation": orientation,
        "aria-disabled": dataAttr(disabled),
        "aria-orientation": orientation,
        "aria-valuemax": maxValue,
        "aria-valuemin": minValue,
        "aria-valuenow": channelValue,
        "aria-valuetext": `${channel} ${channelValue}`,
        style: {
          forcedColorAdjust: "none",
          position: "absolute",
          background: getChannelDisplayColor(areaValue, channel).toString("css"),
          ...placementStyles
        },
        onFocus() {
          if (!interactive)
            return;
          send({ type: "CHANNEL_SLIDER.FOCUS", channel });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          const step = getEventStep(event) * stepValue;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CHANNEL_SLIDER.ARROW_UP", channel, step });
            },
            ArrowDown() {
              send({ type: "CHANNEL_SLIDER.ARROW_DOWN", channel, step });
            },
            ArrowLeft() {
              send({ type: "CHANNEL_SLIDER.ARROW_LEFT", channel, step });
            },
            ArrowRight() {
              send({ type: "CHANNEL_SLIDER.ARROW_RIGHT", channel, step });
            },
            PageUp() {
              send({ type: "CHANNEL_SLIDER.PAGE_UP", channel });
            },
            PageDown() {
              send({ type: "CHANNEL_SLIDER.PAGE_DOWN", channel });
            },
            Home() {
              send({ type: "CHANNEL_SLIDER.HOME", channel });
            },
            End() {
              send({ type: "CHANNEL_SLIDER.END", channel });
            },
            Escape(event2) {
              event2.stopPropagation();
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getChannelInputProps(props29) {
      const { channel } = props29;
      const isTextField = channel === "hex" || channel === "css";
      const range2 = getChannelRange(value, channel);
      return normalize.input({
        ...parts7.channelInput.attrs,
        dir: state2.context.dir,
        type: isTextField ? "text" : "number",
        "data-channel": channel,
        "aria-label": channel,
        spellCheck: false,
        autoComplete: "off",
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly: state2.context.readOnly,
        defaultValue: getChannelValue(value, channel),
        min: range2 == null ? void 0 : range2.minValue,
        max: range2 == null ? void 0 : range2.maxValue,
        step: range2 == null ? void 0 : range2.step,
        onBeforeInput(event) {
          if (isTextField || !interactive)
            return;
          const value2 = event.currentTarget.value;
          if (value2.match(/[^0-9.]/g)) {
            event.preventDefault();
          }
        },
        onFocus(event) {
          if (!interactive)
            return;
          send({ type: "CHANNEL_INPUT.FOCUS", channel });
          event.target.select();
        },
        onBlur(event) {
          if (!interactive)
            return;
          const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
          send({ type: "CHANNEL_INPUT.BLUR", channel, value: value2, isTextField });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          if (event.key === "Enter") {
            const value2 = isTextField ? event.currentTarget.value : event.currentTarget.valueAsNumber;
            send({ type: "CHANNEL_INPUT.CHANGE", channel, value: value2, isTextField });
            event.preventDefault();
          }
        },
        style: {
          appearance: "none",
          WebkitAppearance: "none",
          MozAppearance: "textfield"
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        type: "text",
        disabled,
        name: state2.context.name,
        id: dom7.getHiddenInputId(state2.context),
        style: visuallyHiddenStyle,
        defaultValue: valueAsString
      });
    },
    getEyeDropperTriggerProps() {
      return normalize.button({
        ...parts7.eyeDropperTrigger.attrs,
        type: "button",
        dir: state2.context.dir,
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": "Pick a color from the screen",
        onClick() {
          if (!interactive)
            return;
          send("EYEDROPPER.CLICK");
        }
      });
    },
    getSwatchGroupProps() {
      return normalize.element({
        ...parts7.swatchGroup.attrs,
        role: "group"
      });
    },
    getSwatchTriggerState,
    getSwatchTriggerProps(props29) {
      const swatchState = getSwatchTriggerState(props29);
      return normalize.button({
        ...parts7.swatchTrigger.attrs,
        disabled: swatchState.disabled,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `select ${swatchState.valueAsString} as the color`,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        "data-disabled": dataAttr(swatchState.disabled),
        onClick() {
          if (swatchState.disabled)
            return;
          send({ type: "SWATCH_TRIGGER.CLICK", value: swatchState.value });
        },
        style: {
          position: "relative"
        }
      });
    },
    getSwatchIndicatorProps(props29) {
      const swatchState = getSwatchTriggerState(props29);
      return normalize.element({
        ...parts7.swatchIndicator.attrs,
        dir: state2.context.dir,
        hidden: !swatchState.checked
      });
    },
    getSwatchProps(props29) {
      const { respectAlpha = true } = props29;
      const swatchState = getSwatchTriggerState(props29);
      return normalize.element({
        ...parts7.swatch.attrs,
        dir: state2.context.dir,
        "data-state": swatchState.checked ? "checked" : "unchecked",
        "data-value": swatchState.valueAsString,
        style: {
          position: "relative",
          background: swatchState.value.toString(respectAlpha ? "css" : "hex")
        }
      });
    },
    getFormatTriggerProps() {
      return normalize.button({
        ...parts7.formatTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "aria-label": `change color format to ${getNextFormat(state2.context.format)}`,
        onClick(event) {
          if (event.currentTarget.disabled)
            return;
          const nextFormat = getNextFormat(state2.context.format);
          send({ type: "FORMAT.SET", format: nextFormat, src: "format-trigger" });
        }
      });
    },
    getFormatSelectProps() {
      return normalize.select({
        ...parts7.formatSelect.attrs,
        "aria-label": "change color format",
        dir: state2.context.dir,
        defaultValue: state2.context.format,
        disabled,
        onChange(event) {
          const format = assertFormat(event.currentTarget.value);
          send({ type: "FORMAT.SET", format, src: "format-select" });
        }
      });
    }
  };
}
var formats = ["hsba", "hsla", "rgba"];
var formatRegex = new RegExp(`^(${formats.join("|")})$`);
function getNextFormat(format) {
  const index = formats.indexOf(format);
  return formats[index + 1] ?? formats[0];
}
function assertFormat(format) {
  if (formatRegex.test(format))
    return format;
  throw new Error(`Unsupported color format: ${format}`);
}
var parse = (colorString) => {
  return parseColor(colorString);
};
var { and: and3 } = guards;
function machine7(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "color-picker",
      initial: ctx.open ? "open" : "idle",
      context: {
        dir: "ltr",
        value: parse("#000000"),
        format: "rgba",
        disabled: false,
        closeOnSelect: false,
        ...ctx,
        activeId: null,
        activeChannel: null,
        activeOrientation: null,
        fieldsetDisabled: false,
        restoreFocus: true,
        positioning: {
          ...ctx.positioning,
          placement: "bottom"
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        valueAsString: (ctx2) => ctx2.value.toString(ctx2.format),
        areaValue: (ctx2) => {
          const format = ctx2.format.startsWith("hsl") ? "hsla" : "hsba";
          return ctx2.value.toFormat(format);
        }
      },
      activities: ["trackFormControl"],
      watch: {
        value: ["syncInputElements"],
        format: ["syncFormatSelectElement"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "FORMAT.SET": {
          actions: ["setFormat"]
        },
        "CHANNEL_INPUT.CHANGE": {
          actions: ["setChannelColorFromInput"]
        },
        "EYEDROPPER.CLICK": {
          actions: ["openEyeDropper"]
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              target: "focused",
              actions: ["setActiveChannel"]
            }
          }
        },
        focused: {
          tags: ["closed", "focused"],
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            "CHANNEL_INPUT.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_INPUT.BLUR": {
              target: "idle",
              actions: ["setChannelColorFromInput"]
            },
            "TRIGGER.BLUR": {
              target: "idle"
            }
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "AREA.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "CHANNEL_SLIDER.POINTER_DOWN": {
              target: "open:dragging",
              actions: ["setActiveChannel", "setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.FOCUS": {
              actions: ["setActiveChannel"]
            },
            "AREA.ARROW_LEFT": {
              actions: ["decrementXChannel"]
            },
            "AREA.ARROW_RIGHT": {
              actions: ["incrementXChannel"]
            },
            "AREA.ARROW_UP": {
              actions: ["incrementYChannel"]
            },
            "AREA.ARROW_DOWN": {
              actions: ["decrementYChannel"]
            },
            "AREA.PAGE_UP": {
              actions: ["incrementXChannel"]
            },
            "AREA.PAGE_DOWN": {
              actions: ["decrementXChannel"]
            },
            "CHANNEL_SLIDER.ARROW_LEFT": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_RIGHT": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.ARROW_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_UP": {
              actions: ["incrementChannel"]
            },
            "CHANNEL_SLIDER.PAGE_DOWN": {
              actions: ["decrementChannel"]
            },
            "CHANNEL_SLIDER.HOME": {
              actions: ["setChannelToMin"]
            },
            "CHANNEL_SLIDER.END": {
              actions: ["setChannelToMax"]
            },
            "CHANNEL_INPUT.BLUR": {
              actions: ["setChannelColorFromInput"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "SWATCH_TRIGGER.CLICK": [
              {
                guard: and3("isOpenControlled", "closeOnSelect"),
                actions: ["setValue", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setValue", "invokeOnClose", "setReturnFocus"]
              },
              {
                actions: ["setValue"]
              }
            ]
          }
        },
        "open:dragging": {
          tags: ["open"],
          exit: ["clearActiveChannel"],
          activities: ["trackPointerMove", "disableTextSelection", "trackPositioning", "trackDismissableElement"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setReturnFocus"]
              },
              {
                target: "idle"
              }
            ],
            "AREA.POINTER_MOVE": {
              actions: ["setAreaColorFromPoint", "focusAreaThumb"]
            },
            "AREA.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            "CHANNEL_SLIDER.POINTER_MOVE": {
              actions: ["setChannelColorFromPoint", "focusChannelThumb"]
            },
            "CHANNEL_SLIDER.POINTER_UP": {
              target: "open",
              actions: ["invokeOnChangeEnd"]
            },
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "setReturnFocus"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom7.getTriggerEl(ctx2);
          const getPositionerEl = () => dom7.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom7.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            exclude: dom7.getTriggerEl(ctx2),
            defer: true,
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              if (event.defaultPrevented)
                return;
              ctx2.restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            }
          });
        },
        trackFormControl(ctx2, _evt, { send, initialContext }) {
          const inputEl = dom7.getHiddenInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "VALUE.SET", value: initialContext.value, src: "form.reset" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom7.getDoc(ctx2), {
            onPointerMove({ point }) {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_MOVE" : "CHANNEL_SLIDER.POINTER_MOVE";
              send({ type, point });
            },
            onPointerUp() {
              const type = ctx2.activeId === "area" ? "AREA.POINTER_UP" : "CHANNEL_SLIDER.POINTER_UP";
              send({ type });
            }
          });
        },
        disableTextSelection(ctx2) {
          return disableTextSelection({ doc: dom7.getDoc(ctx2), target: dom7.getContentEl(ctx2) });
        }
      },
      actions: {
        openEyeDropper(ctx2) {
          const isSupported = "EyeDropper" in dom7.getWin(ctx2);
          if (!isSupported)
            return;
          const win = dom7.getWin(ctx2);
          const picker = new win.EyeDropper();
          picker.open().then(({ sRGBHex }) => {
            var _a;
            const format = ctx2.value.getFormat();
            const color = parseColor(sRGBHex).toFormat(format);
            set6.value(ctx2, color);
            (_a = ctx2.onValueChangeEnd) == null ? void 0 : _a.call(ctx2, { value: ctx2.value, valueAsString: ctx2.valueAsString });
          }).catch(() => void 0);
        },
        setActiveChannel(ctx2, evt) {
          ctx2.activeId = evt.id;
          if (evt.channel)
            ctx2.activeChannel = evt.channel;
          if (evt.orientation)
            ctx2.activeOrientation = evt.orientation;
        },
        clearActiveChannel(ctx2) {
          ctx2.activeChannel = null;
          ctx2.activeId = null;
          ctx2.activeOrientation = null;
        },
        setAreaColorFromPoint(ctx2, evt) {
          const { xChannel, yChannel } = evt.channel || ctx2.activeChannel;
          const percent = dom7.getAreaValueFromPoint(ctx2, evt.point);
          if (!percent)
            return;
          const xValue = ctx2.areaValue.getChannelPercentValue(xChannel, percent.x);
          const yValue = ctx2.areaValue.getChannelPercentValue(yChannel, 1 - percent.y);
          const color = ctx2.areaValue.withChannelValue(xChannel, xValue).withChannelValue(yChannel, yValue);
          set6.value(ctx2, color);
        },
        setChannelColorFromPoint(ctx2, evt) {
          const channel = evt.channel || ctx2.activeId;
          const percent = dom7.getChannelSliderValueFromPoint(ctx2, evt.point, channel);
          if (!percent)
            return;
          const orientation = ctx2.activeOrientation || "horizontal";
          const channelPercent = orientation === "horizontal" ? percent.x : percent.y;
          const value = ctx2.areaValue.getChannelPercentValue(channel, channelPercent);
          const color = ctx2.areaValue.withChannelValue(channel, value);
          set6.value(ctx2, color);
        },
        setValue(ctx2, evt) {
          set6.value(ctx2, evt.value);
        },
        setFormat(ctx2, evt) {
          set6.format(ctx2, evt.format);
        },
        syncInputElements(ctx2) {
          sync.inputs(ctx2);
        },
        invokeOnChangeEnd(ctx2) {
          invoke4.changeEnd(ctx2);
        },
        setChannelColorFromInput(ctx2, evt) {
          const { channel, isTextField, value } = evt;
          const currentAlpha = ctx2.value.getChannelValue("alpha");
          let color;
          if (channel === "alpha") {
            let valueAsNumber = parseFloat(value);
            valueAsNumber = Number.isNaN(valueAsNumber) ? currentAlpha : valueAsNumber;
            color = ctx2.value.withChannelValue("alpha", valueAsNumber);
          } else if (isTextField) {
            color = tryCatch(
              () => parse(value).withChannelValue("alpha", currentAlpha),
              () => ctx2.value
            );
          } else {
            const current = ctx2.value.toFormat(ctx2.format);
            const valueAsNumber = Number.isNaN(value) ? current.getChannelValue(channel) : value;
            color = current.withChannelValue(channel, valueAsNumber);
          }
          sync.inputs(ctx2, color);
          set6.value(ctx2, color);
        },
        incrementChannel(ctx2, evt) {
          const color = ctx2.value.incrementChannel(evt.channel, evt.step);
          set6.value(ctx2, color);
        },
        decrementChannel(ctx2, evt) {
          const color = ctx2.value.decrementChannel(evt.channel, evt.step);
          set6.value(ctx2, color);
        },
        incrementXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(xChannel, evt.step);
          set6.value(ctx2, color);
        },
        decrementXChannel(ctx2, evt) {
          const { xChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(xChannel, evt.step);
          set6.value(ctx2, color);
        },
        incrementYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.incrementChannel(yChannel, evt.step);
          set6.value(ctx2, color);
        },
        decrementYChannel(ctx2, evt) {
          const { yChannel } = evt.channel;
          const color = ctx2.areaValue.decrementChannel(yChannel, evt.step);
          set6.value(ctx2, color);
        },
        setChannelToMax(ctx2, evt) {
          const range2 = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range2.maxValue);
          set6.value(ctx2, color);
        },
        setChannelToMin(ctx2, evt) {
          const range2 = ctx2.value.getChannelRange(evt.channel);
          const color = ctx2.value.withChannelValue(evt.channel, range2.minValue);
          set6.value(ctx2, color);
        },
        focusAreaThumb(ctx2) {
          raf(() => {
            var _a;
            (_a = dom7.getAreaThumbEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        focusChannelThumb(ctx2, evt) {
          raf(() => {
            var _a;
            (_a = dom7.getChannelSliderThumbEl(ctx2, evt.channel)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        setInitialFocus(ctx2) {
          raf(() => {
            const element = getInitialFocus({
              root: dom7.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setReturnFocus(ctx2) {
          raf(() => {
            var _a;
            (_a = dom7.getTriggerEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        syncFormatSelectElement(ctx2) {
          sync.formatSelect(ctx2);
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        value: (a2, b2) => a2.isEqual(b2)
      }
    }
  );
}
var sync = {
  // sync channel inputs
  inputs(ctx, color) {
    const channelInputs = dom7.getChannelInputEls(ctx);
    raf(() => {
      channelInputs.forEach((inputEl) => {
        const channel = inputEl.dataset.channel;
        dom7.setValue(inputEl, getChannelValue(color || ctx.value, channel));
      });
    });
  },
  // sync format select
  formatSelect(ctx) {
    const selectEl = dom7.getFormatSelectEl(ctx);
    raf(() => {
      dom7.setValue(selectEl, ctx.format);
    });
  }
};
var invoke4 = {
  changeEnd(ctx) {
    var _a;
    const value = ctx.value.toFormat(ctx.format);
    (_a = ctx.onValueChangeEnd) == null ? void 0 : _a.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
  },
  change(ctx) {
    var _a;
    const value = ctx.value.toFormat(ctx.format);
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value,
      valueAsString: ctx.valueAsString
    });
    dispatchInputValueEvent(dom7.getHiddenInputEl(ctx), { value: ctx.valueAsString });
  },
  formatChange(ctx) {
    var _a;
    (_a = ctx.onFormatChange) == null ? void 0 : _a.call(ctx, { format: ctx.format });
  }
};
var set6 = {
  value(ctx, color) {
    if (!color || ctx.value.isEqual(color))
      return;
    ctx.value = color;
    invoke4.change(ctx);
  },
  format(ctx, format) {
    if (ctx.format === format)
      return;
    ctx.format = format;
    invoke4.formatChange(ctx);
  }
};

// node_modules/@ark-ui/anatomy/dist/color-picker/index.js
var anatomy10 = anatomy9.extendWith("valueText", "view");

// node_modules/@zag-js/collection/dist/index.mjs
var __defProp3 = Object.defineProperty;
var __defNormalProp3 = (obj, key, value) => key in obj ? __defProp3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField3 = (obj, key, value) => __defNormalProp3(obj, typeof key !== "symbol" ? key + "" : key, value);
function hash(str) {
  let i;
  let l2;
  let hval = 2166136261;
  for (i = 0, l2 = str.length; i < l2; i++) {
    hval ^= str.charCodeAt(i);
    hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
  }
  return `00000${(hval >>> 0).toString(36)}`.slice(-6);
}
var isObject4 = (v) => typeof v === "object" && v !== null && !Array.isArray(v);
var hasKey = (obj, key) => Object.prototype.hasOwnProperty.call(obj, key);
var fallback = {
  itemToValue(item) {
    if (typeof item === "string")
      return item;
    if (isObject4(item) && hasKey(item, "value"))
      return item.value;
    return "";
  },
  itemToString(item) {
    if (typeof item === "string")
      return item;
    if (isObject4(item) && hasKey(item, "label"))
      return item.label;
    return fallback.itemToValue(item);
  },
  itemToDisabled(item) {
    if (isObject4(item) && hasKey(item, "disabled"))
      return !!item.disabled;
    return false;
  }
};
var Collection = class {
  constructor(options) {
    this.options = options;
    __publicField3(this, "nodes", /* @__PURE__ */ new Map());
    __publicField3(this, "disabledValues", /* @__PURE__ */ new Set());
    __publicField3(this, "_firstValue", null);
    __publicField3(this, "_lastValue", null);
    __publicField3(this, "hash", "");
    __publicField3(this, "isEqual", (other) => {
      return this.hash === other.hash;
    });
    __publicField3(this, "iterate", () => {
      const { items } = this.options;
      const hashSet = /* @__PURE__ */ new Set();
      for (let i = 0; i < items.length; i++) {
        const item = items[i];
        const value = this.itemToValue(item);
        const label = this.itemToString(item);
        const disabled = this.itemToDisabled(item);
        hashSet.add(JSON.stringify({ value, label, disabled }));
        const node = {
          // freeze item to prevent mutation by frameworks like Solid.js
          item: Object.freeze(item),
          index: i,
          label,
          value,
          previousValue: this.itemToValue(items[i - 1]) ?? null,
          nextValue: this.itemToValue(items[i + 1]) ?? null
        };
        this.nodes.set(value, node);
        if (disabled) {
          this.disabledValues.add(value);
        }
        if (i === 0) {
          this._firstValue = value;
        }
        if (i === items.length - 1) {
          this._lastValue = value;
        }
      }
      this.hash = hash(Array.from(hashSet).join(""));
      return this;
    });
    __publicField3(this, "setItems", (items) => {
      this.options.items = items;
      return this.iterate();
    });
    __publicField3(this, "item", (value) => {
      var _a;
      if (value === null)
        return null;
      return ((_a = this.nodes.get(value)) == null ? void 0 : _a.item) ?? null;
    });
    __publicField3(this, "items", (values) => {
      return values.map((value) => this.item(value)).filter(Boolean);
    });
    __publicField3(this, "at", (index) => {
      for (const node of this.nodes.values()) {
        if (node.index === index) {
          return node.item;
        }
      }
      return null;
    });
    __publicField3(this, "sortFn", (valueA, valueB) => {
      const nodeA = this.nodes.get(valueA);
      const nodeB = this.nodes.get(valueB);
      return ((nodeA == null ? void 0 : nodeA.index) ?? 0) - ((nodeB == null ? void 0 : nodeB.index) ?? 0);
    });
    __publicField3(this, "sort", (values) => {
      return [...values].sort(this.sortFn);
    });
    __publicField3(this, "itemToValue", (item) => {
      var _a, _b;
      if (!item)
        return "";
      return ((_b = (_a = this.options).itemToValue) == null ? void 0 : _b.call(_a, item)) ?? fallback.itemToValue(item);
    });
    __publicField3(this, "itemToString", (item) => {
      var _a, _b;
      if (!item)
        return "";
      return ((_b = (_a = this.options).itemToString) == null ? void 0 : _b.call(_a, item)) ?? fallback.itemToString(item);
    });
    __publicField3(this, "itemToDisabled", (item) => {
      var _a, _b;
      if (!item)
        return false;
      return ((_b = (_a = this.options).isItemDisabled) == null ? void 0 : _b.call(_a, item)) ?? fallback.itemToDisabled(item);
    });
    __publicField3(this, "valueToString", (value) => {
      var _a;
      if (value == null)
        return "";
      return ((_a = this.nodes.get(value)) == null ? void 0 : _a.label) ?? "";
    });
    __publicField3(this, "itemsToString", (item, separator = ", ") => {
      return item.map((item2) => this.itemToString(item2)).filter(Boolean).join(separator);
    });
    __publicField3(this, "has", (value) => {
      if (value == null)
        return false;
      return this.nodes.has(value);
    });
    __publicField3(this, "count", () => {
      return this.nodes.size;
    });
    __publicField3(this, "first", () => {
      let firstValue = this._firstValue;
      while (firstValue != null) {
        let item = this.nodes.get(firstValue);
        if (item != null && !this.disabledValues.has(item.value)) {
          return firstValue;
        }
        firstValue = (item == null ? void 0 : item.nextValue) ?? null;
      }
      return null;
    });
    __publicField3(this, "last", () => {
      let lastValue = this._lastValue;
      while (lastValue != null) {
        let item = this.nodes.get(lastValue);
        if (item != null && !this.disabledValues.has(item.value)) {
          return lastValue;
        }
        lastValue = (item == null ? void 0 : item.previousValue) ?? null;
      }
      return null;
    });
    __publicField3(this, "next", (value) => {
      if (value == null)
        return null;
      const item = this.nodes.get(value);
      let nextValue = (item == null ? void 0 : item.nextValue) ?? null;
      while (nextValue != null) {
        let item2 = this.nodes.get(nextValue);
        if (item2 != null && !this.disabledValues.has(item2.value)) {
          return nextValue;
        }
        nextValue = (item2 == null ? void 0 : item2.nextValue) ?? null;
      }
      return null;
    });
    __publicField3(this, "prev", (value) => {
      if (value == null)
        return null;
      const item = this.nodes.get(value);
      let previousValue = (item == null ? void 0 : item.previousValue) ?? null;
      while (previousValue != null) {
        let item2 = this.nodes.get(previousValue);
        if (item2 != null && !this.disabledValues.has(item2.value)) {
          return previousValue;
        }
        previousValue = (item2 == null ? void 0 : item2.previousValue) ?? null;
      }
      return null;
    });
    __publicField3(this, "isItemDisabled", (item) => {
      return this.disabledValues.has(this.itemToValue(item));
    });
    __publicField3(this, "toArray", () => {
      return Array.from(this.nodes.values());
    });
    __publicField3(this, "indexOf", (value) => {
      var _a;
      if (value == null)
        return -1;
      return ((_a = this.nodes.get(value)) == null ? void 0 : _a.index) ?? -1;
    });
    __publicField3(this, "getByText", (text, currentValue) => {
      const index = this.indexOf(currentValue);
      let nodes = currentValue != null ? wrap2(this.toArray(), index) : this.toArray();
      const isSingleKey = text.length === 1;
      if (isSingleKey) {
        nodes = nodes.filter((node) => node.value !== currentValue);
      }
      return nodes.find((node) => match3(node.label, text));
    });
    __publicField3(this, "search", (queryString, options2) => {
      var _a;
      const { state: state2, currentValue, timeout = 350 } = options2;
      const search = state2.keysSoFar + queryString;
      const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
      const query2 = isRepeated ? search[0] : search;
      const value = ((_a = this.getByText(query2, currentValue)) == null ? void 0 : _a.value) ?? null;
      function cleanup() {
        clearTimeout(state2.timer);
        state2.timer = -1;
      }
      function update(value2) {
        state2.keysSoFar = value2;
        cleanup();
        if (value2 !== "") {
          state2.timer = +setTimeout(() => {
            update("");
            cleanup();
          }, timeout);
        }
      }
      update(search);
      return value;
    });
    __publicField3(this, "toJSON", () => {
      return {
        size: this.count(),
        first: this.first(),
        last: this.last()
      };
    });
    this.iterate();
  }
};
var match3 = (label, query2) => {
  return label.toLowerCase().startsWith(query2.toLowerCase());
};
var wrap2 = (v, idx) => {
  return v.map((_, index) => v[(Math.max(idx, 0) + index) % v.length]);
};

// node_modules/@zag-js/aria-hidden/dist/index.mjs
var refCountMap = /* @__PURE__ */ new WeakMap();
var observerStack = [];
function ariaHiddenImpl(targets, options = {}) {
  const { rootEl } = options;
  const exclude = targets.filter(Boolean);
  if (exclude.length === 0)
    return;
  const doc = exclude[0].ownerDocument || document;
  const win = doc.defaultView ?? window;
  const visibleNodes = new Set(exclude);
  const hiddenNodes = /* @__PURE__ */ new Set();
  const root = rootEl ?? doc.body;
  let walk = (root2) => {
    for (let element of root2.querySelectorAll("[data-live-announcer], [data-zag-top-layer]")) {
      visibleNodes.add(element);
    }
    let acceptNode = (node) => {
      if (visibleNodes.has(node) || hiddenNodes.has(node.parentElement) && node.parentElement.getAttribute("role") !== "row") {
        return NodeFilter.FILTER_REJECT;
      }
      for (let target of visibleNodes) {
        if (node.contains(target)) {
          return NodeFilter.FILTER_SKIP;
        }
      }
      return NodeFilter.FILTER_ACCEPT;
    };
    let walker = doc.createTreeWalker(root2, NodeFilter.SHOW_ELEMENT, { acceptNode });
    let acceptRoot = acceptNode(root2);
    if (acceptRoot === NodeFilter.FILTER_ACCEPT) {
      hide2(root2);
    }
    if (acceptRoot !== NodeFilter.FILTER_REJECT) {
      let node = walker.nextNode();
      while (node != null) {
        hide2(node);
        node = walker.nextNode();
      }
    }
  };
  let hide2 = (node) => {
    let refCount = refCountMap.get(node) ?? 0;
    if (node.getAttribute("aria-hidden") === "true" && refCount === 0) {
      return;
    }
    if (refCount === 0) {
      node.setAttribute("aria-hidden", "true");
    }
    hiddenNodes.add(node);
    refCountMap.set(node, refCount + 1);
  };
  if (observerStack.length) {
    observerStack[observerStack.length - 1].disconnect();
  }
  walk(root);
  const observer = new win.MutationObserver((changes) => {
    for (let change of changes) {
      if (change.type !== "childList" || change.addedNodes.length === 0) {
        continue;
      }
      if (![...visibleNodes, ...hiddenNodes].some((node) => node.contains(change.target))) {
        for (let node of change.removedNodes) {
          if (node instanceof win.Element) {
            visibleNodes.delete(node);
            hiddenNodes.delete(node);
          }
        }
        for (let node of change.addedNodes) {
          if ((node instanceof win.HTMLElement || node instanceof win.SVGElement) && (node.dataset.liveAnnouncer === "true" || node.dataset.zagTopLayer === "true")) {
            visibleNodes.add(node);
          } else if (node instanceof win.Element) {
            walk(node);
          }
        }
      }
    }
  });
  observer.observe(root, { childList: true, subtree: true });
  let observerWrapper = {
    observe() {
      observer.observe(root, { childList: true, subtree: true });
    },
    disconnect() {
      observer.disconnect();
    }
  };
  observerStack.push(observerWrapper);
  return () => {
    observer.disconnect();
    for (let node of hiddenNodes) {
      let count = refCountMap.get(node);
      if (count === 1) {
        node.removeAttribute("aria-hidden");
        refCountMap.delete(node);
      } else {
        refCountMap.set(node, count - 1);
      }
    }
    if (observerWrapper === observerStack[observerStack.length - 1]) {
      observerStack.pop();
      if (observerStack.length) {
        observerStack[observerStack.length - 1].observe();
      }
    } else {
      observerStack.splice(observerStack.indexOf(observerWrapper), 1);
    }
  };
}
function ariaHidden(targetsOrFn, options = {}) {
  const { defer } = options;
  const func = defer ? raf : (v) => v();
  const cleanups2 = [];
  cleanups2.push(
    func(() => {
      const targets = typeof targetsOrFn === "function" ? targetsOrFn() : targetsOrFn;
      cleanups2.push(ariaHiddenImpl(targets, options));
    })
  );
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
  };
}

// node_modules/@zag-js/combobox/dist/index.mjs
var anatomy11 = createAnatomy("combobox").parts(
  "root",
  "clearTrigger",
  "content",
  "control",
  "input",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "label",
  "list",
  "positioner",
  "trigger"
);
var parts8 = anatomy11.build();
var collection = (options) => {
  return ref(new Collection(options));
};
collection.empty = () => {
  return ref(new Collection({ items: [] }));
};
var dom8 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `combobox:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `combobox:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `combobox:${ctx.id}:control`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `combobox:${ctx.id}:input`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `combobox:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `combobox:${ctx.id}:popper`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `combobox:${ctx.id}:toggle-btn`;
  },
  getClearTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.clearTrigger) ?? `combobox:${ctx.id}:clear-btn`;
  },
  getItemGroupId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemGroup) == null ? void 0 : _b.call(_a, id)) ?? `combobox:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemGroupLabel) == null ? void 0 : _b.call(_a, id)) ?? `combobox:${ctx.id}:optgroup-label:${id}`;
  },
  getItemId: (ctx, id) => `combobox:${ctx.id}:option:${id}`,
  getContentEl: (ctx) => dom8.getById(ctx, dom8.getContentId(ctx)),
  getInputEl: (ctx) => dom8.getById(ctx, dom8.getInputId(ctx)),
  getPositionerEl: (ctx) => dom8.getById(ctx, dom8.getPositionerId(ctx)),
  getControlEl: (ctx) => dom8.getById(ctx, dom8.getControlId(ctx)),
  getTriggerEl: (ctx) => dom8.getById(ctx, dom8.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom8.getById(ctx, dom8.getClearTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => {
    const value = ctx.highlightedValue;
    if (value == null)
      return;
    return query(dom8.getContentEl(ctx), `[role=option][data-value="${CSS.escape(value)}"`);
  },
  focusInputEl: (ctx) => {
    const inputEl = dom8.getInputEl(ctx);
    if (dom8.getActiveElement(ctx) === inputEl)
      return;
    inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
  },
  focusTriggerEl: (ctx) => {
    const triggerEl = dom8.getTriggerEl(ctx);
    if (dom8.getActiveElement(ctx) === triggerEl)
      return;
    triggerEl == null ? void 0 : triggerEl.focus({ preventScroll: true });
  }
});
function connect8(state2, send, normalize) {
  const translations = state2.context.translations;
  const collection22 = state2.context.collection;
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const open = state2.hasTag("open");
  const focused = state2.hasTag("focused");
  const composite = state2.context.composite;
  const highlightedValue = state2.context.highlightedValue;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  function getItemState(props29) {
    const { item } = props29;
    const disabled2 = collection22.isItemDisabled(item);
    const value = collection22.itemToValue(item);
    return {
      value,
      disabled: Boolean(disabled2 || disabled2),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  return {
    focused,
    open,
    inputValue: state2.context.inputValue,
    highlightedValue,
    highlightedItem: state2.context.highlightedItem,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    hasSelectedItems: state2.context.hasSelectedItems,
    selectedItems: state2.context.selectedItems,
    collection: state2.context.collection,
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    setCollection(collection3) {
      send({ type: "COLLECTION.SET", value: collection3 });
    },
    setHighlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    setInputValue(value) {
      send({ type: "INPUT_VALUE.SET", value });
    },
    clearValue(value) {
      if (value != null) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send("VALUE.CLEAR");
      }
    },
    focus() {
      var _a;
      (_a = dom8.getInputEl(state2.context)) == null ? void 0 : _a.focus();
    },
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getRootProps() {
      return normalize.element({
        ...parts8.root.attrs,
        dir: state2.context.dir,
        id: dom8.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts8.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom8.getInputId(state2.context),
        id: dom8.getLabelId(state2.context),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        onClick(event) {
          var _a;
          if (composite)
            return;
          event.preventDefault();
          (_a = dom8.getTriggerEl(state2.context)) == null ? void 0 : _a.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts8.control.attrs,
        dir: state2.context.dir,
        id: dom8.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts8.positioner.attrs,
        dir: state2.context.dir,
        id: dom8.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts8.input.attrs,
        dir: state2.context.dir,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        autoFocus: state2.context.autoFocus,
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        spellCheck: "false",
        readOnly,
        placeholder: state2.context.placeholder,
        id: dom8.getInputId(state2.context),
        type: "text",
        role: "combobox",
        defaultValue: state2.context.inputValue,
        "aria-autocomplete": state2.context.autoComplete ? "both" : "list",
        "aria-controls": dom8.getContentId(state2.context),
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-activedescendant": highlightedValue ? dom8.getItemId(state2.context, highlightedValue) : void 0,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!state2.context.openOnClick)
            return;
          if (!interactive)
            return;
          send("INPUT.CLICK");
        },
        onFocus() {
          if (disabled)
            return;
          send("INPUT.FOCUS");
        },
        onBlur() {
          if (disabled)
            return;
          send("INPUT.BLUR");
        },
        onChange(event) {
          send({ type: "INPUT.CHANGE", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          if (event.ctrlKey || event.shiftKey || isComposingEvent(event))
            return;
          const openOnKeyPress = state2.context.openOnKeyPress;
          const isModifierKey2 = event.ctrlKey || event.metaKey || event.shiftKey;
          const keypress = true;
          const keymap = {
            ArrowDown(event2) {
              if (!openOnKeyPress && !open)
                return;
              send({ type: event2.altKey ? "OPEN" : "INPUT.ARROW_DOWN", keypress });
              event2.preventDefault();
            },
            ArrowUp() {
              if (!openOnKeyPress && !open)
                return;
              send({ type: event.altKey ? "CLOSE" : "INPUT.ARROW_UP", keypress });
              event.preventDefault();
            },
            Home(event2) {
              if (isModifierKey2)
                return;
              send({ type: "INPUT.HOME", keypress });
              if (open) {
                event2.preventDefault();
              }
            },
            End(event2) {
              if (isModifierKey2)
                return;
              send({ type: "INPUT.END", keypress });
              if (open) {
                event2.preventDefault();
              }
            },
            Enter(event2) {
              send({ type: "INPUT.ENTER", keypress });
              if (open) {
                event2.preventDefault();
              }
              const itemEl = dom8.getHighlightedItemEl(state2.context);
              clickIfLink(itemEl);
            },
            Escape() {
              send({ type: "INPUT.ESCAPE", keypress });
              event.preventDefault();
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keymap[key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getTriggerProps(props29 = {}) {
      return normalize.button({
        ...parts8.trigger.attrs,
        dir: state2.context.dir,
        id: dom8.getTriggerId(state2.context),
        "aria-haspopup": composite ? "listbox" : "dialog",
        type: "button",
        tabIndex: props29.focusable ? void 0 : -1,
        "aria-label": translations.triggerLabel,
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": open ? dom8.getContentId(state2.context) : void 0,
        disabled,
        "data-focusable": dataAttr(props29.focusable),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        onFocus() {
          if (!props29.focusable)
            return;
          send({ type: "INPUT.FOCUS", src: "trigger" });
        },
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          if (!isLeftClick(event))
            return;
          send("TRIGGER.CLICK");
        },
        onPointerDown(event) {
          if (!interactive)
            return;
          if (event.pointerType === "touch")
            return;
          event.preventDefault();
          queueMicrotask(() => {
            var _a;
            (_a = dom8.getInputEl(state2.context)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (composite)
            return;
          const keyMap2 = {
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", src: "trigger" });
            },
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", src: "trigger" });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts8.content.attrs,
        dir: state2.context.dir,
        id: dom8.getContentId(state2.context),
        role: !composite ? "dialog" : "listbox",
        tabIndex: -1,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "aria-labelledby": dom8.getLabelId(state2.context),
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        onPointerDown(event) {
          event.preventDefault();
        }
      });
    },
    getListProps() {
      return normalize.element({
        ...parts8.list.attrs,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom8.getLabelId(state2.context),
        "aria-multiselectable": state2.context.multiple && !composite ? true : void 0
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts8.clearTrigger.attrs,
        dir: state2.context.dir,
        id: dom8.getClearTriggerId(state2.context),
        type: "button",
        tabIndex: -1,
        disabled,
        "aria-label": translations.clearTriggerLabel,
        "aria-controls": dom8.getInputId(state2.context),
        hidden: !state2.context.value.length,
        onPointerDown(event) {
          event.preventDefault();
        },
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          send({ type: "VALUE.CLEAR", src: "clear-trigger" });
        }
      });
    },
    getItemState,
    getItemProps(props29) {
      const itemState = getItemState(props29);
      const value = itemState.value;
      return normalize.element({
        ...parts8.item.attrs,
        dir: state2.context.dir,
        id: dom8.getItemId(state2.context, value),
        role: "option",
        tabIndex: -1,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.selected ? "checked" : "unchecked",
        "aria-selected": itemState.highlighted,
        "aria-disabled": itemState.disabled,
        "data-disabled": dataAttr(itemState.disabled),
        "data-value": itemState.value,
        onPointerMove() {
          if (itemState.disabled)
            return;
          if (itemState.highlighted)
            return;
          send({ type: "ITEM.POINTER_MOVE", value });
        },
        onPointerLeave() {
          if (props29.persistFocus)
            return;
          if (itemState.disabled)
            return;
          const mouseMoved = state2.previousEvent.type.includes("POINTER");
          if (!mouseMoved)
            return;
          send({ type: "ITEM.POINTER_LEAVE", value });
        },
        onPointerUp(event) {
          if (isDownloadingEvent(event))
            return;
          if (isOpeningInNewTab(event))
            return;
          if (isContextMenuEvent(event))
            return;
          if (itemState.disabled)
            return;
          send({ type: "ITEM.CLICK", src: "pointerup", value });
        },
        onTouchEnd(event) {
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getItemTextProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts8.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        "aria-hidden": true,
        ...parts8.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupProps(props29) {
      const { id } = props29;
      return normalize.element({
        ...parts8.itemGroup.attrs,
        dir: state2.context.dir,
        id: dom8.getItemGroupId(state2.context, id),
        "aria-labelledby": dom8.getItemGroupLabelId(state2.context, id)
      });
    },
    getItemGroupLabelProps(props29) {
      const { htmlFor } = props29;
      return normalize.element({
        ...parts8.itemGroupLabel.attrs,
        dir: state2.context.dir,
        id: dom8.getItemGroupLabelId(state2.context, htmlFor),
        role: "group"
      });
    }
  };
}
var { and: and4, not: not4 } = guards;
function machine8(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "combobox",
      initial: ctx.open ? "suggesting" : "idle",
      context: {
        loopFocus: true,
        openOnClick: false,
        value: [],
        highlightedValue: null,
        inputValue: "",
        allowCustomValue: false,
        closeOnSelect: !ctx.multiple,
        inputBehavior: "none",
        selectionBehavior: "replace",
        openOnKeyPress: true,
        openOnChange: true,
        composite: true,
        readOnly: false,
        disabled: false,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection.empty(),
        positioning: {
          placement: "bottom",
          flip: false,
          sameWidth: true,
          ...ctx.positioning
        },
        translations: {
          triggerLabel: "Toggle suggestions",
          clearTriggerLabel: "Clear value",
          ...ctx.translations
        }
      },
      created: ["syncInitialValues", "syncSelectionBehavior"],
      computed: {
        isInputValueEmpty: (ctx2) => ctx2.inputValue.length === 0,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.disabled),
        autoComplete: (ctx2) => ctx2.inputBehavior === "autocomplete",
        autoHighlight: (ctx2) => ctx2.inputBehavior === "autohighlight",
        hasSelectedItems: (ctx2) => ctx2.value.length > 0
      },
      watch: {
        value: ["syncSelectedItems"],
        inputValue: ["syncInputValue"],
        highlightedValue: ["syncHighlightedItem", "autofillInputValue"],
        multiple: ["syncSelectionBehavior"],
        open: ["toggleVisibility"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "INPUT_VALUE.SET": {
          actions: "setInputValue"
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        },
        "POSITIONING.SET": {
          actions: ["reposition"]
        }
      },
      states: {
        idle: {
          tags: ["idle", "closed"],
          entry: ["scrollContentToTop", "clearHighlightedItem"],
          on: {
            "CONTROLLED.OPEN": {
              target: "interacting"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["invokeOnOpen"]
              }
            ],
            "VALUE.CLEAR": {
              target: "focused",
              actions: ["clearInputValue", "clearSelectedItems", "setInitialFocus"]
            }
          }
        },
        focused: {
          tags: ["focused", "closed"],
          entry: ["scrollContentToTop", "clearHighlightedItem"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isChangeEvent",
                target: "suggesting"
              },
              {
                target: "interacting"
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: and4("isOpenControlled", "openOnChange"),
                actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
              },
              {
                guard: "openOnChange",
                target: "suggesting",
                actions: ["setInputValue", "invokeOnOpen", "highlightFirstItemIfNeeded"]
              },
              {
                actions: "setInputValue"
              }
            ],
            "LAYER.INTERACT_OUTSIDE": {
              target: "idle"
            },
            "INPUT.ESCAPE": {
              guard: and4("isCustomValue", not4("allowCustomValue")),
              actions: "revertInputValue"
            },
            "INPUT.BLUR": {
              target: "idle"
            },
            "INPUT.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["setInitialFocus", "highlightFirstSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.ARROW_DOWN": [
              // == group 1 ==
              {
                guard: and4("isOpenControlled", "autoComplete"),
                actions: ["invokeOnOpen"]
              },
              {
                guard: "autoComplete",
                target: "interacting",
                actions: ["invokeOnOpen"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightFirstOrSelectedItem", "invokeOnOpen"]
              }
            ],
            "INPUT.ARROW_UP": [
              // == group 1 ==
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              {
                guard: "autoComplete",
                target: "interacting",
                actions: "invokeOnOpen"
              },
              // == group 2 ==
              {
                target: "interacting",
                actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["highlightLastOrSelectedItem", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "interacting",
                actions: ["invokeOnOpen"]
              }
            ],
            "VALUE.CLEAR": {
              actions: ["clearInputValue", "clearSelectedItems"]
            }
          }
        },
        interacting: {
          tags: ["open", "focused"],
          entry: ["setInitialFocus"],
          activities: ["scrollToHighlightedItem", "trackDismissableLayer", "computePlacement", "hideOtherElements"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "restoreFocus",
                target: "focused",
                actions: ["setFinalFocus"]
              },
              {
                target: "idle"
              }
            ],
            "INPUT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "INPUT.END": {
              actions: ["highlightLastItem"]
            },
            "INPUT.ARROW_DOWN": [
              {
                guard: and4("autoComplete", "isLastItemHighlighted"),
                actions: ["clearHighlightedItem", "scrollContentToTop"]
              },
              {
                actions: ["highlightNextItem"]
              }
            ],
            "INPUT.ARROW_UP": [
              {
                guard: and4("autoComplete", "isFirstItemHighlighted"),
                actions: "clearHighlightedItem"
              },
              {
                actions: "highlightPrevItem"
              }
            ],
            "INPUT.ENTER": [
              {
                guard: and4("isOpenControlled", "closeOnSelect"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: "autoComplete",
                target: "suggesting",
                actions: ["setInputValue", "invokeOnOpen"]
              },
              {
                target: "suggesting",
                actions: ["clearHighlightedItem", "setInputValue", "invokeOnOpen"]
              }
            ],
            "ITEM.POINTER_MOVE": {
              actions: ["setHighlightedItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "ITEM.CLICK": [
              {
                guard: and4("isOpenControlled", "closeOnSelect"),
                actions: ["selectItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            "LAYER.ESCAPE": [
              {
                guard: and4("isOpenControlled", "autoComplete"),
                actions: ["syncInputValue", "invokeOnClose"]
              },
              {
                guard: "autoComplete",
                target: "focused",
                actions: ["syncInputValue", "invokeOnClose"]
              },
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "focused",
                actions: "invokeOnClose"
              }
            ],
            "LAYER.INTERACT_OUTSIDE": [
              // == group 1 ==
              {
                guard: and4("isOpenControlled", "isCustomValue", not4("allowCustomValue")),
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                guard: and4("isCustomValue", not4("allowCustomValue")),
                target: "idle",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "idle",
                actions: "invokeOnClose"
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            "VALUE.CLEAR": [
              {
                guard: "isOpenControlled",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
              }
            ]
          }
        },
        suggesting: {
          tags: ["open", "focused"],
          activities: [
            "trackDismissableLayer",
            "scrollToHighlightedItem",
            "computePlacement",
            "trackChildNodes",
            "hideOtherElements"
          ],
          entry: ["setInitialFocus"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "restoreFocus",
                target: "focused",
                actions: ["setFinalFocus"]
              },
              {
                target: "idle"
              }
            ],
            CHILDREN_CHANGE: {
              actions: ["highlightFirstItem"]
            },
            "INPUT.ARROW_DOWN": {
              target: "interacting",
              actions: ["highlightNextItem"]
            },
            "INPUT.ARROW_UP": {
              target: "interacting",
              actions: ["highlightPrevItem"]
            },
            "INPUT.HOME": {
              target: "interacting",
              actions: ["highlightFirstItem"]
            },
            "INPUT.END": {
              target: "interacting",
              actions: ["highlightLastItem"]
            },
            "INPUT.ENTER": [
              {
                guard: and4("isOpenControlled", "closeOnSelect"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "INPUT.CHANGE": [
              {
                guard: "autoHighlight",
                actions: ["setInputValue"]
              },
              {
                actions: ["setInputValue"]
              }
            ],
            "LAYER.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "ITEM.POINTER_MOVE": {
              target: "interacting",
              actions: ["setHighlightedItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "LAYER.INTERACT_OUTSIDE": [
              // == group 1 ==
              {
                guard: and4("isOpenControlled", "isCustomValue", not4("allowCustomValue")),
                actions: ["revertInputValue", "invokeOnClose"]
              },
              {
                guard: and4("isCustomValue", not4("allowCustomValue")),
                target: "idle",
                actions: ["revertInputValue", "invokeOnClose"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and4("isOpenControlled", "closeOnSelect"),
                actions: ["selectItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectItem", "invokeOnClose", "setFinalFocus"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            "VALUE.CLEAR": [
              {
                guard: "isOpenControlled",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["clearInputValue", "clearSelectedItems", "invokeOnClose", "setFinalFocus"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isInputValueEmpty: (ctx2) => ctx2.isInputValueEmpty,
        autoComplete: (ctx2) => ctx2.autoComplete && !ctx2.multiple,
        autoHighlight: (ctx2) => ctx2.autoHighlight,
        isFirstItemHighlighted: (ctx2) => ctx2.collection.first() === ctx2.highlightedValue,
        isLastItemHighlighted: (ctx2) => ctx2.collection.last() === ctx2.highlightedValue,
        isCustomValue: (ctx2) => ctx2.inputValue !== ctx2.valueAsString,
        allowCustomValue: (ctx2) => !!ctx2.allowCustomValue,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        openOnChange: (ctx2, evt) => {
          var _a;
          if (isBoolean(ctx2.openOnChange))
            return ctx2.openOnChange;
          return !!((_a = ctx2.openOnChange) == null ? void 0 : _a.call(ctx2, { inputValue: evt.value }));
        },
        restoreFocus: (_ctx, evt) => evt.restoreFocus == null ? true : !!evt.restoreFocus,
        isChangeEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "INPUT.CHANGE";
        }
      },
      activities: {
        trackDismissableLayer(ctx2, _evt, { send }) {
          if (ctx2.disableLayer)
            return;
          const contentEl = () => dom8.getContentEl(ctx2);
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: () => [dom8.getInputEl(ctx2), dom8.getTriggerEl(ctx2), dom8.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside: ctx2.onInteractOutside,
            onEscapeKeyDown(event) {
              event.preventDefault();
              event.stopPropagation();
              send("LAYER.ESCAPE");
            },
            onDismiss() {
              send({ type: "LAYER.INTERACT_OUTSIDE", restoreFocus: false });
            }
          });
        },
        hideOtherElements(ctx2) {
          return ariaHidden([dom8.getInputEl(ctx2), dom8.getContentEl(ctx2), dom8.getTriggerEl(ctx2)]);
        },
        computePlacement(ctx2) {
          const controlEl = () => dom8.getControlEl(ctx2);
          const positionerEl = () => dom8.getPositionerEl(ctx2);
          ctx2.currentPlacement = ctx2.positioning.placement;
          return getPlacement(controlEl, positionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        // in event the options are fetched (async), we still want to auto-highlight the first option
        trackChildNodes(ctx2, _evt, { send }) {
          if (!ctx2.autoHighlight)
            return;
          const exec2 = () => send("CHILDREN_CHANGE");
          const contentEl = () => dom8.getContentEl(ctx2);
          return observeChildren(contentEl, {
            callback: exec2,
            defer: true
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const inputEl = dom8.getInputEl(ctx2);
          let cleanups2 = [];
          const exec2 = (immediate) => {
            const state2 = getState();
            const pointer = state2.event.type.includes("POINTER");
            if (pointer || !ctx2.highlightedValue)
              return;
            const itemEl = dom8.getHighlightedItemEl(ctx2);
            const contentEl = dom8.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            const rafCleanup2 = raf(() => {
              scrollIntoView(itemEl, { rootEl: contentEl, block: "nearest" });
            });
            cleanups2.push(rafCleanup2);
          };
          const rafCleanup = raf(() => exec2(true));
          cleanups2.push(rafCleanup);
          const observerCleanup = observeAttributes(inputEl, {
            attributes: ["aria-activedescendant"],
            callback: () => exec2(false)
          });
          cleanups2.push(observerCleanup);
          return () => {
            cleanups2.forEach((cleanup) => cleanup());
          };
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const controlEl = () => dom8.getControlEl(ctx2);
          const positionerEl = () => dom8.getPositionerEl(ctx2);
          getPlacement(controlEl, positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setHighlightedItem(ctx2, evt) {
          if (evt.value == null)
            return;
          set7.highlightedValue(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set7.highlightedValue(ctx2, null, true);
        },
        selectHighlightedItem(ctx2) {
          set7.value(ctx2, ctx2.highlightedValue);
        },
        selectItem(ctx2, evt) {
          if (evt.value == null)
            return;
          set7.value(ctx2, evt.value);
        },
        clearItem(ctx2, evt) {
          if (evt.value == null)
            return;
          const value = ctx2.value.filter((v) => v !== evt.value);
          set7.value(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf(() => {
            dom8.focusInputEl(ctx2);
          });
        },
        setFinalFocus(ctx2) {
          raf(() => {
            const triggerEl = dom8.getTriggerEl(ctx2);
            if ((triggerEl == null ? void 0 : triggerEl.dataset.focusable) == null) {
              dom8.focusInputEl(ctx2);
            } else {
              dom8.focusTriggerEl(ctx2);
            }
          });
        },
        syncInputValue(ctx2) {
          const inputEl = dom8.getInputEl(ctx2);
          if (!inputEl)
            return;
          inputEl.value = ctx2.inputValue;
          queueMicrotask(() => {
            const { selectionStart, selectionEnd } = inputEl;
            if (Math.abs((selectionEnd ?? 0) - (selectionStart ?? 0)) !== 0)
              return;
            if (selectionStart !== 0)
              return;
            inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
          });
        },
        setInputValue(ctx2, evt) {
          set7.inputValue(ctx2, evt.value);
        },
        clearInputValue(ctx2) {
          set7.inputValue(ctx2, "");
        },
        revertInputValue(ctx2) {
          const inputValue = match2(ctx2.selectionBehavior, {
            replace: ctx2.hasSelectedItems ? ctx2.valueAsString : "",
            preserve: ctx2.inputValue,
            clear: ""
          });
          set7.inputValue(ctx2, inputValue);
        },
        syncInitialValues(ctx2) {
          const selectedItems = ctx2.collection.items(ctx2.value);
          const valueAsString = ctx2.collection.itemsToString(selectedItems);
          ctx2.highlightedItem = ctx2.collection.item(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
          ctx2.inputValue = match2(ctx2.selectionBehavior, {
            preserve: ctx2.inputValue || valueAsString,
            replace: valueAsString,
            clear: ""
          });
        },
        syncSelectionBehavior(ctx2) {
          if (ctx2.multiple) {
            ctx2.selectionBehavior = "clear";
          }
        },
        setSelectedItems(ctx2, evt) {
          if (!isArray(evt.value))
            return;
          set7.value(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set7.value(ctx2, []);
        },
        scrollContentToTop(ctx2) {
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            const contentEl = dom8.getContentEl(ctx2);
            if (!contentEl)
              return;
            contentEl.scrollTop = 0;
          }
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        highlightFirstItem(ctx2) {
          raf(() => {
            const value = ctx2.collection.first();
            set7.highlightedValue(ctx2, value);
          });
        },
        highlightFirstItemIfNeeded(ctx2) {
          if (!ctx2.autoHighlight)
            return;
          raf(() => {
            const value = ctx2.collection.first();
            set7.highlightedValue(ctx2, value);
          });
        },
        highlightLastItem(ctx2) {
          raf(() => {
            const value = ctx2.collection.last();
            set7.highlightedValue(ctx2, value);
          });
        },
        highlightNextItem(ctx2) {
          let value = null;
          if (ctx2.highlightedValue) {
            value = ctx2.collection.next(ctx2.highlightedValue);
            if (!value && ctx2.loopFocus)
              value = ctx2.collection.first();
          } else {
            value = ctx2.collection.first();
          }
          set7.highlightedValue(ctx2, value);
        },
        highlightPrevItem(ctx2) {
          let value = null;
          if (ctx2.highlightedValue) {
            value = ctx2.collection.prev(ctx2.highlightedValue);
            if (!value && ctx2.loopFocus)
              value = ctx2.collection.last();
          } else {
            value = ctx2.collection.last();
          }
          set7.highlightedValue(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          raf(() => {
            const [value] = ctx2.collection.sort(ctx2.value);
            set7.highlightedValue(ctx2, value);
          });
        },
        highlightFirstOrSelectedItem(ctx2) {
          raf(() => {
            let value = null;
            if (ctx2.hasSelectedItems) {
              value = ctx2.collection.sort(ctx2.value)[0];
            } else {
              value = ctx2.collection.first();
            }
            set7.highlightedValue(ctx2, value);
          });
        },
        highlightLastOrSelectedItem(ctx2) {
          raf(() => {
            let value = null;
            if (ctx2.hasSelectedItems) {
              value = ctx2.collection.sort(ctx2.value)[0];
            } else {
              value = ctx2.collection.last();
            }
            set7.highlightedValue(ctx2, value);
          });
        },
        autofillInputValue(ctx2, evt) {
          const inputEl = dom8.getInputEl(ctx2);
          if (!ctx2.autoComplete || !inputEl || !evt.keypress)
            return;
          const valueText = ctx2.collection.valueToString(ctx2.highlightedValue);
          raf(() => {
            inputEl.value = valueText || ctx2.inputValue;
          });
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncSelectedItems(ctx2) {
          sync2.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync2.highlightChange(ctx2);
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var sync2 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((v) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.itemToValue(item) === v);
      if (foundItem)
        return foundItem;
      return ctx.collection.item(v);
    });
    const valueAsString = ctx.collection.itemsToString(ctx.selectedItems);
    ctx.valueAsString = valueAsString;
    let inputValue;
    if (ctx.getSelectionValue) {
      inputValue = ctx.getSelectionValue({
        inputValue: ctx.inputValue,
        selectedItems: Array.from(ctx.selectedItems),
        valueAsString
      });
    } else {
      inputValue = match2(ctx.selectionBehavior, {
        replace: ctx.valueAsString,
        preserve: ctx.inputValue,
        clear: ""
      });
    }
    set7.inputValue(ctx, inputValue);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.item(ctx.highlightedValue);
  }
};
var invoke5 = {
  valueChange: (ctx) => {
    var _a;
    sync2.valueChange(ctx);
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
  },
  highlightChange: (ctx) => {
    var _a;
    sync2.highlightChange(ctx);
    (_a = ctx.onHighlightChange) == null ? void 0 : _a.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem
    });
  },
  inputChange: (ctx) => {
    var _a;
    (_a = ctx.onInputValueChange) == null ? void 0 : _a.call(ctx, { inputValue: ctx.inputValue });
  }
};
var set7 = {
  value: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value))
      return;
    if (value == null && !force)
      return;
    if (value == null && force) {
      ctx.value = [];
      invoke5.valueChange(ctx);
      return;
    }
    if (isArray(value)) {
      ctx.value = value;
    } else if (value != null) {
      ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    }
    invoke5.valueChange(ctx);
  },
  highlightedValue: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value))
      return;
    if (!value && !force)
      return;
    ctx.highlightedValue = value || null;
    invoke5.highlightChange(ctx);
  },
  inputValue: (ctx, value) => {
    if (isEqual(ctx.inputValue, value))
      return;
    ctx.inputValue = value;
    invoke5.inputChange(ctx);
  }
};

// node_modules/@internationalized/date/dist/utils.mjs
function $2b4dce13dd5a17fa$export$842a2cf37af977e1(amount, numerator) {
  return amount - numerator * Math.floor(amount / numerator);
}

// node_modules/@internationalized/date/dist/GregorianCalendar.mjs
var $3b62074eb05584b2$var$EPOCH = 1721426;
function $3b62074eb05584b2$export$f297eb839006d339(era, year, month, day) {
  year = $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year);
  let y1 = year - 1;
  let monthOffset = -2;
  if (month <= 2)
    monthOffset = 0;
  else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year))
    monthOffset = -1;
  return $3b62074eb05584b2$var$EPOCH - 1 + 365 * y1 + Math.floor(y1 / 4) - Math.floor(y1 / 100) + Math.floor(y1 / 400) + Math.floor((367 * month - 362) / 12 + monthOffset + day);
}
function $3b62074eb05584b2$export$553d7fa8e3805fc0(year) {
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}
function $3b62074eb05584b2$export$c36e0ecb2d4fa69d(era, year) {
  return era === "BC" ? 1 - year : year;
}
function $3b62074eb05584b2$export$4475b7e617eb123c(year) {
  let era = "AD";
  if (year <= 0) {
    era = "BC";
    year = 1 - year;
  }
  return [
    era,
    year
  ];
}
var $3b62074eb05584b2$var$daysInMonth = {
  standard: [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ],
  leapyear: [
    31,
    29,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
  ]
};
var $3b62074eb05584b2$export$80ee6245ec4f29ec = class {
  fromJulianDay(jd) {
    let jd0 = jd;
    let depoch = jd0 - $3b62074eb05584b2$var$EPOCH;
    let quadricent = Math.floor(depoch / 146097);
    let dqc = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(depoch, 146097);
    let cent = Math.floor(dqc / 36524);
    let dcent = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dqc, 36524);
    let quad = Math.floor(dcent / 1461);
    let dquad = (0, $2b4dce13dd5a17fa$export$842a2cf37af977e1)(dcent, 1461);
    let yindex = Math.floor(dquad / 365);
    let extendedYear = quadricent * 400 + cent * 100 + quad * 4 + yindex + (cent !== 4 && yindex !== 4 ? 1 : 0);
    let [era, year] = $3b62074eb05584b2$export$4475b7e617eb123c(extendedYear);
    let yearDay = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, 1, 1);
    let leapAdj = 2;
    if (jd0 < $3b62074eb05584b2$export$f297eb839006d339(era, year, 3, 1))
      leapAdj = 0;
    else if ($3b62074eb05584b2$export$553d7fa8e3805fc0(year))
      leapAdj = 1;
    let month = Math.floor(((yearDay + leapAdj) * 12 + 373) / 367);
    let day = jd0 - $3b62074eb05584b2$export$f297eb839006d339(era, year, month, 1) + 1;
    return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(era, year, month, day);
  }
  toJulianDay(date) {
    return $3b62074eb05584b2$export$f297eb839006d339(date.era, date.year, date.month, date.day);
  }
  getDaysInMonth(date) {
    return $3b62074eb05584b2$var$daysInMonth[$3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? "leapyear" : "standard"][date.month - 1];
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getMonthsInYear(date) {
    return 12;
  }
  getDaysInYear(date) {
    return $3b62074eb05584b2$export$553d7fa8e3805fc0(date.year) ? 366 : 365;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  getYearsInEra(date) {
    return 9999;
  }
  getEras() {
    return [
      "BC",
      "AD"
    ];
  }
  isInverseEra(date) {
    return date.era === "BC";
  }
  balanceDate(date) {
    if (date.year <= 0) {
      date.era = date.era === "BC" ? "AD" : "BC";
      date.year = 1 - date.year;
    }
  }
  constructor() {
    this.identifier = "gregory";
  }
};

// node_modules/@internationalized/date/dist/weekStartData.mjs
var $2fe286d2fb449abb$export$7a5acbd77d414bd9 = {
  "001": 1,
  AD: 1,
  AE: 6,
  AF: 6,
  AI: 1,
  AL: 1,
  AM: 1,
  AN: 1,
  AR: 1,
  AT: 1,
  AU: 1,
  AX: 1,
  AZ: 1,
  BA: 1,
  BE: 1,
  BG: 1,
  BH: 6,
  BM: 1,
  BN: 1,
  BY: 1,
  CH: 1,
  CL: 1,
  CM: 1,
  CN: 1,
  CR: 1,
  CY: 1,
  CZ: 1,
  DE: 1,
  DJ: 6,
  DK: 1,
  DZ: 6,
  EC: 1,
  EE: 1,
  EG: 6,
  ES: 1,
  FI: 1,
  FJ: 1,
  FO: 1,
  FR: 1,
  GB: 1,
  GE: 1,
  GF: 1,
  GP: 1,
  GR: 1,
  HR: 1,
  HU: 1,
  IE: 1,
  IQ: 6,
  IR: 6,
  IS: 1,
  IT: 1,
  JO: 6,
  KG: 1,
  KW: 6,
  KZ: 1,
  LB: 1,
  LI: 1,
  LK: 1,
  LT: 1,
  LU: 1,
  LV: 1,
  LY: 6,
  MC: 1,
  MD: 1,
  ME: 1,
  MK: 1,
  MN: 1,
  MQ: 1,
  MV: 5,
  MY: 1,
  NL: 1,
  NO: 1,
  NZ: 1,
  OM: 6,
  PL: 1,
  QA: 6,
  RE: 1,
  RO: 1,
  RS: 1,
  RU: 1,
  SD: 6,
  SE: 1,
  SI: 1,
  SK: 1,
  SM: 1,
  SY: 6,
  TJ: 1,
  TM: 1,
  TR: 1,
  UA: 1,
  UY: 1,
  UZ: 1,
  VA: 1,
  VN: 1,
  XK: 1
};

// node_modules/@internationalized/date/dist/queries.mjs
function $14e0f24ef4ac5c92$export$ea39ec197993aef0(a2, b2) {
  b2 = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(b2, a2.calendar);
  return a2.era === b2.era && a2.year === b2.year && a2.month === b2.month && a2.day === b2.day;
}
function $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(a2, b2) {
  return a2.calendar.identifier === b2.calendar.identifier && a2.era === b2.era && a2.year === b2.year && a2.month === b2.month && a2.day === b2.day;
}
function $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone) {
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(date, $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
}
function $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale) {
  let julian = date.calendar.toJulianDay(date);
  let dayOfWeek = Math.ceil(julian + 1 - $14e0f24ef4ac5c92$var$getWeekStart(locale)) % 7;
  if (dayOfWeek < 0)
    dayOfWeek += 7;
  return dayOfWeek;
}
function $14e0f24ef4ac5c92$export$461939dd4422153(timeZone) {
  return (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(Date.now(), timeZone);
}
function $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone) {
  return (0, $11d87f3f76e88657$export$93522d1a439f3617)($14e0f24ef4ac5c92$export$461939dd4422153(timeZone));
}
function $14e0f24ef4ac5c92$export$68781ddf31c0090f(a2, b2) {
  return a2.calendar.toJulianDay(a2) - b2.calendar.toJulianDay(b2);
}
function $14e0f24ef4ac5c92$export$c19a80a9721b80f6(a2, b2) {
  return $14e0f24ef4ac5c92$var$timeToMs(a2) - $14e0f24ef4ac5c92$var$timeToMs(b2);
}
function $14e0f24ef4ac5c92$var$timeToMs(a2) {
  return a2.hour * 36e5 + a2.minute * 6e4 + a2.second * 1e3 + a2.millisecond;
}
var $14e0f24ef4ac5c92$var$localTimeZone = null;
function $14e0f24ef4ac5c92$export$aa8b41735afcabd2() {
  if ($14e0f24ef4ac5c92$var$localTimeZone == null)
    $14e0f24ef4ac5c92$var$localTimeZone = new Intl.DateTimeFormat().resolvedOptions().timeZone;
  return $14e0f24ef4ac5c92$var$localTimeZone;
}
function $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date) {
  return date.subtract({
    days: date.day - 1
  });
}
function $14e0f24ef4ac5c92$export$a2258d9c4118825c(date) {
  return date.add({
    days: date.calendar.getDaysInMonth(date) - date.day
  });
}
function $14e0f24ef4ac5c92$export$f91e89d3d0406102(date) {
  return $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date.subtract({
    months: date.month - 1
  }));
}
function $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(date) {
  return $14e0f24ef4ac5c92$export$a2258d9c4118825c(date.add({
    months: date.calendar.getMonthsInYear(date) - date.month
  }));
}
function $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale) {
  let dayOfWeek = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  return date.subtract({
    days: dayOfWeek
  });
}
function $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(date, locale) {
  return $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale).add({
    days: 6
  });
}
var $14e0f24ef4ac5c92$var$cachedRegions = /* @__PURE__ */ new Map();
function $14e0f24ef4ac5c92$var$getRegion(locale) {
  if (Intl.Locale) {
    let region = $14e0f24ef4ac5c92$var$cachedRegions.get(locale);
    if (!region) {
      region = new Intl.Locale(locale).maximize().region;
      if (region)
        $14e0f24ef4ac5c92$var$cachedRegions.set(locale, region);
    }
    return region;
  }
  let part = locale.split("-")[1];
  return part === "u" ? void 0 : part;
}
function $14e0f24ef4ac5c92$var$getWeekStart(locale) {
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  return region ? (0, $2fe286d2fb449abb$export$7a5acbd77d414bd9)[region] || 0 : 0;
}
function $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(date, locale) {
  let days = date.calendar.getDaysInMonth(date);
  return Math.ceil(($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(date), locale) + days) / 7);
}
function $14e0f24ef4ac5c92$export$5c333a116e949cdd(a2, b2) {
  if (a2 && b2)
    return a2.compare(b2) <= 0 ? a2 : b2;
  return a2 || b2;
}
function $14e0f24ef4ac5c92$export$a75f2bff57811055(a2, b2) {
  if (a2 && b2)
    return a2.compare(b2) >= 0 ? a2 : b2;
  return a2 || b2;
}
var $14e0f24ef4ac5c92$var$WEEKEND_DATA = {
  AF: [
    4,
    5
  ],
  AE: [
    5,
    6
  ],
  BH: [
    5,
    6
  ],
  DZ: [
    5,
    6
  ],
  EG: [
    5,
    6
  ],
  IL: [
    5,
    6
  ],
  IQ: [
    5,
    6
  ],
  IR: [
    5,
    5
  ],
  JO: [
    5,
    6
  ],
  KW: [
    5,
    6
  ],
  LY: [
    5,
    6
  ],
  OM: [
    5,
    6
  ],
  QA: [
    5,
    6
  ],
  SA: [
    5,
    6
  ],
  SD: [
    5,
    6
  ],
  SY: [
    5,
    6
  ],
  YE: [
    5,
    6
  ]
};
function $14e0f24ef4ac5c92$export$618d60ea299da42(date, locale) {
  let julian = date.calendar.toJulianDay(date);
  let dayOfWeek = Math.ceil(julian + 1) % 7;
  if (dayOfWeek < 0)
    dayOfWeek += 7;
  let region = $14e0f24ef4ac5c92$var$getRegion(locale);
  let [start, end] = $14e0f24ef4ac5c92$var$WEEKEND_DATA[region] || [
    6,
    0
  ];
  return dayOfWeek === start || dayOfWeek === end;
}

// node_modules/@internationalized/date/dist/conversion.mjs
function $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) {
  date = $11d87f3f76e88657$export$b4a036af3fc0b032(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(date.era, date.year);
  return $11d87f3f76e88657$var$epochFromParts(year, date.month, date.day, date.hour, date.minute, date.second, date.millisecond);
}
function $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, millisecond) {
  let date = /* @__PURE__ */ new Date();
  date.setUTCHours(hour, minute, second, millisecond);
  date.setUTCFullYear(year, month - 1, day);
  return date.getTime();
}
function $11d87f3f76e88657$export$59c99f3515d3493f(ms2, timeZone) {
  if (timeZone === "UTC")
    return 0;
  if (ms2 > 0 && timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)())
    return new Date(ms2).getTimezoneOffset() * -6e4;
  let { year, month, day, hour, minute, second } = $11d87f3f76e88657$var$getTimeZoneParts(ms2, timeZone);
  let utc = $11d87f3f76e88657$var$epochFromParts(year, month, day, hour, minute, second, 0);
  return utc - Math.floor(ms2 / 1e3) * 1e3;
}
var $11d87f3f76e88657$var$formattersByTimeZone = /* @__PURE__ */ new Map();
function $11d87f3f76e88657$var$getTimeZoneParts(ms2, timeZone) {
  let formatter = $11d87f3f76e88657$var$formattersByTimeZone.get(timeZone);
  if (!formatter) {
    formatter = new Intl.DateTimeFormat("en-US", {
      timeZone,
      hour12: false,
      era: "short",
      year: "numeric",
      month: "numeric",
      day: "numeric",
      hour: "numeric",
      minute: "numeric",
      second: "numeric"
    });
    $11d87f3f76e88657$var$formattersByTimeZone.set(timeZone, formatter);
  }
  let parts34 = formatter.formatToParts(new Date(ms2));
  let namedParts = {};
  for (let part of parts34)
    if (part.type !== "literal")
      namedParts[part.type] = part.value;
  return {
    // Firefox returns B instead of BC... https://bugzilla.mozilla.org/show_bug.cgi?id=1752253
    year: namedParts.era === "BC" || namedParts.era === "B" ? -namedParts.year + 1 : +namedParts.year,
    month: +namedParts.month,
    day: +namedParts.day,
    hour: namedParts.hour === "24" ? 0 : +namedParts.hour,
    minute: +namedParts.minute,
    second: +namedParts.second
  };
}
var $11d87f3f76e88657$var$DAYMILLIS = 864e5;
function $11d87f3f76e88657$var$getValidWallTimes(date, timeZone, earlier, later) {
  let found = earlier === later ? [
    earlier
  ] : [
    earlier,
    later
  ];
  return found.filter((absolute) => $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute));
}
function $11d87f3f76e88657$var$isValidWallTime(date, timeZone, absolute) {
  let parts34 = $11d87f3f76e88657$var$getTimeZoneParts(absolute, timeZone);
  return date.year === parts34.year && date.month === parts34.month && date.day === parts34.day && date.hour === parts34.hour && date.minute === parts34.minute && date.second === parts34.second;
}
function $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation = "compatible") {
  let dateTime = $11d87f3f76e88657$export$b21e0b124e224484(date);
  if (timeZone === "UTC")
    return $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  if (timeZone === (0, $14e0f24ef4ac5c92$export$aa8b41735afcabd2)() && disambiguation === "compatible") {
    dateTime = $11d87f3f76e88657$export$b4a036af3fc0b032(dateTime, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
    let date2 = /* @__PURE__ */ new Date();
    let year = (0, $3b62074eb05584b2$export$c36e0ecb2d4fa69d)(dateTime.era, dateTime.year);
    date2.setFullYear(year, dateTime.month - 1, dateTime.day);
    date2.setHours(dateTime.hour, dateTime.minute, dateTime.second, dateTime.millisecond);
    return date2.getTime();
  }
  let ms2 = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(dateTime);
  let offsetBefore = $11d87f3f76e88657$export$59c99f3515d3493f(ms2 - $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let offsetAfter = $11d87f3f76e88657$export$59c99f3515d3493f(ms2 + $11d87f3f76e88657$var$DAYMILLIS, timeZone);
  let valid = $11d87f3f76e88657$var$getValidWallTimes(dateTime, timeZone, ms2 - offsetBefore, ms2 - offsetAfter);
  if (valid.length === 1)
    return valid[0];
  if (valid.length > 1)
    switch (disambiguation) {
      case "compatible":
      case "earlier":
        return valid[0];
      case "later":
        return valid[valid.length - 1];
      case "reject":
        throw new RangeError("Multiple possible absolute times found");
    }
  switch (disambiguation) {
    case "earlier":
      return Math.min(ms2 - offsetBefore, ms2 - offsetAfter);
    case "compatible":
    case "later":
      return Math.max(ms2 - offsetBefore, ms2 - offsetAfter);
    case "reject":
      throw new RangeError("No such absolute time found");
  }
}
function $11d87f3f76e88657$export$e67a095c620b86fe(dateTime, timeZone, disambiguation = "compatible") {
  return new Date($11d87f3f76e88657$export$5107c82f94518f5c(dateTime, timeZone, disambiguation));
}
function $11d87f3f76e88657$export$1b96692a1ba042ac(ms2, timeZone) {
  let offset3 = $11d87f3f76e88657$export$59c99f3515d3493f(ms2, timeZone);
  let date = new Date(ms2 + offset3);
  let year = date.getUTCFullYear();
  let month = date.getUTCMonth() + 1;
  let day = date.getUTCDate();
  let hour = date.getUTCHours();
  let minute = date.getUTCMinutes();
  let second = date.getUTCSeconds();
  let millisecond = date.getUTCMilliseconds();
  return new (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)(year, month, day, timeZone, offset3, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$93522d1a439f3617(dateTime) {
  return new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)(dateTime.calendar, dateTime.era, dateTime.year, dateTime.month, dateTime.day);
}
function $11d87f3f76e88657$export$b21e0b124e224484(date, time) {
  let hour = 0, minute = 0, second = 0, millisecond = 0;
  if ("timeZone" in date)
    ({ hour, minute, second, millisecond } = date);
  else if ("hour" in date && !time)
    return date;
  if (time)
    ({ hour, minute, second, millisecond } = time);
  return new (0, $35ea8db9cb2ccb90$export$ca871e8dbb80966f)(date.calendar, date.era, date.year, date.month, date.day, hour, minute, second, millisecond);
}
function $11d87f3f76e88657$export$b4a036af3fc0b032(date, calendar) {
  if (date.calendar.identifier === calendar.identifier)
    return date;
  let calendarDate = calendar.fromJulianDay(date.calendar.toJulianDay(date));
  let copy = date.copy();
  copy.calendar = calendar;
  copy.era = calendarDate.era;
  copy.year = calendarDate.year;
  copy.month = calendarDate.month;
  copy.day = calendarDate.day;
  (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(copy);
  return copy;
}
function $11d87f3f76e88657$export$84c95a83c799e074(date, timeZone, disambiguation) {
  if (date instanceof (0, $35ea8db9cb2ccb90$export$d3b7288e7994edea)) {
    if (date.timeZone === timeZone)
      return date;
    return $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone);
  }
  let ms2 = $11d87f3f76e88657$export$5107c82f94518f5c(date, timeZone, disambiguation);
  return $11d87f3f76e88657$export$1b96692a1ba042ac(ms2, timeZone);
}
function $11d87f3f76e88657$export$83aac07b4c37b25(date) {
  let ms2 = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return new Date(ms2);
}
function $11d87f3f76e88657$export$538b00033cc11c75(date, timeZone) {
  let ms2 = $11d87f3f76e88657$export$bd4fb2bc8bb06fb(date) - date.offset;
  return $11d87f3f76e88657$export$b4a036af3fc0b032($11d87f3f76e88657$export$1b96692a1ba042ac(ms2, timeZone), date.calendar);
}

// node_modules/@internationalized/date/dist/manipulation.mjs
var $735220c2d4774dd3$var$ONE_HOUR = 36e5;
function $735220c2d4774dd3$export$e16d8520af44a096(date, duration) {
  let mutableDate = date.copy();
  let days = "hour" in mutableDate ? $735220c2d4774dd3$var$addTimeFields(mutableDate, duration) : 0;
  $735220c2d4774dd3$var$addYears(mutableDate, duration.years || 0);
  if (mutableDate.calendar.balanceYearMonth)
    mutableDate.calendar.balanceYearMonth(mutableDate, date);
  mutableDate.month += duration.months || 0;
  $735220c2d4774dd3$var$balanceYearMonth(mutableDate);
  $735220c2d4774dd3$var$constrainMonthDay(mutableDate);
  mutableDate.day += (duration.weeks || 0) * 7;
  mutableDate.day += duration.days || 0;
  mutableDate.day += days;
  $735220c2d4774dd3$var$balanceDay(mutableDate);
  if (mutableDate.calendar.balanceDate)
    mutableDate.calendar.balanceDate(mutableDate);
  if (mutableDate.year < 1) {
    mutableDate.year = 1;
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxYear = mutableDate.calendar.getYearsInEra(mutableDate);
  if (mutableDate.year > maxYear) {
    var _mutableDate_calendar_isInverseEra, _mutableDate_calendar;
    let isInverseEra = (_mutableDate_calendar_isInverseEra = (_mutableDate_calendar = mutableDate.calendar).isInverseEra) === null || _mutableDate_calendar_isInverseEra === void 0 ? void 0 : _mutableDate_calendar_isInverseEra.call(_mutableDate_calendar, mutableDate);
    mutableDate.year = maxYear;
    mutableDate.month = isInverseEra ? 1 : mutableDate.calendar.getMonthsInYear(mutableDate);
    mutableDate.day = isInverseEra ? 1 : mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  if (mutableDate.month < 1) {
    mutableDate.month = 1;
    mutableDate.day = 1;
  }
  let maxMonth = mutableDate.calendar.getMonthsInYear(mutableDate);
  if (mutableDate.month > maxMonth) {
    mutableDate.month = maxMonth;
    mutableDate.day = mutableDate.calendar.getDaysInMonth(mutableDate);
  }
  mutableDate.day = Math.max(1, Math.min(mutableDate.calendar.getDaysInMonth(mutableDate), mutableDate.day));
  return mutableDate;
}
function $735220c2d4774dd3$var$addYears(date, years) {
  var _date_calendar_isInverseEra, _date_calendar;
  if ((_date_calendar_isInverseEra = (_date_calendar = date.calendar).isInverseEra) === null || _date_calendar_isInverseEra === void 0 ? void 0 : _date_calendar_isInverseEra.call(_date_calendar, date))
    years = -years;
  date.year += years;
}
function $735220c2d4774dd3$var$balanceYearMonth(date) {
  while (date.month < 1) {
    $735220c2d4774dd3$var$addYears(date, -1);
    date.month += date.calendar.getMonthsInYear(date);
  }
  let monthsInYear = 0;
  while (date.month > (monthsInYear = date.calendar.getMonthsInYear(date))) {
    date.month -= monthsInYear;
    $735220c2d4774dd3$var$addYears(date, 1);
  }
}
function $735220c2d4774dd3$var$balanceDay(date) {
  while (date.day < 1) {
    date.month--;
    $735220c2d4774dd3$var$balanceYearMonth(date);
    date.day += date.calendar.getDaysInMonth(date);
  }
  while (date.day > date.calendar.getDaysInMonth(date)) {
    date.day -= date.calendar.getDaysInMonth(date);
    date.month++;
    $735220c2d4774dd3$var$balanceYearMonth(date);
  }
}
function $735220c2d4774dd3$var$constrainMonthDay(date) {
  date.month = Math.max(1, Math.min(date.calendar.getMonthsInYear(date), date.month));
  date.day = Math.max(1, Math.min(date.calendar.getDaysInMonth(date), date.day));
}
function $735220c2d4774dd3$export$c4e2ecac49351ef2(date) {
  if (date.calendar.constrainDate)
    date.calendar.constrainDate(date);
  date.year = Math.max(1, Math.min(date.calendar.getYearsInEra(date), date.year));
  $735220c2d4774dd3$var$constrainMonthDay(date);
}
function $735220c2d4774dd3$export$3e2544e88a25bff8(duration) {
  let inverseDuration = {};
  for (let key in duration)
    if (typeof duration[key] === "number")
      inverseDuration[key] = -duration[key];
  return inverseDuration;
}
function $735220c2d4774dd3$export$4e2d2ead65e5f7e3(date, duration) {
  return $735220c2d4774dd3$export$e16d8520af44a096(date, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$adaa4cf7ef1b65be(date, fields) {
  let mutableDate = date.copy();
  if (fields.era != null)
    mutableDate.era = fields.era;
  if (fields.year != null)
    mutableDate.year = fields.year;
  if (fields.month != null)
    mutableDate.month = fields.month;
  if (fields.day != null)
    mutableDate.day = fields.day;
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutableDate);
  return mutableDate;
}
function $735220c2d4774dd3$export$e5d5e1c1822b6e56(value, fields) {
  let mutableValue = value.copy();
  if (fields.hour != null)
    mutableValue.hour = fields.hour;
  if (fields.minute != null)
    mutableValue.minute = fields.minute;
  if (fields.second != null)
    mutableValue.second = fields.second;
  if (fields.millisecond != null)
    mutableValue.millisecond = fields.millisecond;
  $735220c2d4774dd3$export$7555de1e070510cb(mutableValue);
  return mutableValue;
}
function $735220c2d4774dd3$var$balanceTime(time) {
  time.second += Math.floor(time.millisecond / 1e3);
  time.millisecond = $735220c2d4774dd3$var$nonNegativeMod(time.millisecond, 1e3);
  time.minute += Math.floor(time.second / 60);
  time.second = $735220c2d4774dd3$var$nonNegativeMod(time.second, 60);
  time.hour += Math.floor(time.minute / 60);
  time.minute = $735220c2d4774dd3$var$nonNegativeMod(time.minute, 60);
  let days = Math.floor(time.hour / 24);
  time.hour = $735220c2d4774dd3$var$nonNegativeMod(time.hour, 24);
  return days;
}
function $735220c2d4774dd3$export$7555de1e070510cb(time) {
  time.millisecond = Math.max(0, Math.min(time.millisecond, 1e3));
  time.second = Math.max(0, Math.min(time.second, 59));
  time.minute = Math.max(0, Math.min(time.minute, 59));
  time.hour = Math.max(0, Math.min(time.hour, 23));
}
function $735220c2d4774dd3$var$nonNegativeMod(a2, b2) {
  let result = a2 % b2;
  if (result < 0)
    result += b2;
  return result;
}
function $735220c2d4774dd3$var$addTimeFields(time, duration) {
  time.hour += duration.hours || 0;
  time.minute += duration.minutes || 0;
  time.second += duration.seconds || 0;
  time.millisecond += duration.milliseconds || 0;
  return $735220c2d4774dd3$var$balanceTime(time);
}
function $735220c2d4774dd3$export$d52ced6badfb9a4c(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "era": {
      let eras = value.calendar.getEras();
      let eraIndex = eras.indexOf(value.era);
      if (eraIndex < 0)
        throw new Error("Invalid era: " + value.era);
      eraIndex = $735220c2d4774dd3$var$cycleValue(eraIndex, amount, 0, eras.length - 1, options === null || options === void 0 ? void 0 : options.round);
      mutable.era = eras[eraIndex];
      $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
      break;
    }
    case "year":
      var _mutable_calendar_isInverseEra, _mutable_calendar;
      if ((_mutable_calendar_isInverseEra = (_mutable_calendar = mutable.calendar).isInverseEra) === null || _mutable_calendar_isInverseEra === void 0 ? void 0 : _mutable_calendar_isInverseEra.call(_mutable_calendar, mutable))
        amount = -amount;
      mutable.year = $735220c2d4774dd3$var$cycleValue(value.year, amount, -Infinity, 9999, options === null || options === void 0 ? void 0 : options.round);
      if (mutable.year === -Infinity)
        mutable.year = 1;
      if (mutable.calendar.balanceYearMonth)
        mutable.calendar.balanceYearMonth(mutable, value);
      break;
    case "month":
      mutable.month = $735220c2d4774dd3$var$cycleValue(value.month, amount, 1, value.calendar.getMonthsInYear(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    case "day":
      mutable.day = $735220c2d4774dd3$var$cycleValue(value.day, amount, 1, value.calendar.getDaysInMonth(value), options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  if (value.calendar.balanceDate)
    value.calendar.balanceDate(mutable);
  $735220c2d4774dd3$export$c4e2ecac49351ef2(mutable);
  return mutable;
}
function $735220c2d4774dd3$export$dd02b3e0007dfe28(value, field, amount, options) {
  let mutable = value.copy();
  switch (field) {
    case "hour": {
      let hours = value.hour;
      let min3 = 0;
      let max3 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = hours >= 12;
        min3 = isPM ? 12 : 0;
        max3 = isPM ? 23 : 11;
      }
      mutable.hour = $735220c2d4774dd3$var$cycleValue(hours, amount, min3, max3, options === null || options === void 0 ? void 0 : options.round);
      break;
    }
    case "minute":
      mutable.minute = $735220c2d4774dd3$var$cycleValue(value.minute, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "second":
      mutable.second = $735220c2d4774dd3$var$cycleValue(value.second, amount, 0, 59, options === null || options === void 0 ? void 0 : options.round);
      break;
    case "millisecond":
      mutable.millisecond = $735220c2d4774dd3$var$cycleValue(value.millisecond, amount, 0, 999, options === null || options === void 0 ? void 0 : options.round);
      break;
    default:
      throw new Error("Unsupported field " + field);
  }
  return mutable;
}
function $735220c2d4774dd3$var$cycleValue(value, amount, min3, max3, round2 = false) {
  if (round2) {
    value += Math.sign(amount);
    if (value < min3)
      value = max3;
    let div = Math.abs(amount);
    if (amount > 0)
      value = Math.ceil(value / div) * div;
    else
      value = Math.floor(value / div) * div;
    if (value > max3)
      value = min3;
  } else {
    value += amount;
    if (value < min3)
      value = max3 - (min3 - value - 1);
    else if (value > max3)
      value = min3 + (value - max3 - 1);
  }
  return value;
}
function $735220c2d4774dd3$export$96b1d28349274637(dateTime, duration) {
  let ms2;
  if (duration.years != null && duration.years !== 0 || duration.months != null && duration.months !== 0 || duration.weeks != null && duration.weeks !== 0 || duration.days != null && duration.days !== 0) {
    let res2 = $735220c2d4774dd3$export$e16d8520af44a096((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), {
      years: duration.years,
      months: duration.months,
      weeks: duration.weeks,
      days: duration.days
    });
    ms2 = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res2, dateTime.timeZone);
  } else
    ms2 = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
  ms2 += duration.milliseconds || 0;
  ms2 += (duration.seconds || 0) * 1e3;
  ms2 += (duration.minutes || 0) * 6e4;
  ms2 += (duration.hours || 0) * 36e5;
  let res = (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(res, dateTime.calendar);
}
function $735220c2d4774dd3$export$6814caac34ca03c7(dateTime, duration) {
  return $735220c2d4774dd3$export$96b1d28349274637(dateTime, $735220c2d4774dd3$export$3e2544e88a25bff8(duration));
}
function $735220c2d4774dd3$export$9a297d111fc86b79(dateTime, field, amount, options) {
  switch (field) {
    case "hour": {
      let min3 = 0;
      let max3 = 23;
      if ((options === null || options === void 0 ? void 0 : options.hourCycle) === 12) {
        let isPM = dateTime.hour >= 12;
        min3 = isPM ? 12 : 0;
        max3 = isPM ? 23 : 11;
      }
      let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
      let minDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: min3
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let minAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(minDate, dateTime.timeZone, "later")
      ].filter((ms3) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms3, dateTime.timeZone).day === minDate.day)[0];
      let maxDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)($735220c2d4774dd3$export$e5d5e1c1822b6e56(plainDateTime, {
        hour: max3
      }), new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
      let maxAbsolute = [
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "earlier"),
        (0, $11d87f3f76e88657$export$5107c82f94518f5c)(maxDate, dateTime.timeZone, "later")
      ].filter((ms3) => (0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms3, dateTime.timeZone).day === maxDate.day).pop();
      let ms2 = (0, $11d87f3f76e88657$export$bd4fb2bc8bb06fb)(dateTime) - dateTime.offset;
      let hours = Math.floor(ms2 / $735220c2d4774dd3$var$ONE_HOUR);
      let remainder = ms2 % $735220c2d4774dd3$var$ONE_HOUR;
      ms2 = $735220c2d4774dd3$var$cycleValue(hours, amount, Math.floor(minAbsolute / $735220c2d4774dd3$var$ONE_HOUR), Math.floor(maxAbsolute / $735220c2d4774dd3$var$ONE_HOUR), options === null || options === void 0 ? void 0 : options.round) * $735220c2d4774dd3$var$ONE_HOUR + remainder;
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone), dateTime.calendar);
    }
    case "minute":
    case "second":
    case "millisecond":
      return $735220c2d4774dd3$export$dd02b3e0007dfe28(dateTime, field, amount, options);
    case "era":
    case "year":
    case "month":
    case "day": {
      let res = $735220c2d4774dd3$export$d52ced6badfb9a4c((0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime), field, amount, options);
      let ms2 = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone);
      return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone), dateTime.calendar);
    }
    default:
      throw new Error("Unsupported field " + field);
  }
}
function $735220c2d4774dd3$export$31b5430eb18be4f8(dateTime, fields, disambiguation) {
  let plainDateTime = (0, $11d87f3f76e88657$export$b21e0b124e224484)(dateTime);
  let res = $735220c2d4774dd3$export$e5d5e1c1822b6e56($735220c2d4774dd3$export$adaa4cf7ef1b65be(plainDateTime, fields), fields);
  if (res.compare(plainDateTime) === 0)
    return dateTime;
  let ms2 = (0, $11d87f3f76e88657$export$5107c82f94518f5c)(res, dateTime.timeZone, disambiguation);
  return (0, $11d87f3f76e88657$export$b4a036af3fc0b032)((0, $11d87f3f76e88657$export$1b96692a1ba042ac)(ms2, dateTime.timeZone), dateTime.calendar);
}

// node_modules/@internationalized/date/dist/string.mjs
var $fae977aafc393c5c$var$DATE_RE = /^(\d{4})-(\d{2})-(\d{2})$/;
var $fae977aafc393c5c$var$requiredDurationTimeGroups = [
  "hours",
  "minutes",
  "seconds"
];
var $fae977aafc393c5c$var$requiredDurationGroups = [
  "years",
  "months",
  "weeks",
  "days",
  ...$fae977aafc393c5c$var$requiredDurationTimeGroups
];
function $fae977aafc393c5c$export$6b862160d295c8e(value) {
  let m = value.match($fae977aafc393c5c$var$DATE_RE);
  if (!m)
    throw new Error("Invalid ISO 8601 date string: " + value);
  let date = new (0, $35ea8db9cb2ccb90$export$99faa760c7908e4f)($fae977aafc393c5c$var$parseNumber(m[1], 0, 9999), $fae977aafc393c5c$var$parseNumber(m[2], 1, 12), 1);
  date.day = $fae977aafc393c5c$var$parseNumber(m[3], 0, date.calendar.getDaysInMonth(date));
  return date;
}
function $fae977aafc393c5c$var$parseNumber(value, min3, max3) {
  let val = Number(value);
  if (val < min3 || val > max3)
    throw new RangeError(`Value out of range: ${min3} <= ${val} <= ${max3}`);
  return val;
}
function $fae977aafc393c5c$export$f59dee82248f5ad4(time) {
  return `${String(time.hour).padStart(2, "0")}:${String(time.minute).padStart(2, "0")}:${String(time.second).padStart(2, "0")}${time.millisecond ? String(time.millisecond / 1e3).slice(1) : ""}`;
}
function $fae977aafc393c5c$export$60dfd74aa96791bd(date) {
  let gregorianDate = (0, $11d87f3f76e88657$export$b4a036af3fc0b032)(date, new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)());
  return `${String(gregorianDate.year).padStart(4, "0")}-${String(gregorianDate.month).padStart(2, "0")}-${String(gregorianDate.day).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$4223de14708adc63(date) {
  return `${$fae977aafc393c5c$export$60dfd74aa96791bd(date)}T${$fae977aafc393c5c$export$f59dee82248f5ad4(date)}`;
}
function $fae977aafc393c5c$var$offsetToString(offset3) {
  let sign2 = Math.sign(offset3) < 0 ? "-" : "+";
  offset3 = Math.abs(offset3);
  let offsetHours = Math.floor(offset3 / 36e5);
  let offsetMinutes = offset3 % 36e5 / 6e4;
  return `${sign2}${String(offsetHours).padStart(2, "0")}:${String(offsetMinutes).padStart(2, "0")}`;
}
function $fae977aafc393c5c$export$bf79f1ebf4b18792(date) {
  return `${$fae977aafc393c5c$export$4223de14708adc63(date)}${$fae977aafc393c5c$var$offsetToString(date.offset)}[${date.timeZone}]`;
}

// node_modules/@swc/helpers/esm/_check_private_redeclaration.js
function _check_private_redeclaration(obj, privateCollection) {
  if (privateCollection.has(obj)) {
    throw new TypeError("Cannot initialize the same private elements twice on an object");
  }
}

// node_modules/@swc/helpers/esm/_class_private_field_init.js
function _class_private_field_init(obj, privateMap, value) {
  _check_private_redeclaration(obj, privateMap);
  privateMap.set(obj, value);
}

// node_modules/@internationalized/date/dist/CalendarDate.mjs
function $35ea8db9cb2ccb90$var$shiftArgs(args) {
  let calendar = typeof args[0] === "object" ? args.shift() : new (0, $3b62074eb05584b2$export$80ee6245ec4f29ec)();
  let era;
  if (typeof args[0] === "string")
    era = args.shift();
  else {
    let eras = calendar.getEras();
    era = eras[eras.length - 1];
  }
  let year = args.shift();
  let month = args.shift();
  let day = args.shift();
  return [
    calendar,
    era,
    year,
    month,
    day
  ];
}
var $35ea8db9cb2ccb90$var$_type = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$99faa760c7908e4f = class _$35ea8db9cb2ccb90$export$99faa760c7908e4f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era)
      return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.era, this.year, this.month, this.day);
    else
      return new _$35ea8db9cb2ccb90$export$99faa760c7908e4f(this.calendar, this.year, this.month, this.day);
  }
  /** Returns a new `CalendarDate` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDate` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)(this, fields);
  }
  /**
  * Returns a new `CalendarDate` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object, with the time set to midnight in the given time zone. */
  toDate(timeZone) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$60dfd74aa96791bd)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    return (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b2);
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type2 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$ca871e8dbb80966f = class _$35ea8db9cb2ccb90$export$ca871e8dbb80966f {
  /** Returns a copy of this date. */
  copy() {
    if (this.era)
      return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.era, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
    else
      return new _$35ea8db9cb2ccb90$export$ca871e8dbb80966f(this.calendar, this.year, this.month, this.day, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `CalendarDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$e16d8520af44a096)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$4e2d2ead65e5f7e3)(this, duration);
  }
  /** Returns a new `CalendarDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields) {
    return (0, $735220c2d4774dd3$export$adaa4cf7ef1b65be)((0, $735220c2d4774dd3$export$e5d5e1c1822b6e56)(this, fields), fields);
  }
  /**
  * Returns a new `CalendarDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    switch (field) {
      case "era":
      case "year":
      case "month":
      case "day":
        return (0, $735220c2d4774dd3$export$d52ced6badfb9a4c)(this, field, amount, options);
      default:
        return (0, $735220c2d4774dd3$export$dd02b3e0007dfe28)(this, field, amount, options);
    }
  }
  /** Converts the date to a native JavaScript Date object in the given time zone. */
  toDate(timeZone, disambiguation) {
    return (0, $11d87f3f76e88657$export$e67a095c620b86fe)(this, timeZone, disambiguation);
  }
  /** Converts the date to an ISO 8601 formatted string. */
  toString() {
    return (0, $fae977aafc393c5c$export$4223de14708adc63)(this);
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    let res = (0, $14e0f24ef4ac5c92$export$68781ddf31c0090f)(this, b2);
    if (res === 0)
      return (0, $14e0f24ef4ac5c92$export$c19a80a9721b80f6)(this, (0, $11d87f3f76e88657$export$b21e0b124e224484)(b2));
    return res;
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type2, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};
var $35ea8db9cb2ccb90$var$_type3 = /* @__PURE__ */ new WeakMap();
var $35ea8db9cb2ccb90$export$d3b7288e7994edea = class _$35ea8db9cb2ccb90$export$d3b7288e7994edea {
  /** Returns a copy of this date. */
  copy() {
    if (this.era)
      return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.era, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
    else
      return new _$35ea8db9cb2ccb90$export$d3b7288e7994edea(this.calendar, this.year, this.month, this.day, this.timeZone, this.offset, this.hour, this.minute, this.second, this.millisecond);
  }
  /** Returns a new `ZonedDateTime` with the given duration added to it. */
  add(duration) {
    return (0, $735220c2d4774dd3$export$96b1d28349274637)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given duration subtracted from it. */
  subtract(duration) {
    return (0, $735220c2d4774dd3$export$6814caac34ca03c7)(this, duration);
  }
  /** Returns a new `ZonedDateTime` with the given fields set to the provided values. Other fields will be constrained accordingly. */
  set(fields, disambiguation) {
    return (0, $735220c2d4774dd3$export$31b5430eb18be4f8)(this, fields, disambiguation);
  }
  /**
  * Returns a new `ZonedDateTime` with the given field adjusted by a specified amount.
  * When the resulting value reaches the limits of the field, it wraps around.
  */
  cycle(field, amount, options) {
    return (0, $735220c2d4774dd3$export$9a297d111fc86b79)(this, field, amount, options);
  }
  /** Converts the date to a native JavaScript Date object. */
  toDate() {
    return (0, $11d87f3f76e88657$export$83aac07b4c37b25)(this);
  }
  /** Converts the date to an ISO 8601 formatted string, including the UTC offset and time zone identifier. */
  toString() {
    return (0, $fae977aafc393c5c$export$bf79f1ebf4b18792)(this);
  }
  /** Converts the date to an ISO 8601 formatted string in UTC. */
  toAbsoluteString() {
    return this.toDate().toISOString();
  }
  /** Compares this date with another. A negative result indicates that this date is before the given one, and a positive date indicates that it is after. */
  compare(b2) {
    return this.toDate().getTime() - (0, $11d87f3f76e88657$export$84c95a83c799e074)(b2, this.timeZone).toDate().getTime();
  }
  constructor(...args) {
    (0, _class_private_field_init)(this, $35ea8db9cb2ccb90$var$_type3, {
      writable: true,
      value: void 0
    });
    let [calendar, era, year, month, day] = $35ea8db9cb2ccb90$var$shiftArgs(args);
    let timeZone = args.shift();
    let offset3 = args.shift();
    this.calendar = calendar;
    this.era = era;
    this.year = year;
    this.month = month;
    this.day = day;
    this.timeZone = timeZone;
    this.offset = offset3;
    this.hour = args.shift() || 0;
    this.minute = args.shift() || 0;
    this.second = args.shift() || 0;
    this.millisecond = args.shift() || 0;
    (0, $735220c2d4774dd3$export$c4e2ecac49351ef2)(this);
  }
};

// node_modules/@internationalized/date/dist/HebrewCalendar.mjs
var $7c5f6fbf42389787$var$HOUR_PARTS = 1080;
var $7c5f6fbf42389787$var$DAY_PARTS = 24 * $7c5f6fbf42389787$var$HOUR_PARTS;
var $7c5f6fbf42389787$var$MONTH_DAYS = 29;
var $7c5f6fbf42389787$var$MONTH_FRACT = 12 * $7c5f6fbf42389787$var$HOUR_PARTS + 793;
var $7c5f6fbf42389787$var$MONTH_PARTS = $7c5f6fbf42389787$var$MONTH_DAYS * $7c5f6fbf42389787$var$DAY_PARTS + $7c5f6fbf42389787$var$MONTH_FRACT;

// node_modules/@internationalized/date/dist/DateFormatter.mjs
var $fb18d541ea1ad717$var$formatterCache = /* @__PURE__ */ new Map();
var $fb18d541ea1ad717$export$ad991b66133851cf = class {
  /** Formats a date as a string according to the locale and format options passed to the constructor. */
  format(value) {
    return this.formatter.format(value);
  }
  /** Formats a date to an array of parts such as separators, numbers, punctuation, and more. */
  formatToParts(value) {
    return this.formatter.formatToParts(value);
  }
  /** Formats a date range as a string. */
  formatRange(start, end) {
    if (typeof this.formatter.formatRange === "function")
      return this.formatter.formatRange(start, end);
    if (end < start)
      throw new RangeError("End date must be >= start date");
    return `${this.formatter.format(start)}  ${this.formatter.format(end)}`;
  }
  /** Formats a date range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.formatter.formatRangeToParts === "function")
      return this.formatter.formatRangeToParts(start, end);
    if (end < start)
      throw new RangeError("End date must be >= start date");
    let startParts = this.formatter.formatToParts(start);
    let endParts = this.formatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let resolvedOptions = this.formatter.resolvedOptions();
    if ($fb18d541ea1ad717$var$hasBuggyResolvedHourCycle()) {
      if (!this.resolvedHourCycle)
        this.resolvedHourCycle = $fb18d541ea1ad717$var$getResolvedHourCycle(resolvedOptions.locale, this.options);
      resolvedOptions.hourCycle = this.resolvedHourCycle;
      resolvedOptions.hour12 = this.resolvedHourCycle === "h11" || this.resolvedHourCycle === "h12";
    }
    if (resolvedOptions.calendar === "ethiopic-amete-alem")
      resolvedOptions.calendar = "ethioaa";
    return resolvedOptions;
  }
  constructor(locale, options = {}) {
    this.formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options);
    this.options = options;
  }
};
var $fb18d541ea1ad717$var$hour12Preferences = {
  true: {
    // Only Japanese uses the h11 style for 12 hour time. All others use h12.
    ja: "h11"
  },
  false: {}
};
function $fb18d541ea1ad717$var$getCachedDateFormatter(locale, options = {}) {
  if (typeof options.hour12 === "boolean" && $fb18d541ea1ad717$var$hasBuggyHour12Behavior()) {
    options = {
      ...options
    };
    let pref = $fb18d541ea1ad717$var$hour12Preferences[String(options.hour12)][locale.split("-")[0]];
    let defaultHourCycle = options.hour12 ? "h12" : "h23";
    options.hourCycle = pref !== null && pref !== void 0 ? pref : defaultHourCycle;
    delete options.hour12;
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($fb18d541ea1ad717$var$formatterCache.has(cacheKey))
    return $fb18d541ea1ad717$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.DateTimeFormat(locale, options);
  $fb18d541ea1ad717$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
var $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = null;
function $fb18d541ea1ad717$var$hasBuggyHour12Behavior() {
  if ($fb18d541ea1ad717$var$_hasBuggyHour12Behavior == null)
    $fb18d541ea1ad717$var$_hasBuggyHour12Behavior = new Intl.DateTimeFormat("en-US", {
      hour: "numeric",
      hour12: false
    }).format(new Date(2020, 2, 3, 0)) === "24";
  return $fb18d541ea1ad717$var$_hasBuggyHour12Behavior;
}
var $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = null;
function $fb18d541ea1ad717$var$hasBuggyResolvedHourCycle() {
  if ($fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle == null)
    $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle = new Intl.DateTimeFormat("fr", {
      hour: "numeric",
      hour12: false
    }).resolvedOptions().hourCycle === "h12";
  return $fb18d541ea1ad717$var$_hasBuggyResolvedHourCycle;
}
function $fb18d541ea1ad717$var$getResolvedHourCycle(locale, options) {
  if (!options.timeStyle && !options.hour)
    return void 0;
  locale = locale.replace(/(-u-)?-nu-[a-zA-Z0-9]+/, "");
  locale += (locale.includes("-u-") ? "" : "-u") + "-nu-latn";
  let formatter = $fb18d541ea1ad717$var$getCachedDateFormatter(locale, {
    ...options,
    timeZone: void 0
    // use local timezone
  });
  let min3 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 0)).find((p) => p.type === "hour").value, 10);
  let max3 = parseInt(formatter.formatToParts(new Date(2020, 2, 3, 23)).find((p) => p.type === "hour").value, 10);
  if (min3 === 0 && max3 === 23)
    return "h23";
  if (min3 === 24 && max3 === 23)
    return "h24";
  if (min3 === 0 && max3 === 11)
    return "h11";
  if (min3 === 12 && max3 === 11)
    return "h12";
  throw new Error("Unexpected hour cycle result");
}

// node_modules/@zag-js/date-utils/dist/index.mjs
function alignCenter(date, duration, locale, min3, max3) {
  let halfDuration = {};
  for (let key in duration) {
    halfDuration[key] = Math.floor(duration[key] / 2);
    if (halfDuration[key] > 0 && duration[key] % 2 === 0) {
      halfDuration[key]--;
    }
  }
  let aligned = alignStart(date, duration, locale).subtract(halfDuration);
  return constrainStart(date, aligned, duration, locale, min3, max3);
}
function alignStart(date, duration, locale, min3, max3) {
  let aligned = date;
  if (duration.years) {
    aligned = $14e0f24ef4ac5c92$export$f91e89d3d0406102(date);
  } else if (duration.months) {
    aligned = $14e0f24ef4ac5c92$export$a5a3b454ada2268e(date);
  } else if (duration.weeks) {
    aligned = $14e0f24ef4ac5c92$export$42c81a444fbfb5d4(date, locale);
  }
  return constrainStart(date, aligned, duration, locale, min3, max3);
}
function alignEnd(date, duration, locale, min3, max3) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else if (d.weeks) {
    d.weeks--;
  } else if (d.months) {
    d.months--;
  } else if (d.years) {
    d.years--;
  }
  let aligned = alignStart(date, duration, locale).subtract(d);
  return constrainStart(date, aligned, duration, locale, min3, max3);
}
function constrainStart(date, aligned, duration, locale, min3, max3) {
  if (min3 && date.compare(min3) >= 0) {
    aligned = $14e0f24ef4ac5c92$export$a75f2bff57811055(aligned, alignStart($11d87f3f76e88657$export$93522d1a439f3617(min3), duration, locale));
  }
  if (max3 && date.compare(max3) <= 0) {
    aligned = $14e0f24ef4ac5c92$export$5c333a116e949cdd(aligned, alignEnd($11d87f3f76e88657$export$93522d1a439f3617(max3), duration, locale));
  }
  return aligned;
}
function constrainValue(date, minValue, maxValue) {
  if (minValue) {
    date = $14e0f24ef4ac5c92$export$a75f2bff57811055(date, $11d87f3f76e88657$export$93522d1a439f3617(minValue));
  }
  if (maxValue) {
    date = $14e0f24ef4ac5c92$export$5c333a116e949cdd(date, $11d87f3f76e88657$export$93522d1a439f3617(maxValue));
  }
  return date;
}
function alignDate(date, alignment, duration, locale, min3, max3) {
  switch (alignment) {
    case "start":
      return alignStart(date, duration, locale, min3, max3);
    case "end":
      return alignEnd(date, duration, locale, min3, max3);
    case "center":
    default:
      return alignCenter(date, duration, locale, min3, max3);
  }
}
function isTodayDate(date, timeZone) {
  return $14e0f24ef4ac5c92$export$629b0a497aa65267(date, timeZone);
}
function isDateEqual(dateA, dateB) {
  return dateB != null && $14e0f24ef4ac5c92$export$ea39ec197993aef0(dateA, dateB);
}
function isDateInvalid(date, minValue, maxValue) {
  return minValue != null && date.compare(minValue) < 0 || maxValue != null && date.compare(maxValue) > 0;
}
function isDateDisabled(date, startDate, endDate, minValue, maxValue) {
  return isDateOutsideVisibleRange(date, startDate, endDate) || isDateInvalid(date, minValue, maxValue);
}
function isDateUnavailable(date, isUnavailable, locale, minValue, maxValue) {
  if (!date) {
    return false;
  }
  if (isUnavailable == null ? void 0 : isUnavailable(date, locale)) {
    return true;
  }
  return isDateInvalid(date, minValue, maxValue);
}
function isDateOutsideVisibleRange(date, startDate, endDate) {
  return date.compare(startDate) < 0 || date.compare(endDate) > 0;
}
function isPreviousVisibleRangeInvalid(startDate, minValue, maxValue) {
  const prevDate = startDate.subtract({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(prevDate, startDate) || isDateInvalid(prevDate, minValue, maxValue);
}
function isNextVisibleRangeInvalid(endDate, minValue, maxValue) {
  const nextDate = endDate.add({ days: 1 });
  return $14e0f24ef4ac5c92$export$ea39ec197993aef0(nextDate, endDate) || isDateInvalid(nextDate, minValue, maxValue);
}
function getUnitDuration(duration) {
  let d = { ...duration };
  for (let key in d) {
    d[key] = 1;
  }
  return d;
}
function getEndDate(startDate, duration) {
  let d = { ...duration };
  if (d.days) {
    d.days--;
  } else {
    d.days = -1;
  }
  return startDate.add(d);
}
function formatRange(startDate, endDate, formatter, toString, timeZone) {
  let parts34 = formatter.formatRangeToParts(startDate.toDate(timeZone), endDate.toDate(timeZone));
  let separatorIndex = -1;
  for (let i = 0; i < parts34.length; i++) {
    let part = parts34[i];
    if (part.source === "shared" && part.type === "literal") {
      separatorIndex = i;
    } else if (part.source === "endRange") {
      break;
    }
  }
  let start = "";
  let end = "";
  for (let i = 0; i < parts34.length; i++) {
    if (i < separatorIndex) {
      start += parts34[i].value;
    } else if (i > separatorIndex) {
      end += parts34[i].value;
    }
  }
  return toString(start, end);
}
function getEraFormat(date) {
  return (date == null ? void 0 : date.calendar.identifier) === "gregory" && date.era === "BC" ? "short" : void 0;
}
function getDayFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$b21e0b124e224484($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    weekday: "long",
    month: "long",
    year: "numeric",
    day: "numeric",
    era: getEraFormat(date),
    timeZone
  });
}
function formatSelectedDate(startDate, endDate, locale, timeZone) {
  let start = startDate;
  let end = endDate ?? startDate;
  let formatter = getDayFormatter(locale, timeZone);
  if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(start, end)) {
    return formatter.format(start.toDate(timeZone));
  }
  return formatRange(start, end, formatter, (start2, end2) => `${start2}  ${end2}`, timeZone);
}
function getMonthFormatter(locale, timeZone) {
  const date = $11d87f3f76e88657$export$93522d1a439f3617($14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone));
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, {
    month: "long",
    year: "numeric",
    era: getEraFormat(date),
    calendar: date == null ? void 0 : date.calendar.identifier,
    timeZone
  });
}
function getDecadeRange(year) {
  const computedYear = year - year % 10 - 1;
  const years = [];
  for (let i = 0; i < 12; i += 1) {
    const value = computedYear + i;
    years.push(value);
  }
  return years;
}
function getStartOfWeek(date, locale, firstDayOfWeek = 0) {
  const day = $14e0f24ef4ac5c92$export$2061056d06d7cdf7(date, locale);
  const diff = (day - firstDayOfWeek + 7) % 7;
  return date.subtract({ days: diff });
}
function getDaysInWeek(weekIndex, from, locale, firstDayOfWeek) {
  const weekDate = from.add({ weeks: weekIndex });
  const dates = [];
  let date = getStartOfWeek(weekDate, locale, firstDayOfWeek);
  while (dates.length < 7) {
    dates.push(date);
    let nextDate = date.add({ days: 1 });
    if ($14e0f24ef4ac5c92$export$ea39ec197993aef0(date, nextDate)) {
      break;
    }
    date = nextDate;
  }
  return dates;
}
function getCustomWeeksInMonth(from, locale, firstDayOfWeek) {
  if (firstDayOfWeek == null) {
    return $14e0f24ef4ac5c92$export$ccc1b2479e7dd654(from, locale);
  }
  const paddingDays = ($14e0f24ef4ac5c92$export$2061056d06d7cdf7($14e0f24ef4ac5c92$export$a5a3b454ada2268e(from), locale) - firstDayOfWeek + 7) % 7;
  return Math.ceil((paddingDays + from.calendar.getDaysInMonth(from)) / 7);
}
function getMonthDays(from, locale, numOfWeeks, firstDayOfWeek) {
  const monthWeeks = numOfWeeks ?? getCustomWeeksInMonth(from, locale, firstDayOfWeek);
  const weeks = [...new Array(monthWeeks).keys()];
  return weeks.map((week) => getDaysInWeek(week, from, locale, firstDayOfWeek));
}
function getMonthNames(locale, format = "long") {
  const date = new Date(2021, 0, 1);
  const monthNames = [];
  for (let i = 0; i < 12; i++) {
    monthNames.push(date.toLocaleString(locale, { month: format }));
    date.setMonth(date.getMonth() + 1);
  }
  return monthNames;
}
function getWeekdayFormats(locale, timeZone) {
  const longFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "long", timeZone });
  const shortFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "short", timeZone });
  const narrowFormat = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { weekday: "narrow", timeZone });
  return (value) => {
    const date = value instanceof Date ? value : value.toDate(timeZone);
    return {
      value,
      short: shortFormat.format(date),
      long: longFormat.format(date),
      narrow: narrowFormat.format(date)
    };
  };
}
function getWeekDays(date, startOfWeekProp, timeZone, locale) {
  const firstDayOfWeek = getStartOfWeek(date, locale, startOfWeekProp);
  const weeks = [...new Array(7).keys()];
  const format = getWeekdayFormats(locale, timeZone);
  return weeks.map((index) => format(firstDayOfWeek.add({ days: index })));
}
function getTodayDate(timeZone) {
  return $14e0f24ef4ac5c92$export$d0bdf45af03a6ea3(timeZone ?? $14e0f24ef4ac5c92$export$aa8b41735afcabd2());
}
function getNextDay(date) {
  return date.add({ days: 1 });
}
function getPreviousDay(date) {
  return date.subtract({ days: 1 });
}
function setMonth(date, month) {
  return date.set({ month });
}
function setYear(date, year) {
  return date.set({ year });
}
function getAdjustedDateFn(visibleDuration, locale, minValue, maxValue) {
  return function getDate(options) {
    const { startDate, focusedDate } = options;
    const endDate = getEndDate(startDate, visibleDuration);
    if (isDateInvalid(focusedDate, minValue, maxValue)) {
      return {
        startDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(startDate) < 0) {
      return {
        startDate: alignEnd(focusedDate, visibleDuration, locale, minValue, maxValue),
        focusedDate: constrainValue(focusedDate, minValue, maxValue),
        endDate
      };
    }
    if (focusedDate.compare(endDate) > 0) {
      return {
        startDate: alignStart(focusedDate, visibleDuration, locale, minValue, maxValue),
        endDate,
        focusedDate: constrainValue(focusedDate, minValue, maxValue)
      };
    }
    return {
      startDate,
      endDate,
      focusedDate: constrainValue(focusedDate, minValue, maxValue)
    };
  };
}
function getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  const start = startDate.add(visibleDuration);
  return adjust({
    focusedDate: focusedDate.add(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  let start = startDate.subtract(visibleDuration);
  return adjust({
    focusedDate: focusedDate.subtract(visibleDuration),
    startDate: alignStart(
      constrainStart(focusedDate, start, visibleDuration, locale, minValue, maxValue),
      visibleDuration,
      locale
    )
  });
}
function getNextSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.add(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getNextPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.add({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.add({ years: 1 }),
      startDate
    });
  }
}
function getPreviousSection(focusedDate, startDate, larger, visibleDuration, locale, minValue, maxValue) {
  const adjust = getAdjustedDateFn(visibleDuration, locale, minValue, maxValue);
  if (!larger && !visibleDuration.days) {
    return adjust({
      focusedDate: focusedDate.subtract(getUnitDuration(visibleDuration)),
      startDate
    });
  }
  if (visibleDuration.days) {
    return getPreviousPage(focusedDate, startDate, visibleDuration, locale, minValue, maxValue);
  }
  if (visibleDuration.weeks) {
    return adjust({
      focusedDate: focusedDate.subtract({ months: 1 }),
      startDate
    });
  }
  if (visibleDuration.months || visibleDuration.years) {
    return adjust({
      focusedDate: focusedDate.subtract({ years: 1 }),
      startDate
    });
  }
}
var isValidYear = (year) => year != null && year.length === 4;
var isValidMonth = (month) => month != null && parseFloat(month) <= 12;
var isValidDay = (day) => day != null && parseFloat(day) <= 31;
function parseDateString(date, locale, timeZone) {
  const regex = createRegex(locale, timeZone);
  let { year, month, day } = extract(regex, date) ?? {};
  const hasMatch = year != null || month != null || day != null;
  if (hasMatch) {
    const curr = /* @__PURE__ */ new Date();
    year || (year = curr.getFullYear().toString());
    month || (month = (curr.getMonth() + 1).toString());
    day || (day = curr.getDate().toString());
  }
  if (isValidYear(year) && isValidMonth(month) && isValidDay(day)) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(+year, +month, +day);
  }
  const time = Date.parse(date);
  if (!isNaN(time)) {
    const date2 = new Date(time);
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(date2.getFullYear(), date2.getMonth() + 1, date2.getDate());
  }
}
function createRegex(locale, timeZone) {
  const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(locale, { day: "numeric", month: "numeric", year: "numeric", timeZone });
  const parts34 = formatter.formatToParts(new Date(2e3, 11, 25));
  return parts34.map(({ type, value }) => type === "literal" ? `${value}?` : `((?!=<${type}>)\\d+)?`).join("");
}
function extract(pattern, str) {
  var _a;
  const matches2 = str.match(pattern);
  return (_a = pattern.toString().match(/<(.+?)>/g)) == null ? void 0 : _a.map((group2) => {
    var _a2;
    const groupMatches = group2.match(/<(.+)>/);
    if (!groupMatches || groupMatches.length <= 0) {
      return null;
    }
    return (_a2 = group2.match(/<(.+)>/)) == null ? void 0 : _a2[1];
  }).reduce((acc, curr, index) => {
    if (!curr)
      return acc;
    if (matches2 && matches2.length > index) {
      acc[curr] = matches2[index + 1];
    } else {
      acc[curr] = null;
    }
    return acc;
  }, {});
}
function getDateRangePreset(preset, locale, timeZone) {
  const today4 = $14e0f24ef4ac5c92$export$461939dd4422153(timeZone);
  switch (preset) {
    case "thisWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today4, locale), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today4, locale)];
    case "thisMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today4), today4];
    case "thisQuarter":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today4).add({ months: -today4.month % 3 }), today4];
    case "thisYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today4), today4];
    case "last3Days":
      return [today4.add({ days: -2 }), today4];
    case "last7Days":
      return [today4.add({ days: -6 }), today4];
    case "last14Days":
      return [today4.add({ days: -13 }), today4];
    case "last30Days":
      return [today4.add({ days: -29 }), today4];
    case "last90Days":
      return [today4.add({ days: -89 }), today4];
    case "lastMonth":
      return [$14e0f24ef4ac5c92$export$a5a3b454ada2268e(today4.add({ months: -1 })), $14e0f24ef4ac5c92$export$a2258d9c4118825c(today4.add({ months: -1 }))];
    case "lastQuarter":
      return [
        $14e0f24ef4ac5c92$export$a5a3b454ada2268e(today4.add({ months: -today4.month % 3 - 3 })),
        $14e0f24ef4ac5c92$export$a2258d9c4118825c(today4.add({ months: -today4.month % 3 - 1 }))
      ];
    case "lastWeek":
      return [$14e0f24ef4ac5c92$export$42c81a444fbfb5d4(today4, locale).add({ weeks: -1 }), $14e0f24ef4ac5c92$export$ef8b6d9133084f4e(today4, locale).add({ weeks: -1 })];
    case "lastYear":
      return [$14e0f24ef4ac5c92$export$f91e89d3d0406102(today4.add({ years: -1 })), $14e0f24ef4ac5c92$export$8b7aa55c66d5569e(today4.add({ years: -1 }))];
    default:
      throw new Error(`Invalid date range preset: ${preset}`);
  }
}

// node_modules/@zag-js/live-region/dist/index.mjs
var ID = "__live-region__";
function createLiveRegion(opts = {}) {
  const { level = "polite", document: doc = document, root, delay: _delay = 0 } = opts;
  const win = doc.defaultView ?? window;
  const parent = root ?? doc.body;
  function announce(message, delay3) {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
    delay3 = delay3 ?? _delay;
    const region = doc.createElement("span");
    region.id = ID;
    region.dataset.liveAnnouncer = "true";
    const role = level !== "assertive" ? "status" : "alert";
    region.setAttribute("aria-live", level);
    region.setAttribute("role", role);
    Object.assign(region.style, {
      border: "0",
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: "0",
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    });
    parent.appendChild(region);
    win.setTimeout(() => {
      region.textContent = message;
    }, delay3);
  }
  function destroy() {
    const oldRegion = doc.getElementById(ID);
    oldRegion == null ? void 0 : oldRegion.remove();
  }
  return {
    announce,
    destroy,
    toJSON() {
      return ID;
    }
  };
}

// node_modules/@zag-js/date-picker/dist/index.mjs
var anatomy12 = createAnatomy("date-picker").parts(
  "root",
  "label",
  "clearTrigger",
  "content",
  "control",
  "input",
  "monthSelect",
  "nextTrigger",
  "positioner",
  "prevTrigger",
  "rangeText",
  "table",
  "tableBody",
  "tableCell",
  "tableCellTrigger",
  "tableHead",
  "tableHeader",
  "tableRow",
  "trigger",
  "viewTrigger",
  "viewControl",
  "yearSelect",
  "presetTrigger"
);
var parts9 = anatomy12.build();
var dom9 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `datepicker:${ctx.id}`;
  },
  getTableId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.table) == null ? void 0 : _b.call(_a, id)) ?? `datepicker:${ctx.id}:table:${id}`;
  },
  getTableHeaderId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.tableHeader) == null ? void 0 : _b.call(_a, id)) ?? `datepicker:${ctx.id}:thead`;
  },
  getTableBodyId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.tableBody) == null ? void 0 : _b.call(_a, id)) ?? `datepicker:${ctx.id}:tbody`;
  },
  getTableRowId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.tableRow) == null ? void 0 : _b.call(_a, id)) ?? `datepicker:${ctx.id}:tr:${id}`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `datepicker:${ctx.id}:content`;
  },
  getCellTriggerId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.cellTrigger) == null ? void 0 : _b.call(_a, id)) ?? `datepicker:${ctx.id}:cell-trigger:${id}`;
  },
  getPrevTriggerId: (ctx, view) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.prevTrigger) == null ? void 0 : _b.call(_a, view)) ?? `datepicker:${ctx.id}:prev:${view}`;
  },
  getNextTriggerId: (ctx, view) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.nextTrigger) == null ? void 0 : _b.call(_a, view)) ?? `datepicker:${ctx.id}:next:${view}`;
  },
  getViewTriggerId: (ctx, view) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.viewTrigger) == null ? void 0 : _b.call(_a, view)) ?? `datepicker:${ctx.id}:view:${view}`;
  },
  getClearTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.clearTrigger) ?? `datepicker:${ctx.id}:clear`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `datepicker:${ctx.id}:control`;
  },
  getInputId: (ctx, index) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.input) == null ? void 0 : _b.call(_a, index)) ?? `datepicker:${ctx.id}:input:${index}`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `datepicker:${ctx.id}:trigger`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `datepicker:${ctx.id}:positioner`;
  },
  getMonthSelectId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.monthSelect) ?? `datepicker:${ctx.id}:month-select`;
  },
  getYearSelectId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.yearSelect) ?? `datepicker:${ctx.id}:year-select`;
  },
  getFocusedCell: (ctx, view = ctx.view) => query(
    dom9.getContentEl(ctx),
    `[data-part=table-cell-trigger][data-view=${view}][data-focus]:not([data-outside-range])`
  ),
  getTriggerEl: (ctx) => dom9.getById(ctx, dom9.getTriggerId(ctx)),
  getContentEl: (ctx) => dom9.getById(ctx, dom9.getContentId(ctx)),
  getInputEls: (ctx) => queryAll(dom9.getControlEl(ctx), `[data-part=input]`),
  getYearSelectEl: (ctx) => dom9.getById(ctx, dom9.getYearSelectId(ctx)),
  getMonthSelectEl: (ctx) => dom9.getById(ctx, dom9.getMonthSelectId(ctx)),
  getClearTriggerEl: (ctx) => dom9.getById(ctx, dom9.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom9.getById(ctx, dom9.getPositionerId(ctx)),
  getControlEl: (ctx) => dom9.getById(ctx, dom9.getControlId(ctx))
});
function adjustStartAndEndDate(value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate)
    return value;
  return startDate.compare(endDate) <= 0 ? value : [endDate, startDate];
}
function isDateWithinRange(date, value) {
  const [startDate, endDate] = value;
  if (!startDate || !endDate)
    return false;
  return startDate.compare(date) <= 0 && endDate.compare(date) >= 0;
}
function sortDates(values) {
  return values.sort((a2, b2) => a2.compare(b2));
}
function getNextTriggerLabel(view) {
  return match2(view, {
    year: "Switch to next decade",
    month: "Switch to next year",
    day: "Switch to next month"
  });
}
function getPrevTriggerLabel(view) {
  return match2(view, {
    year: "Switch to previous decade",
    month: "Switch to previous year",
    day: "Switch to previous month"
  });
}
function getRoleDescription(view) {
  return match2(view, {
    year: "calendar decade",
    month: "calendar year",
    day: "calendar month"
  });
}
function getViewTriggerLabel(view) {
  return match2(view, {
    year: "Switch to month view",
    month: "Switch to day view",
    day: "Switch to year view"
  });
}
var PLACEHOLDERS = { day: "dd", month: "mm", year: "yyyy" };
function getInputPlaceholder(locale) {
  return new $fb18d541ea1ad717$export$ad991b66133851cf(locale).formatToParts(/* @__PURE__ */ new Date()).map((item) => PLACEHOLDERS[item.type] ?? item.value).join("");
}
var isValidCharacter = (char, separator) => {
  if (!char)
    return true;
  return /\d/.test(char) || char === separator || char.length !== 1;
};
var ensureValidCharacters = (value, separator) => {
  return value.split("").filter((char) => isValidCharacter(char, separator)).join("");
};
function getLocaleSeparator(locale) {
  const dateFormatter = new Intl.DateTimeFormat(locale);
  const parts210 = dateFormatter.formatToParts(/* @__PURE__ */ new Date());
  const literalPart = parts210.find((part) => part.type === "literal");
  return literalPart ? literalPart.value : "/";
}
var pretty = (value) => value.toString().split("T")[0];
function connect9(state2, send, normalize) {
  const startValue = state2.context.startValue;
  const endValue = state2.context.endValue;
  const selectedValue = state2.context.value;
  const focusedValue = state2.context.focusedValue;
  const hoveredValue = state2.context.hoveredValue;
  const hoveredRangeValue = hoveredValue ? adjustStartAndEndDate([selectedValue[0], hoveredValue]) : [];
  const disabled = state2.context.disabled;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const min3 = state2.context.min;
  const max3 = state2.context.max;
  const locale = state2.context.locale;
  const timeZone = state2.context.timeZone;
  const startOfWeek = state2.context.startOfWeek;
  const focused = state2.matches("focused");
  const open = state2.matches("open");
  const isRangePicker = state2.context.selectionMode === "range";
  const isDateUnavailableFn = state2.context.isDateUnavailable;
  const currentPlacement = state2.context.currentPlacement;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  const separator = getLocaleSeparator(locale);
  function getMonthWeeks(from = startValue) {
    const numOfWeeks = state2.context.fixedWeeks ? 6 : void 0;
    return getMonthDays(from, locale, numOfWeeks, startOfWeek);
  }
  function getMonths(props29 = {}) {
    const { format } = props29;
    return getMonthNames(locale, format).map((label, index) => ({ label, value: index + 1 }));
  }
  function getYears() {
    return getDecadeRange(focusedValue.year).map((year) => ({
      label: year.toString(),
      value: year
    }));
  }
  function isUnavailable(date) {
    return isDateUnavailable(date, isDateUnavailableFn, locale, min3, max3);
  }
  function focusMonth(month) {
    const value = setMonth(startValue ?? getTodayDate(timeZone), month);
    send({ type: "FOCUS.SET", value });
  }
  function focusYear(year) {
    const value = setYear(startValue ?? getTodayDate(timeZone), year);
    send({ type: "FOCUS.SET", value });
  }
  function getYearTableCellState(props29) {
    const { value, disabled: disabled2 } = props29;
    const normalized = focusedValue.set({ year: value });
    const cellState = {
      focused: focusedValue.year === props29.value,
      selectable: !isDateInvalid(normalized, min3, max3),
      selected: !!selectedValue.find((date) => date.year === value),
      valueText: value.toString(),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getMonthTableCellState(props29) {
    const { value, disabled: disabled2 } = props29;
    const normalized = focusedValue.set({ month: value });
    const formatter = getMonthFormatter(locale, timeZone);
    const cellState = {
      focused: focusedValue.month === props29.value,
      selectable: !isDateInvalid(normalized, min3, max3),
      selected: !!selectedValue.find((date) => date.month === value && date.year === focusedValue.year),
      valueText: formatter.format(normalized.toDate(timeZone)),
      get disabled() {
        return disabled2 || !cellState.selectable;
      }
    };
    return cellState;
  }
  function getDayTableCellState(props29) {
    const { value, disabled: disabled2, visibleRange = state2.context.visibleRange } = props29;
    const formatter = getDayFormatter(locale, timeZone);
    const unitDuration = getUnitDuration(state2.context.visibleDuration);
    const end = visibleRange.start.add(unitDuration).subtract({ days: 1 });
    const cellState = {
      invalid: isDateInvalid(value, min3, max3),
      disabled: disabled2 || isDateDisabled(value, visibleRange.start, end, min3, max3),
      selected: selectedValue.some((date) => isDateEqual(value, date)),
      unavailable: isDateUnavailable(value, isDateUnavailableFn, locale, min3, max3) && !disabled2,
      outsideRange: isDateOutsideVisibleRange(value, visibleRange.start, end),
      inRange: isRangePicker && (isDateWithinRange(value, selectedValue) || isDateWithinRange(value, hoveredRangeValue)),
      firstInRange: isRangePicker && isDateEqual(value, selectedValue[0]),
      lastInRange: isRangePicker && isDateEqual(value, selectedValue[1]),
      today: isTodayDate(value, timeZone),
      weekend: $14e0f24ef4ac5c92$export$618d60ea299da42(value, locale),
      formattedDate: formatter.format(value.toDate(timeZone)),
      get focused() {
        return isDateEqual(value, focusedValue) && !cellState.outsideRange;
      },
      get ariaLabel() {
        if (cellState.unavailable)
          return `Not available. ${cellState.formattedDate}`;
        if (cellState.selected)
          return `Selected date. ${cellState.formattedDate}`;
        return `Choose ${cellState.formattedDate}`;
      },
      get selectable() {
        return !cellState.disabled && !cellState.unavailable;
      }
    };
    return cellState;
  }
  function getTableId(props29) {
    const { view = "day", id } = props29;
    return [view, id].filter(Boolean).join(" ");
  }
  return {
    focused,
    open,
    view: state2.context.view,
    getRangePresetValue(preset) {
      return getDateRangePreset(preset, locale, timeZone);
    },
    getDaysInWeek(week, from = startValue) {
      return getDaysInWeek(week, from, locale, startOfWeek);
    },
    getOffset(duration) {
      const from = startValue.add(duration);
      return {
        visibleRange: { start: from, end: endValue.add(duration) },
        weeks: getMonthWeeks(from)
      };
    },
    getMonthWeeks,
    isUnavailable,
    weeks: getMonthWeeks(),
    weekDays: getWeekDays(getTodayDate(timeZone), startOfWeek, timeZone, locale),
    visibleRangeText: state2.context.visibleRangeText,
    value: selectedValue,
    valueAsDate: selectedValue.map((date) => date.toDate(timeZone)),
    valueAsString: selectedValue.map(pretty),
    focusedValue,
    focusedValueAsDate: focusedValue == null ? void 0 : focusedValue.toDate(timeZone),
    focusedValueAsString: pretty(focusedValue),
    visibleRange: state2.context.visibleRange,
    selectToday() {
      const value = constrainValue(getTodayDate(timeZone), min3, max3);
      send({ type: "VALUE.SET", value });
    },
    setValue(values) {
      const computedValue = values.map((date) => constrainValue(date, min3, max3));
      send({ type: "VALUE.SET", value: computedValue });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    setFocusedValue(value) {
      send({ type: "FOCUS.SET", value });
    },
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    focusMonth,
    focusYear,
    getYears,
    getMonths,
    getYearsGrid(props29 = {}) {
      const { columns = 1 } = props29;
      return chunk(getYears(), columns);
    },
    getDecade() {
      const years = getDecadeRange(focusedValue.year);
      return { start: years.at(0), end: years.at(-1) };
    },
    getMonthsGrid(props29 = {}) {
      const { columns = 1, format } = props29;
      return chunk(getMonths({ format }), columns);
    },
    format(value, opts = { month: "long", year: "numeric" }) {
      return new $fb18d541ea1ad717$export$ad991b66133851cf(locale, opts).format(value.toDate(timeZone));
    },
    setView(view) {
      send({ type: "VIEW.SET", cell: view });
    },
    goToNext() {
      send({ type: "GOTO.NEXT", view: state2.context.view });
    },
    goToPrev() {
      send({ type: "GOTO.PREV", view: state2.context.view });
    },
    getRootProps() {
      return normalize.element({
        ...parts9.root.attrs,
        dir: state2.context.dir,
        id: dom9.getRootId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts9.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom9.getInputId(state2.context, 0),
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts9.control.attrs,
        dir: state2.context.dir,
        id: dom9.getControlId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getRangeTextProps() {
      return normalize.element({
        ...parts9.rangeText.attrs,
        dir: state2.context.dir
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts9.content.attrs,
        hidden: !open,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed",
        "data-placement": currentPlacement,
        id: dom9.getContentId(state2.context),
        role: "application",
        "aria-roledescription": "datepicker",
        "aria-label": "calendar"
      });
    },
    getTableProps(props29 = {}) {
      const { view = "day", columns = view === "day" ? 7 : 4 } = props29;
      const uid = getTableId(props29);
      return normalize.element({
        ...parts9.table.attrs,
        role: "grid",
        "data-columns": columns,
        "aria-roledescription": getRoleDescription(view),
        id: dom9.getTableId(state2.context, uid),
        "aria-readonly": ariaAttr(readOnly),
        "aria-disabled": ariaAttr(disabled),
        "aria-multiselectable": ariaAttr(state2.context.selectionMode !== "single"),
        "data-view": view,
        dir: state2.context.dir,
        tabIndex: -1,
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          const keyMap2 = {
            Enter() {
              if (isUnavailable(focusedValue))
                return;
              send({ type: "TABLE.ENTER", view, columns, focus: true });
            },
            ArrowLeft() {
              send({ type: "TABLE.ARROW_LEFT", view, columns, focus: true });
            },
            ArrowRight() {
              send({ type: "TABLE.ARROW_RIGHT", view, columns, focus: true });
            },
            ArrowUp() {
              send({ type: "TABLE.ARROW_UP", view, columns, focus: true });
            },
            ArrowDown() {
              send({ type: "TABLE.ARROW_DOWN", view, columns, focus: true });
            },
            PageUp(event2) {
              send({ type: "TABLE.PAGE_UP", larger: event2.shiftKey, view, columns, focus: true });
            },
            PageDown(event2) {
              send({ type: "TABLE.PAGE_DOWN", larger: event2.shiftKey, view, columns, focus: true });
            },
            Home() {
              send({ type: "TABLE.HOME", view, columns, focus: true });
            },
            End() {
              send({ type: "TABLE.END", view, columns, focus: true });
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        },
        onPointerLeave() {
          send({ type: "TABLE.POINTER_LEAVE" });
        },
        onPointerDown() {
          send({ type: "TABLE.POINTER_DOWN", view });
        },
        onPointerUp() {
          send({ type: "TABLE.POINTER_UP", view });
        }
      });
    },
    getTableHeadProps(props29 = {}) {
      const { view = "day" } = props29;
      return normalize.element({
        ...parts9.tableHead.attrs,
        "aria-hidden": true,
        dir: state2.context.dir,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableHeaderProps(props29 = {}) {
      const { view = "day" } = props29;
      return normalize.element({
        ...parts9.tableHeader.attrs,
        dir: state2.context.dir,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableBodyProps(props29 = {}) {
      const { view = "day" } = props29;
      return normalize.element({
        ...parts9.tableBody.attrs,
        "data-view": view,
        "data-disabled": dataAttr(disabled)
      });
    },
    getTableRowProps(props29 = {}) {
      const { view = "day" } = props29;
      return normalize.element({
        ...parts9.tableRow.attrs,
        "aria-disabled": ariaAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "data-view": view
      });
    },
    getDayTableCellState,
    getDayTableCellProps(props29) {
      const { value } = props29;
      const cellState = getDayTableCellState(props29);
      return normalize.element({
        ...parts9.tableCell.attrs,
        role: "gridcell",
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-selected": cellState.selected || cellState.inRange,
        "aria-invalid": ariaAttr(cellState.invalid),
        "aria-current": cellState.today ? "date" : void 0,
        "data-value": value.toString()
      });
    },
    getDayTableCellTriggerProps(props29) {
      const { value } = props29;
      const cellState = getDayTableCellState(props29);
      return normalize.element({
        ...parts9.tableCellTrigger.attrs,
        id: dom9.getCellTriggerId(state2.context, value.toString()),
        role: "button",
        dir: state2.context.dir,
        tabIndex: cellState.focused ? 0 : -1,
        "aria-label": cellState.ariaLabel,
        "aria-disabled": ariaAttr(!cellState.selectable),
        "aria-invalid": ariaAttr(cellState.invalid),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-selected": dataAttr(cellState.selected),
        "data-value": value.toString(),
        "data-view": "day",
        "data-today": dataAttr(cellState.today),
        "data-focus": dataAttr(cellState.focused),
        "data-unavailable": dataAttr(cellState.unavailable),
        "data-range-start": dataAttr(cellState.firstInRange),
        "data-range-end": dataAttr(cellState.lastInRange),
        "data-in-range": dataAttr(cellState.inRange),
        "data-outside-range": dataAttr(cellState.outsideRange),
        "data-weekend": dataAttr(cellState.weekend),
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!cellState.selectable)
            return;
          send({ type: "CELL.CLICK", cell: "day", value });
        },
        onPointerMove(event) {
          if (event.pointerType === "touch" || !cellState.selectable)
            return;
          const focus = event.currentTarget.ownerDocument.activeElement !== event.currentTarget;
          if (hoveredValue && $14e0f24ef4ac5c92$export$91b62ebf2ba703ee(value, hoveredValue))
            return;
          send({ type: "CELL.POINTER_MOVE", cell: "day", value, focus });
        }
      });
    },
    getMonthTableCellState,
    getMonthTableCellProps(props29) {
      const { value, columns } = props29;
      const cellState = getMonthTableCellState(props29);
      return normalize.element({
        ...parts9.tableCell.attrs,
        dir: state2.context.dir,
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getMonthTableCellTriggerProps(props29) {
      const { value } = props29;
      const cellState = getMonthTableCellState(props29);
      return normalize.element({
        ...parts9.tableCellTrigger.attrs,
        dir: state2.context.dir,
        role: "button",
        id: dom9.getCellTriggerId(state2.context, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "data-focus": dataAttr(cellState.focused),
        "aria-label": cellState.valueText,
        "data-view": "month",
        "data-value": value,
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!cellState.selectable)
            return;
          send({ type: "CELL.CLICK", cell: "month", value });
        }
      });
    },
    getYearTableCellState,
    getYearTableCellProps(props29) {
      const { value, columns } = props29;
      const cellState = getYearTableCellState(props29);
      return normalize.element({
        ...parts9.tableCell.attrs,
        dir: state2.context.dir,
        colSpan: columns,
        role: "gridcell",
        "aria-selected": ariaAttr(cellState.selected),
        "data-selected": dataAttr(cellState.selected),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-value": value
      });
    },
    getYearTableCellTriggerProps(props29) {
      const { value } = props29;
      const cellState = getYearTableCellState(props29);
      return normalize.element({
        ...parts9.tableCellTrigger.attrs,
        dir: state2.context.dir,
        role: "button",
        id: dom9.getCellTriggerId(state2.context, value.toString()),
        "data-selected": dataAttr(cellState.selected),
        "data-focus": dataAttr(cellState.focused),
        "aria-disabled": ariaAttr(!cellState.selectable),
        "data-disabled": dataAttr(!cellState.selectable),
        "aria-label": cellState.valueText,
        "data-value": value,
        "data-view": "year",
        tabIndex: cellState.focused ? 0 : -1,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!cellState.selectable)
            return;
          send({ type: "CELL.CLICK", cell: "year", value });
        }
      });
    },
    getNextTriggerProps(props29 = {}) {
      const { view = "day" } = props29;
      const isDisabled = disabled || !state2.context.isNextVisibleRangeValid;
      return normalize.button({
        ...parts9.nextTrigger.attrs,
        dir: state2.context.dir,
        id: dom9.getNextTriggerId(state2.context, view),
        type: "button",
        "aria-label": getNextTriggerLabel(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send({ type: "GOTO.NEXT", view });
        }
      });
    },
    getPrevTriggerProps(props29 = {}) {
      const { view = "day" } = props29;
      const isDisabled = disabled || !state2.context.isPrevVisibleRangeValid;
      return normalize.button({
        ...parts9.prevTrigger.attrs,
        dir: state2.context.dir,
        id: dom9.getPrevTriggerId(state2.context, view),
        type: "button",
        "aria-label": getPrevTriggerLabel(view),
        disabled: isDisabled,
        "data-disabled": dataAttr(isDisabled),
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send({ type: "GOTO.PREV", view });
        }
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts9.clearTrigger.attrs,
        id: dom9.getClearTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "aria-label": "Clear dates",
        hidden: !state2.context.value.length,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("VALUE.CLEAR");
        }
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts9.trigger.attrs,
        id: dom9.getTriggerId(state2.context),
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        "aria-label": open ? "Close calendar" : "Open calendar",
        "aria-controls": dom9.getContentId(state2.context),
        "data-state": open ? "open" : "closed",
        "aria-haspopup": "grid",
        disabled,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          send("TRIGGER.CLICK");
        }
      });
    },
    getViewTriggerProps(props29 = {}) {
      const { view = "day" } = props29;
      return normalize.button({
        ...parts9.viewTrigger.attrs,
        "data-view": view,
        dir: state2.context.dir,
        id: dom9.getViewTriggerId(state2.context, view),
        type: "button",
        disabled,
        "aria-label": getViewTriggerLabel(state2.context.view),
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          send("VIEW.CHANGE");
        }
      });
    },
    getViewControlProps(props29 = {}) {
      const { view = "day" } = props29;
      return normalize.element({
        ...parts9.viewControl.attrs,
        "data-view": view,
        dir: state2.context.dir
      });
    },
    getInputProps(props29 = {}) {
      const { index = 0 } = props29;
      return normalize.input({
        ...parts9.input.attrs,
        id: dom9.getInputId(state2.context, index),
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        dir: state2.context.dir,
        name: state2.context.name,
        "data-state": open ? "open" : "closed",
        readOnly,
        disabled,
        placeholder: getInputPlaceholder(locale),
        defaultValue: state2.context.formattedValue[index],
        onBeforeInput(event) {
          const { data } = getNativeEvent(event);
          if (!isValidCharacter(data, separator)) {
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur(event) {
          send({ type: "INPUT.BLUR", value: event.currentTarget.value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          if (isComposingEvent(event))
            return;
          if (event.key !== "Enter")
            return;
          if (isUnavailable(state2.context.focusedValue))
            return;
          send({ type: "INPUT.ENTER", value: event.currentTarget.value, index });
          event.preventDefault();
        },
        onChange(event) {
          const { value } = event.target;
          send({ type: "INPUT.CHANGE", value: ensureValidCharacters(value, separator), index });
        }
      });
    },
    getMonthSelectProps() {
      return normalize.select({
        ...parts9.monthSelect.attrs,
        id: dom9.getMonthSelectId(state2.context),
        "aria-label": "Select month",
        disabled,
        dir: state2.context.dir,
        defaultValue: startValue.month,
        onChange(event) {
          focusMonth(Number(event.currentTarget.value));
        }
      });
    },
    getYearSelectProps() {
      return normalize.select({
        ...parts9.yearSelect.attrs,
        id: dom9.getYearSelectId(state2.context),
        disabled,
        "aria-label": "Select year",
        dir: state2.context.dir,
        defaultValue: startValue.year,
        onChange(event) {
          focusYear(Number(event.currentTarget.value));
        }
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: dom9.getPositionerId(state2.context),
        ...parts9.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getPresetTriggerProps(props29) {
      const value = Array.isArray(props29.value) ? props29.value : getDateRangePreset(props29.value, locale, timeZone);
      return normalize.button({
        ...parts9.presetTrigger.attrs,
        "aria-label": Array.isArray(props29.value) ? `select ${value[0].toString()} to ${value[1].toString()}` : `select ${value}`,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send({ type: "PRESET.CLICK", value });
        }
      });
    }
  };
}
var { and: and5 } = guards;
var transformContext = (ctx) => {
  const locale = ctx.locale || "en-US";
  const timeZone = ctx.timeZone || "UTC";
  const selectionMode = ctx.selectionMode || "single";
  const numOfMonths = ctx.numOfMonths || 1;
  const value = sortDates(ctx.value || []).map((date) => constrainValue(date, ctx.min, ctx.max));
  let focusedValue = value[0] || ctx.focusedValue || getTodayDate(timeZone);
  focusedValue = constrainValue(focusedValue, ctx.min, ctx.max);
  const startValue = alignDate(focusedValue, "start", { months: numOfMonths }, locale);
  return {
    locale,
    numOfMonths,
    focusedValue,
    startValue,
    timeZone,
    value,
    selectionMode,
    view: "day",
    activeIndex: 0,
    hoveredValue: null,
    closeOnSelect: true,
    disabled: false,
    readOnly: false,
    ...ctx,
    positioning: {
      placement: "bottom",
      ...ctx.positioning
    }
  };
};
function machine9(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "datepicker",
      initial: ctx.open ? "open" : "idle",
      context: transformContext(ctx),
      computed: {
        valueAsString: (ctx2) => ctx2.value.map((date) => formatSelectedDate(date, null, ctx2.locale, ctx2.timeZone)),
        isInteractive: (ctx2) => !ctx2.disabled && !ctx2.readOnly,
        visibleDuration: (ctx2) => ({ months: ctx2.numOfMonths }),
        endValue: (ctx2) => getEndDate(ctx2.startValue, ctx2.visibleDuration),
        visibleRange: (ctx2) => ({ start: ctx2.startValue, end: ctx2.endValue }),
        visibleRangeText(ctx2) {
          const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(ctx2.locale, { month: "long", year: "numeric", timeZone: ctx2.timeZone });
          const start = formatter.format(ctx2.startValue.toDate(ctx2.timeZone));
          const end = formatter.format(ctx2.endValue.toDate(ctx2.timeZone));
          const formatted = ctx2.selectionMode === "range" ? `${start} - ${end}` : start;
          return { start, end, formatted };
        },
        isPrevVisibleRangeValid: (ctx2) => !isPreviousVisibleRangeInvalid(ctx2.startValue, ctx2.min, ctx2.max),
        isNextVisibleRangeValid: (ctx2) => !isNextVisibleRangeInvalid(ctx2.endValue, ctx2.min, ctx2.max),
        formattedValue(ctx2) {
          const opts = { timeZone: ctx2.timeZone, day: "2-digit", month: "2-digit", year: "numeric" };
          const formatter = new $fb18d541ea1ad717$export$ad991b66133851cf(ctx2.locale, opts);
          return ctx2.value.map((date) => {
            var _a;
            return ((_a = ctx2.format) == null ? void 0 : _a.call(ctx2, date)) ?? formatter.format(date.toDate(ctx2.timeZone));
          });
        }
      },
      activities: ["setupLiveRegion"],
      created: ["setStartValue"],
      watch: {
        locale: ["setStartValue"],
        focusedValue: [
          "setStartValue",
          "syncMonthSelectElement",
          "syncYearSelectElement",
          "focusActiveCellIfNeeded",
          "setHoveredValueIfKeyboard"
        ],
        value: ["syncInputElement"],
        valueAsString: ["announceValueText"],
        view: ["focusActiveCell"],
        open: ["toggleVisibility"]
      },
      on: {
        "VALUE.SET": {
          actions: ["setDateValue", "setFocusedDate"]
        },
        "VIEW.SET": {
          actions: ["setView"]
        },
        "FOCUS.SET": {
          actions: ["setFocusedDate"]
        },
        "VALUE.CLEAR": {
          actions: ["clearDateValue", "clearFocusedDate", "focusFirstInputElement"]
        },
        "INPUT.CHANGE": {
          actions: ["focusParsedDate"]
        },
        "INPUT.ENTER": {
          actions: ["focusParsedDate", "selectFocusedDate"]
        },
        "INPUT.FOCUS": {
          actions: ["setActiveIndex"]
        },
        "INPUT.BLUR": [
          {
            guard: "isOpenControlled",
            actions: ["setActiveIndexToStart", "selectParsedDate", "invokeOnClose"]
          },
          {
            target: "idle",
            actions: ["setActiveIndexToStart", "selectParsedDate"]
          }
        ],
        "PRESET.CLICK": [
          {
            guard: "isOpenControlled",
            actions: ["setDateValue", "setFocusedDate", "invokeOnClose"]
          },
          {
            target: "focused",
            actions: ["setDateValue", "setFocusedDate", "focusInputElement"]
          }
        ],
        "GOTO.NEXT": [
          {
            guard: "isYearView",
            actions: ["focusNextDecade", "announceVisibleRange"]
          },
          {
            guard: "isMonthView",
            actions: ["focusNextYear", "announceVisibleRange"]
          },
          {
            actions: ["focusNextPage"]
          }
        ],
        "GOTO.PREV": [
          {
            guard: "isYearView",
            actions: ["focusPreviousDecade", "announceVisibleRange"]
          },
          {
            guard: "isMonthView",
            actions: ["focusPreviousYear", "announceVisibleRange"]
          },
          {
            actions: ["focusPreviousPage"]
          }
        ]
      },
      states: {
        idle: {
          tags: "closed",
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["focusFirstSelectedDate", "focusActiveCell"]
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: "closed",
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["focusFirstSelectedDate", "focusActiveCell"]
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["focusFirstSelectedDate", "focusActiveCell", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: "open",
          activities: ["trackDismissableElement", "trackPositioning"],
          exit: ["clearHoveredDate", "resetView"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: and5("shouldRestoreFocus", "isInteractOutsideEvent"),
                target: "focused",
                actions: ["focusTriggerElement"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["focusInputElement"]
              },
              {
                target: "idle"
              }
            ],
            "CELL.CLICK": [
              {
                guard: "isMonthView",
                actions: ["setFocusedMonth", "setViewToDay"]
              },
              {
                guard: "isYearView",
                actions: ["setFocusedYear", "setViewToMonth"]
              },
              {
                guard: and5("isRangePicker", "hasSelectedRange"),
                actions: [
                  "setActiveIndexToStart",
                  "clearDateValue",
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToEnd"
                ]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and5("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToStart",
                  "invokeOnClose",
                  "setRestoreFocus"
                ]
              },
              {
                guard: and5("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
                target: "focused",
                actions: [
                  "setFocusedDate",
                  "setSelectedDate",
                  "setActiveIndexToStart",
                  "invokeOnClose",
                  "focusInputElement"
                ]
              },
              {
                guard: and5("isRangePicker", "isSelectingEndDate"),
                actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToStart", "clearHoveredDate"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setFocusedDate", "setSelectedDate", "setActiveIndexToEnd"]
              },
              {
                guard: "isMultiPicker",
                actions: ["setFocusedDate", "toggleSelectedDate"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and5("closeOnSelect", "isOpenControlled"),
                actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["setFocusedDate", "setSelectedDate", "invokeOnClose", "focusInputElement"]
              },
              {
                actions: ["setFocusedDate", "setSelectedDate"]
              }
              // ===
            ],
            "CELL.POINTER_MOVE": {
              guard: and5("isRangePicker", "isSelectingEndDate"),
              actions: ["setHoveredDate", "setFocusedDate"]
            },
            "TABLE.POINTER_LEAVE": {
              guard: "isRangePicker",
              actions: ["clearHoveredDate"]
            },
            "TABLE.POINTER_DOWN": {
              actions: ["disableTextSelection"]
            },
            "TABLE.POINTER_UP": {
              actions: ["enableTextSelection"]
            },
            "TABLE.ESCAPE": [
              {
                guard: "isOpenControlled",
                actions: ["focusFirstSelectedDate", "invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["focusFirstSelectedDate", "invokeOnClose", "focusTriggerElement"]
              }
            ],
            "TABLE.ENTER": [
              {
                guard: "isMonthView",
                actions: "setViewToDay"
              },
              {
                guard: "isYearView",
                actions: "setViewToMonth"
              },
              {
                guard: and5("isRangePicker", "hasSelectedRange"),
                actions: ["setActiveIndexToStart", "clearDateValue", "setSelectedDate", "setActiveIndexToEnd"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and5("isRangePicker", "isSelectingEndDate", "closeOnSelect", "isOpenControlled"),
                actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose"]
              },
              {
                guard: and5("isRangePicker", "isSelectingEndDate", "closeOnSelect"),
                target: "focused",
                actions: ["setSelectedDate", "setActiveIndexToStart", "invokeOnClose", "focusInputElement"]
              },
              {
                guard: and5("isRangePicker", "isSelectingEndDate"),
                actions: ["setSelectedDate", "setActiveIndexToStart"]
              },
              // ===
              {
                guard: "isRangePicker",
                actions: ["setSelectedDate", "setActiveIndexToEnd", "focusNextDay"]
              },
              {
                guard: "isMultiPicker",
                actions: ["toggleSelectedDate"]
              },
              // === Grouped transitions (based on `closeOnSelect` and `isOpenControlled`) ===
              {
                guard: and5("closeOnSelect", "isOpenControlled"),
                actions: ["selectFocusedDate", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectFocusedDate", "invokeOnClose", "focusInputElement"]
              },
              {
                actions: ["selectFocusedDate"]
              }
              // ===
            ],
            "TABLE.ARROW_RIGHT": [
              {
                guard: "isMonthView",
                actions: "focusNextMonth"
              },
              {
                guard: "isYearView",
                actions: "focusNextYear"
              },
              {
                actions: ["focusNextDay", "setHoveredDate"]
              }
            ],
            "TABLE.ARROW_LEFT": [
              {
                guard: "isMonthView",
                actions: "focusPreviousMonth"
              },
              {
                guard: "isYearView",
                actions: "focusPreviousYear"
              },
              {
                actions: ["focusPreviousDay"]
              }
            ],
            "TABLE.ARROW_UP": [
              {
                guard: "isMonthView",
                actions: "focusPreviousMonthColumn"
              },
              {
                guard: "isYearView",
                actions: "focusPreviousYearColumn"
              },
              {
                actions: ["focusPreviousWeek"]
              }
            ],
            "TABLE.ARROW_DOWN": [
              {
                guard: "isMonthView",
                actions: "focusNextMonthColumn"
              },
              {
                guard: "isYearView",
                actions: "focusNextYearColumn"
              },
              {
                actions: ["focusNextWeek"]
              }
            ],
            "TABLE.PAGE_UP": {
              actions: ["focusPreviousSection"]
            },
            "TABLE.PAGE_DOWN": {
              actions: ["focusNextSection"]
            },
            "TABLE.HOME": [
              {
                guard: "isMonthView",
                actions: ["focusFirstMonth"]
              },
              {
                guard: "isYearView",
                actions: ["focusFirstYear"]
              },
              {
                actions: ["focusSectionStart"]
              }
            ],
            "TABLE.END": [
              {
                guard: "isMonthView",
                actions: ["focusLastMonth"]
              },
              {
                guard: "isYearView",
                actions: ["focusLastYear"]
              },
              {
                actions: ["focusSectionEnd"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose"]
              }
            ],
            "VIEW.CHANGE": [
              {
                guard: "isDayView",
                actions: ["setViewToMonth"]
              },
              {
                guard: "isMonthView",
                actions: ["setViewToYear"]
              }
            ],
            INTERACT_OUTSIDE: [
              {
                guard: "isOpenControlled",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["setActiveIndexToStart", "invokeOnClose", "focusTriggerElement"]
              },
              {
                target: "idle",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["setActiveIndexToStart", "invokeOnClose"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isDayView: (ctx2, evt) => (evt.view || ctx2.view) === "day",
        isMonthView: (ctx2, evt) => (evt.view || ctx2.view) === "month",
        isYearView: (ctx2, evt) => (evt.view || ctx2.view) === "year",
        isRangePicker: (ctx2) => ctx2.selectionMode === "range",
        hasSelectedRange: (ctx2) => ctx2.value.length === 2,
        isMultiPicker: (ctx2) => ctx2.selectionMode === "multiple",
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus,
        isSelectingEndDate: (ctx2) => ctx2.activeIndex === 1,
        closeOnSelect: (ctx2) => !!ctx2.closeOnSelect,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isInteractOutsideEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "INTERACT_OUTSIDE";
        }
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom9.getControlEl(ctx2);
          const getPositionerEl = () => dom9.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setupLiveRegion(ctx2) {
          const doc = dom9.getDoc(ctx2);
          ctx2.announcer = createLiveRegion({ level: "assertive", document: doc });
          return () => {
            var _a, _b;
            return (_b = (_a = ctx2.announcer) == null ? void 0 : _a.destroy) == null ? void 0 : _b.call(_a);
          };
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom9.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [...dom9.getInputEls(ctx2), dom9.getTriggerEl(ctx2), dom9.getClearTriggerEl(ctx2)],
            onInteractOutside(event) {
              ctx2.restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "INTERACT_OUTSIDE" });
            },
            onEscapeKeyDown(event) {
              event.preventDefault();
              send({ type: "TABLE.ESCAPE", src: "dismissable" });
            }
          });
        }
      },
      actions: {
        setViewToDay(ctx2) {
          set8.view(ctx2, "day");
        },
        setViewToMonth(ctx2) {
          set8.view(ctx2, "month");
        },
        setViewToYear(ctx2) {
          set8.view(ctx2, "year");
        },
        setView(ctx2, evt) {
          set8.view(ctx2, evt.cell);
        },
        setRestoreFocus(ctx2) {
          ctx2.restoreFocus = true;
        },
        announceValueText(ctx2) {
          var _a;
          (_a = ctx2.announcer) == null ? void 0 : _a.announce(ctx2.valueAsString.join(","), 3e3);
        },
        announceVisibleRange(ctx2) {
          var _a;
          const { formatted } = ctx2.visibleRangeText;
          (_a = ctx2.announcer) == null ? void 0 : _a.announce(formatted);
        },
        disableTextSelection(ctx2) {
          disableTextSelection({ target: dom9.getContentEl(ctx2), doc: dom9.getDoc(ctx2) });
        },
        enableTextSelection(ctx2) {
          restoreTextSelection({ doc: dom9.getDoc(ctx2), target: dom9.getContentEl(ctx2) });
        },
        focusFirstSelectedDate(ctx2) {
          if (!ctx2.value.length)
            return;
          set8.focusedValue(ctx2, ctx2.value[0]);
        },
        syncInputElement(ctx2) {
          raf(() => {
            const inputEls = dom9.getInputEls(ctx2);
            inputEls.forEach((inputEl, index) => {
              dom9.setValue(inputEl, ctx2.formattedValue[index] || "");
            });
          });
        },
        setFocusedDate(ctx2, evt) {
          const value = Array.isArray(evt.value) ? evt.value[0] : evt.value;
          set8.focusedValue(ctx2, value);
        },
        setFocusedMonth(ctx2, evt) {
          set8.focusedValue(ctx2, ctx2.focusedValue.set({ month: evt.value }));
        },
        focusNextMonth(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ months: 1 }));
        },
        focusPreviousMonth(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ months: 1 }));
        },
        setFocusedYear(ctx2, evt) {
          set8.focusedValue(ctx2, ctx2.focusedValue.set({ year: evt.value }));
        },
        setDateValue(ctx2, evt) {
          if (!Array.isArray(evt.value))
            return;
          const value = evt.value.map((date) => constrainValue(date, ctx2.min, ctx2.max));
          set8.value(ctx2, value);
        },
        clearDateValue(ctx2) {
          set8.value(ctx2, []);
        },
        setSelectedDate(ctx2, evt) {
          const values = Array.from(ctx2.value);
          values[ctx2.activeIndex] = evt.value ?? ctx2.focusedValue;
          set8.value(ctx2, adjustStartAndEndDate(values));
        },
        toggleSelectedDate(ctx2, evt) {
          const currentValue = evt.value ?? ctx2.focusedValue;
          const index = ctx2.value.findIndex((date) => isDateEqual(date, currentValue));
          if (index === -1) {
            const values = [...ctx2.value, currentValue];
            set8.value(ctx2, sortDates(values));
          } else {
            const values = Array.from(ctx2.value);
            values.splice(index, 1);
            set8.value(ctx2, sortDates(values));
          }
        },
        setHoveredDate(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        clearHoveredDate(ctx2) {
          ctx2.hoveredValue = null;
        },
        selectFocusedDate(ctx2) {
          const values = Array.from(ctx2.value);
          values[ctx2.activeIndex] = ctx2.focusedValue.copy();
          set8.value(ctx2, adjustStartAndEndDate(values));
        },
        setPreviousDate(ctx2) {
          set8.focusedValue(ctx2, getPreviousDay(ctx2.focusedValue));
        },
        setNextDate(ctx2) {
          set8.focusedValue(ctx2, getNextDay(ctx2.focusedValue));
        },
        focusPreviousDay(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ days: 1 }));
        },
        focusNextDay(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ days: 1 }));
        },
        focusPreviousWeek(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ weeks: 1 }));
        },
        focusNextWeek(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ weeks: 1 }));
        },
        focusNextPage(ctx2) {
          const nextPage = getNextPage(
            ctx2.focusedValue,
            ctx2.startValue,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          set8.adjustedValue(ctx2, nextPage);
        },
        focusPreviousPage(ctx2) {
          const previousPage = getPreviousPage(
            ctx2.focusedValue,
            ctx2.startValue,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          set8.adjustedValue(ctx2, previousPage);
        },
        focusSectionStart(ctx2) {
          set8.focusedValue(ctx2, ctx2.startValue.copy());
        },
        focusSectionEnd(ctx2) {
          set8.focusedValue(ctx2, ctx2.endValue.copy());
        },
        focusNextSection(ctx2, evt) {
          const nextSection = getNextSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!nextSection)
            return;
          set8.adjustedValue(ctx2, nextSection);
        },
        focusPreviousSection(ctx2, evt) {
          const previousSection = getPreviousSection(
            ctx2.focusedValue,
            ctx2.startValue,
            evt.larger,
            ctx2.visibleDuration,
            ctx2.locale,
            ctx2.min,
            ctx2.max
          );
          if (!previousSection)
            return;
          set8.adjustedValue(ctx2, previousSection);
        },
        focusNextYear(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ years: 1 }));
        },
        focusPreviousYear(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: 1 }));
        },
        focusNextDecade(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ years: 10 }));
        },
        focusPreviousDecade(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: 10 }));
        },
        clearFocusedDate(ctx2) {
          set8.focusedValue(ctx2, getTodayDate(ctx2.timeZone));
        },
        focusPreviousMonthColumn(ctx2, evt) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ months: evt.columns }));
        },
        focusNextMonthColumn(ctx2, evt) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ months: evt.columns }));
        },
        focusPreviousYearColumn(ctx2, evt) {
          set8.focusedValue(ctx2, ctx2.focusedValue.subtract({ years: evt.columns }));
        },
        focusNextYearColumn(ctx2, evt) {
          set8.focusedValue(ctx2, ctx2.focusedValue.add({ years: evt.columns }));
        },
        focusFirstMonth(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.set({ month: 0 }));
        },
        focusLastMonth(ctx2) {
          set8.focusedValue(ctx2, ctx2.focusedValue.set({ month: 12 }));
        },
        focusFirstYear(ctx2) {
          const range2 = getDecadeRange(ctx2.focusedValue.year);
          set8.focusedValue(ctx2, ctx2.focusedValue.set({ year: range2.at(0) }));
        },
        focusLastYear(ctx2) {
          const range2 = getDecadeRange(ctx2.focusedValue.year);
          set8.focusedValue(ctx2, ctx2.focusedValue.set({ year: range2.at(-1) }));
        },
        setActiveIndex(ctx2, evt) {
          ctx2.activeIndex = evt.index;
        },
        setActiveIndexToEnd(ctx2) {
          ctx2.activeIndex = 1;
        },
        setActiveIndexToStart(ctx2) {
          ctx2.activeIndex = 0;
        },
        focusActiveCell(ctx2) {
          raf(() => {
            var _a;
            (_a = dom9.getFocusedCell(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        focusActiveCellIfNeeded(ctx2, evt) {
          if (!evt.focus)
            return;
          raf(() => {
            var _a;
            (_a = dom9.getFocusedCell(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        setHoveredValueIfKeyboard(ctx2, evt) {
          if (!evt.type.startsWith("TABLE.ARROW") || ctx2.selectionMode !== "range" || ctx2.activeIndex === 0)
            return;
          ctx2.hoveredValue = ctx2.focusedValue.copy();
        },
        focusTriggerElement(ctx2) {
          raf(() => {
            var _a;
            (_a = dom9.getTriggerEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        focusFirstInputElement(ctx2) {
          raf(() => {
            const inputEl = dom9.getInputEls(ctx2)[0];
            inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
          });
        },
        focusInputElement(ctx2) {
          raf(() => {
            const inputEls = dom9.getInputEls(ctx2);
            const lastIndexWithValue = inputEls.findLastIndex((inputEl2) => inputEl2.value !== "");
            const indexToFocus = Math.max(lastIndexWithValue, 0);
            const inputEl = inputEls[indexToFocus];
            inputEl == null ? void 0 : inputEl.focus({ preventScroll: true });
            inputEl == null ? void 0 : inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
          });
        },
        syncMonthSelectElement(ctx2) {
          const monthSelectEl = dom9.getMonthSelectEl(ctx2);
          if (!monthSelectEl)
            return;
          monthSelectEl.value = ctx2.startValue.month.toString();
        },
        syncYearSelectElement(ctx2) {
          const yearSelectEl = dom9.getYearSelectEl(ctx2);
          if (!yearSelectEl)
            return;
          yearSelectEl.value = ctx2.startValue.year.toString();
        },
        focusParsedDate(ctx2, evt) {
          if (evt.index == null)
            return;
          const date = parseDateString(evt.value, ctx2.locale, ctx2.timeZone);
          if (!date)
            return;
          set8.focusedValue(ctx2, date);
        },
        selectParsedDate(ctx2, evt) {
          if (evt.index == null)
            return;
          const date = parseDateString(evt.value, ctx2.locale, ctx2.timeZone);
          if (!date)
            return;
          const values = Array.from(ctx2.value);
          values[evt.index] = date;
          set8.value(ctx2, values);
        },
        resetView(ctx2, _evt, { initialContext }) {
          set8.view(ctx2, initialContext.view);
        },
        setStartValue(ctx2) {
          const outside = isDateOutsideVisibleRange(ctx2.focusedValue, ctx2.startValue, ctx2.endValue);
          if (!outside)
            return;
          const startValue = alignDate(ctx2.focusedValue, "start", { months: ctx2.numOfMonths }, ctx2.locale);
          ctx2.startValue = startValue;
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      compareFns: {
        startValue: isDateEqual,
        endValue: isDateEqual,
        focusedValue: isDateEqual,
        value: isDateEqualFn
      }
    }
  );
}
var invoke6 = {
  change(ctx) {
    var _a;
    const value = Array.from(ctx.value);
    const valueAsString = value.map((date) => date.toString());
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value,
      valueAsString,
      view: ctx.view
    });
  },
  focusChange(ctx) {
    var _a;
    const value = Array.from(ctx.value);
    const valueAsString = value.map((date) => date.toString());
    (_a = ctx.onFocusChange) == null ? void 0 : _a.call(ctx, {
      focusedValue: ctx.focusedValue,
      value,
      valueAsString,
      view: ctx.view
    });
  },
  viewChange(ctx) {
    var _a;
    (_a = ctx.onViewChange) == null ? void 0 : _a.call(ctx, { view: ctx.view });
  }
};
var isDateEqualFn = (a2, b2) => {
  if (a2.length !== b2.length)
    return false;
  return a2.every((date, index) => isDateEqual(date, b2[index]));
};
var set8 = {
  value(ctx, value) {
    if (isDateEqualFn(ctx.value, value))
      return;
    ctx.value = value;
    invoke6.change(ctx);
  },
  focusedValue(ctx, value) {
    if (!value || isDateEqual(ctx.focusedValue, value))
      return;
    const adjustFn = getAdjustedDateFn(ctx.visibleDuration, ctx.locale, ctx.min, ctx.max);
    const adjustedValue = adjustFn({
      focusedDate: value,
      startDate: ctx.startValue
    });
    ctx.startValue = adjustedValue.startDate;
    ctx.focusedValue = adjustedValue.focusedDate;
    invoke6.focusChange(ctx);
  },
  adjustedValue(ctx, value) {
    ctx.startValue = value.startDate;
    if (isDateEqual(ctx.focusedValue, value.focusedDate))
      return;
    ctx.focusedValue = value.focusedDate;
    invoke6.focusChange(ctx);
  },
  view(ctx, value) {
    if (isEqual(ctx.view, value))
      return;
    ctx.view = value;
    invoke6.viewChange(ctx);
  }
};
function parse2(value) {
  if (Array.isArray(value)) {
    return value.map((v) => parse2(v));
  }
  if (value instanceof Date) {
    return new $35ea8db9cb2ccb90$export$99faa760c7908e4f(value.getFullYear(), value.getMonth() + 1, value.getDate());
  }
  return $fae977aafc393c5c$export$6b862160d295c8e(value);
}
var props7 = createProps()([
  "closeOnSelect",
  "dir",
  "disabled",
  "fixedWeeks",
  "focusedValue",
  "format",
  "getRootNode",
  "id",
  "ids",
  "isDateUnavailable",
  "isDateUnavailable",
  "locale",
  "max",
  "min",
  "modal",
  "name",
  "numOfMonths",
  "onFocusChange",
  "onOpenChange",
  "onValueChange",
  "onViewChange",
  "open",
  "open.controlled",
  "positioning",
  "readOnly",
  "selectionMode",
  "startOfWeek",
  "timeZone",
  "translations",
  "value",
  "view"
]);
var splitProps7 = createSplitProps(props7);
var inputProps = createProps()(["index"]);
var splitInputProps = createSplitProps(inputProps);
var presetTriggerProps = createProps()(["value"]);
var splitPresetTriggerProps = createSplitProps(presetTriggerProps);
var tableProps = createProps()(["columns", "id", "view"]);
var splitTableProps = createSplitProps(tableProps);
var tableCellProps = createProps()(["disabled", "value", "columns"]);
var splitTableCellProps = createSplitProps(tableCellProps);
var viewProps = createProps()(["view"]);
var splitViewProps = createSplitProps(viewProps);

// node_modules/@ark-ui/anatomy/dist/date-picker/index.js
var anatomy13 = anatomy12.extendWith("view");

// node_modules/@zag-js/remove-scroll/dist/index.mjs
var LOCK_CLASSNAME = "data-zag-scroll-lock";
function assignStyle(el, style) {
  if (!el)
    return;
  const previousStyle = el.style.cssText;
  Object.assign(el.style, style);
  return () => {
    el.style.cssText = previousStyle;
  };
}
function setCSSProperty(el, property, value) {
  if (!el)
    return;
  const previousValue = el.style.getPropertyValue(property);
  el.style.setProperty(property, value);
  return () => {
    if (previousValue) {
      el.style.setProperty(property, previousValue);
    } else {
      el.style.removeProperty(property);
    }
  };
}
function getPaddingProperty(documentElement) {
  const documentLeft = documentElement.getBoundingClientRect().left;
  const scrollbarX = Math.round(documentLeft) + documentElement.scrollLeft;
  return scrollbarX ? "paddingLeft" : "paddingRight";
}
function preventBodyScroll(_document) {
  const doc = _document ?? document;
  const win = doc.defaultView ?? window;
  const { documentElement, body } = doc;
  const locked = body.hasAttribute(LOCK_CLASSNAME);
  if (locked)
    return;
  body.setAttribute(LOCK_CLASSNAME, "");
  const scrollbarWidth = win.innerWidth - documentElement.clientWidth;
  const setScrollbarWidthProperty = () => setCSSProperty(documentElement, "--scrollbar-width", `${scrollbarWidth}px`);
  const paddingProperty = getPaddingProperty(documentElement);
  const setStyle2 = () => assignStyle(body, {
    overflow: "hidden",
    [paddingProperty]: `${scrollbarWidth}px`
  });
  const setIOSStyle = () => {
    const { scrollX, scrollY, visualViewport } = win;
    const offsetLeft = (visualViewport == null ? void 0 : visualViewport.offsetLeft) ?? 0;
    const offsetTop = (visualViewport == null ? void 0 : visualViewport.offsetTop) ?? 0;
    const restoreStyle = assignStyle(body, {
      position: "fixed",
      overflow: "hidden",
      top: `${-(scrollY - Math.floor(offsetTop))}px`,
      left: `${-(scrollX - Math.floor(offsetLeft))}px`,
      right: "0",
      [paddingProperty]: `${scrollbarWidth}px`
    });
    return () => {
      restoreStyle == null ? void 0 : restoreStyle();
      win.scrollTo({ left: scrollX, top: scrollY, behavior: "instant" });
    };
  };
  const cleanups2 = [setScrollbarWidthProperty(), isIos() ? setIOSStyle() : setStyle2()];
  return () => {
    cleanups2.forEach((fn) => fn == null ? void 0 : fn());
    body.removeAttribute(LOCK_CLASSNAME);
  };
}

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node === null || node === void 0 ? void 0 : (_node$getAttribute = node.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node && isInert2(node.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node) {
  var _node$getAttribute2;
  var attValue = node === null || node === void 0 ? void 0 : (_node$getAttribute2 = node.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node) {
  return !isNaN(parseInt(node.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node) {
  if (!node) {
    throw new Error("No node provided");
  }
  if (node.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || isContentEditable(node)) && !hasTabIndex(node)) {
      return 0;
    }
  }
  return node.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node, isScope) {
  var tabIndex = getTabIndex(node);
  if (tabIndex < 0 && isScope && !hasTabIndex(node)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
};
var isInput = function isInput2(node) {
  return node.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node) {
  return isInput(node) && node.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node) {
  var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked && nodes[i].form === form) {
      return nodes[i];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node) {
  if (!node.name) {
    return true;
  }
  var radioScope = node.form || getRootNode(node);
  var queryRadios = function queryRadios2(name) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node.name));
  } else {
    try {
      radioSet = queryRadios(node.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node.form);
  return !checked || checked === node;
};
var isRadio = function isRadio2(node) {
  return isInput(node) && node.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node) {
  return isRadio(node) && !isTabbableRadio(node);
};
var isNodeAttached = function isNodeAttached2(node) {
  var _nodeRoot;
  var nodeRoot = node && getRootNode(node);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node !== null && node !== void 0 && (_node$ownerDocument = node.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node) {
  var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden = function isHidden2(node, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches.call(node, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
  if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node;
      while (node) {
        var parentElement = node.parentElement;
        var rootNode = getRootNode(node);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node);
        } else if (node.assignedSlot) {
          node = node.assignedSlot;
        } else if (!parentElement && rootNode !== node.ownerDocument) {
          node = rootNode.host;
        } else {
          node = parentElement;
        }
      }
      node = originalNode;
    }
    if (isNodeAttached(node)) {
      return !node.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
    var parentNode = node.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i = 0; i < parentNode.children.length; i++) {
          var child = parentNode.children.item(i);
          if (child.tagName === "LEGEND") {
            return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
  if (node.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node) || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
  if (isNonTabbableRadio(node) || getTabIndex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable2 = function isTabbable3(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node);
};
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
var isFocusable2 = function isFocusable3(node, options) {
  options = options || {};
  if (!node) {
    throw new Error("No node provided");
  }
  if (matches.call(node, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread2(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap.pause();
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0) {
      trapStack[trapStack.length - 1].unpause();
    }
  }
};
var isSelectableInput = function isSelectableInput2(node) {
  return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Escape" || (e === null || e === void 0 ? void 0 : e.key) === "Esc" || (e === null || e === void 0 ? void 0 : e.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e) {
  return (e === null || e === void 0 ? void 0 : e.key) === "Tab" || (e === null || e === void 0 ? void 0 : e.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e) {
  return isTabEvent(e) && !e.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e) {
  return isTabEvent(e) && e.shiftKey;
};
var delay = function delay2(fn) {
  return setTimeout(fn, 0);
};
var findIndex = function findIndex2(arr, fn) {
  var idx = -1;
  arr.every(function(value, i) {
    if (fn(value)) {
      idx = i;
      return false;
    }
    return true;
  });
  return idx;
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event) {
  return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state2 = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event) {
    var composedPath = typeof (event === null || event === void 0 ? void 0 : event.composedPath) === "function" ? event.composedPath() : void 0;
    return state2.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node) {
        return node === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        params[_key2 - 1] = arguments[_key2];
      }
      optionValue = optionValue.apply(void 0, params);
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node = optionValue;
    if (typeof optionValue === "string") {
      node = doc.querySelector(optionValue);
      if (!node) {
        throw new Error("`".concat(optionName, "` as selector refers to no known node"));
      }
    }
    return node;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node = getNodeForOption("initialFocus");
    if (node === false) {
      return false;
    }
    if (node === void 0 || !isFocusable2(node, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node = doc.activeElement;
      } else {
        var firstTabbableGroup = state2.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    }
    if (!node) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state2.containerGroups = state2.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node) {
        return isTabbable2(node);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node) {
        return isTabbable2(node);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node) {
        return getTabIndex(node) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node) + 1).find(function(el) {
                return isTabbable2(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node)).reverse().find(function(el) {
              return isTabbable2(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state2.tabbableGroups = state2.containerGroups.filter(function(group2) {
      return group2.tabbableNodes.length > 0;
    });
    if (state2.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state2.containerGroups.find(function(g) {
      return g.posTabIndexesFound;
    }) && state2.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var getActiveElement = function getActiveElement2(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return getActiveElement2(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var tryFocus = function tryFocus2(node) {
    if (node === false) {
      return;
    }
    if (node === getActiveElement(document)) {
      return;
    }
    if (!node || !node.focus) {
      tryFocus2(getInitialFocusNode());
      return;
    }
    node.focus({
      preventScroll: !!config.preventScroll
    });
    state2.mostRecentlyFocusedNode = node;
    if (isSelectableInput(node)) {
      node.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node = getNodeForOption("setReturnFocus", previousActiveElement);
    return node ? node : node === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref2) {
    var target = _ref2.target, event = _ref2.event, _ref2$isBackward = _ref2.isBackward, isBackward = _ref2$isBackward === void 0 ? false : _ref2$isBackward;
    target = target || getActualTarget(event);
    updateTabbableNodes();
    var destinationNode = null;
    if (state2.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event);
      var containerGroup = containerIndex >= 0 ? state2.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state2.tabbableGroups[state2.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state2.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = findIndex(state2.tabbableGroups, function(_ref3) {
          var firstTabbableNode = _ref3.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable2(target, config.tabbableOptions) && !isTabbable2(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state2.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state2.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = findIndex(state2.tabbableGroups, function(_ref4) {
          var lastTabbableNode = _ref4.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable2(target, config.tabbableOptions) && !isTabbable2(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state2.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state2.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event) {
    var target = getActualTarget(event);
    var targetContained = findContainerIndex(target, event) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state2.mostRecentlyFocusedNode = target;
      }
    } else {
      event.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state2.mostRecentlyFocusedNode) {
        if (getTabIndex(state2.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state2.mostRecentlyFocusedNode);
          var tabbableNodes = state2.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node) {
              return node === state2.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state2.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state2.containerGroups.some(function(g) {
            return g.tabbableNodes.some(function(n) {
              return getTabIndex(n) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state2.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state2.recentNavEvent)
        });
      }
      if (nextNode) {
        tryFocus(nextNode);
      } else {
        tryFocus(state2.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state2.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state2.recentNavEvent = event;
    var destinationNode = findNextNavNode({
      event,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event)) {
        event.preventDefault();
      }
      tryFocus(destinationNode);
    }
  };
  var checkKey = function checkKey2(event) {
    if (isEscapeEvent(event) && valueOrHandler(config.escapeDeactivates, event) !== false) {
      event.preventDefault();
      trap.deactivate();
      return;
    }
    if (config.isKeyForward(event) || config.isKeyBackward(event)) {
      checkKeyNav(event, config.isKeyBackward(event));
    }
  };
  var checkClick = function checkClick2(e) {
    var target = getActualTarget(e);
    if (findContainerIndex(target, e) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e)) {
      return;
    }
    e.preventDefault();
    e.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state2.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state2.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      tryFocus(getInitialFocusNode());
    }) : tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkKey, {
      capture: true,
      passive: false
    });
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state2.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkKey, true);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node) {
        return node === state2.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state2.active && !state2.paused) {
      state2.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state2.active;
    },
    get paused() {
      return state2.paused;
    },
    activate: function activate(activateOptions) {
      if (state2.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state2.active = true;
      state2.paused = false;
      state2.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state2.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state2.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state2.delayInitialFocusTimer);
      state2.delayInitialFocusTimer = void 0;
      removeListeners();
      state2.active = false;
      state2.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            tryFocus(getReturnFocusNode(state2.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state2.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (state2.paused || !state2.active) {
        return this;
      }
      var onPause = getOption(pauseOptions, "onPause");
      var onPostPause = getOption(pauseOptions, "onPostPause");
      state2.paused = true;
      onPause === null || onPause === void 0 || onPause();
      removeListeners();
      updateObservedNodes();
      onPostPause === null || onPostPause === void 0 || onPostPause();
      return this;
    },
    unpause: function unpause(unpauseOptions) {
      if (!state2.paused || !state2.active) {
        return this;
      }
      var onUnpause = getOption(unpauseOptions, "onUnpause");
      var onPostUnpause = getOption(unpauseOptions, "onPostUnpause");
      state2.paused = false;
      onUnpause === null || onUnpause === void 0 || onUnpause();
      updateTabbableNodes();
      addListeners();
      updateObservedNodes();
      onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
      return this;
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state2.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state2.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@zag-js/dialog/dist/index.mjs
var anatomy14 = createAnatomy("dialog").parts(
  "trigger",
  "backdrop",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts10 = anatomy14.build();
var dom10 = createScope({
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `dialog:${ctx.id}:positioner`;
  },
  getBackdropId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.backdrop) ?? `dialog:${ctx.id}:backdrop`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `dialog:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `dialog:${ctx.id}:trigger`;
  },
  getTitleId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.title) ?? `dialog:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.description) ?? `dialog:${ctx.id}:description`;
  },
  getCloseTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.closeTrigger) ?? `dialog:${ctx.id}:close`;
  },
  getContentEl: (ctx) => dom10.getById(ctx, dom10.getContentId(ctx)),
  getPositionerEl: (ctx) => dom10.getById(ctx, dom10.getPositionerId(ctx)),
  getBackdropEl: (ctx) => dom10.getById(ctx, dom10.getBackdropId(ctx)),
  getTriggerEl: (ctx) => dom10.getById(ctx, dom10.getTriggerId(ctx)),
  getTitleEl: (ctx) => dom10.getById(ctx, dom10.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom10.getById(ctx, dom10.getDescriptionId(ctx)),
  getCloseTriggerEl: (ctx) => dom10.getById(ctx, dom10.getCloseTriggerId(ctx))
});
function connect10(state2, send, normalize) {
  const ariaLabel = state2.context["aria-label"];
  const open = state2.matches("open");
  const rendered = state2.context.renderedElements;
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    getTriggerProps() {
      return normalize.button({
        ...parts10.trigger.attrs,
        dir: state2.context.dir,
        id: dom10.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        type: "button",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom10.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("TOGGLE");
        }
      });
    },
    getBackdropProps() {
      return normalize.element({
        ...parts10.backdrop.attrs,
        dir: state2.context.dir,
        hidden: !open,
        id: dom10.getBackdropId(state2.context),
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts10.positioner.attrs,
        dir: state2.context.dir,
        id: dom10.getPositionerId(state2.context),
        style: {
          pointerEvents: open ? void 0 : "none"
        }
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts10.content.attrs,
        dir: state2.context.dir,
        role: state2.context.role,
        hidden: !open,
        id: dom10.getContentId(state2.context),
        tabIndex: -1,
        "data-state": open ? "open" : "closed",
        "aria-modal": true,
        "aria-label": ariaLabel || void 0,
        "aria-labelledby": ariaLabel || !rendered.title ? void 0 : dom10.getTitleId(state2.context),
        "aria-describedby": rendered.description ? dom10.getDescriptionId(state2.context) : void 0
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts10.title.attrs,
        dir: state2.context.dir,
        id: dom10.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts10.description.attrs,
        dir: state2.context.dir,
        id: dom10.getDescriptionId(state2.context)
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        ...parts10.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom10.getCloseTriggerId(state2.context),
        type: "button",
        onClick(event) {
          if (event.defaultPrevented)
            return;
          event.stopPropagation();
          send("CLOSE");
        }
      });
    }
  };
}
function machine10(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "dialog",
      initial: ctx.open ? "open" : "closed",
      context: {
        role: "dialog",
        renderedElements: {
          title: true,
          description: true
        },
        modal: true,
        trapFocus: true,
        preventScroll: true,
        closeOnInteractOutside: true,
        closeOnEscape: true,
        restoreFocus: true,
        ...ctx
      },
      created: ["checkInitialFocusEl"],
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        open: {
          entry: ["checkRenderedElements", "syncZIndex"],
          activities: ["trackDismissableElement", "trapFocus", "preventScroll", "hideContentBelow"],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ]
          }
        },
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom10.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            pointerBlocking: ctx2.modal,
            exclude: [dom10.getTriggerEl(ctx2)],
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              if (!ctx2.closeOnInteractOutside || ctx2.role === "alertdialog") {
                event.preventDefault();
              }
            },
            persistentElements: ctx2.persistentElements,
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onEscapeKeyDown(event) {
              var _a;
              (_a = ctx2.onEscapeKeyDown) == null ? void 0 : _a.call(ctx2, event);
              if (!ctx2.closeOnEscape) {
                event.preventDefault();
              } else {
                send({ type: "CLOSE", src: "escape-key" });
              }
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        preventScroll(ctx2) {
          if (!ctx2.preventScroll)
            return;
          return preventBodyScroll(dom10.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.trapFocus || !ctx2.modal)
            return;
          let trap;
          const cleanup = nextTick(() => {
            const contentEl = dom10.getContentEl(ctx2);
            if (!contentEl)
              return;
            trap = createFocusTrap(contentEl, {
              document: dom10.getDoc(ctx2),
              escapeDeactivates: false,
              preventScroll: true,
              returnFocusOnDeactivate: false,
              fallbackFocus: contentEl,
              allowOutsideClick: true,
              initialFocus: getInitialFocus({
                root: contentEl,
                getInitialEl: ctx2.initialFocusEl
              })
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => {
            trap == null ? void 0 : trap.deactivate();
            cleanup();
          };
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal)
            return;
          const getElements = () => [dom10.getContentEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        }
      },
      actions: {
        checkInitialFocusEl(ctx2) {
          if (!ctx2.initialFocusEl && ctx2.role === "alertdialog") {
            ctx2.initialFocusEl = () => dom10.getCloseTriggerEl(ctx2);
          }
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            ctx2.renderedElements.title = !!dom10.getTitleEl(ctx2);
            ctx2.renderedElements.description = !!dom10.getDescriptionEl(ctx2);
          });
        },
        syncZIndex(ctx2) {
          raf(() => {
            const contentEl = dom10.getContentEl(ctx2);
            if (!contentEl)
              return;
            const win = dom10.getWin(ctx2);
            const styles = win.getComputedStyle(contentEl);
            const elems = [dom10.getPositionerEl(ctx2), dom10.getBackdropEl(ctx2)];
            elems.forEach((node) => {
              node == null ? void 0 : node.style.setProperty("--z-index", styles.zIndex);
            });
          });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        setFinalFocus(ctx2) {
          if (!ctx2.restoreFocus)
            return;
          queueMicrotask(() => {
            var _a;
            const el = ((_a = ctx2.finalFocusEl) == null ? void 0 : _a.call(ctx2)) ?? dom10.getTriggerEl(ctx2);
            el == null ? void 0 : el.focus({ preventScroll: true });
          });
        }
      }
    }
  );
}
var props8 = createProps()([
  "aria-label",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "finalFocusEl",
  "getRootNode",
  "getRootNode",
  "id",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "preventScroll",
  "restoreFocus",
  "role",
  "trapFocus"
]);
var splitProps8 = createSplitProps(props8);

// node_modules/@zag-js/editable/dist/index.mjs
var anatomy15 = createAnatomy("editable").parts(
  "root",
  "area",
  "label",
  "preview",
  "input",
  "editTrigger",
  "submitTrigger",
  "cancelTrigger",
  "control"
);
var parts11 = anatomy15.build();
var dom11 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `editable:${ctx.id}`;
  },
  getAreaId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.area) ?? `editable:${ctx.id}:area`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `editable:${ctx.id}:label`;
  },
  getPreviewId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.preview) ?? `editable:${ctx.id}:preview`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `editable:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.controls) ?? `editable:${ctx.id}:controls`;
  },
  getSubmitTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.submitTrigger) ?? `editable:${ctx.id}:submit`;
  },
  getCancelTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.cancelTrigger) ?? `editable:${ctx.id}:cancel`;
  },
  getEditTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.editTrigger) ?? `editable:${ctx.id}:edit`;
  },
  getInputEl: (ctx) => dom11.getById(ctx, dom11.getInputId(ctx)),
  getPreviewEl: (ctx) => dom11.getById(ctx, dom11.getPreviewId(ctx)),
  getSubmitTriggerEl: (ctx) => dom11.getById(ctx, dom11.getSubmitTriggerId(ctx)),
  getCancelTriggerEl: (ctx) => dom11.getById(ctx, dom11.getCancelTriggerId(ctx)),
  getEditTriggerEl: (ctx) => dom11.getById(ctx, dom11.getEditTriggerId(ctx))
});
function connect11(state2, send, normalize) {
  const disabled = state2.context.disabled;
  const interactive = state2.context.isInteractive;
  const readOnly = state2.context.readOnly;
  const empty = state2.context.isValueEmpty;
  const invalid = state2.context.invalid;
  const autoResize = state2.context.autoResize;
  const translations = state2.context.translations;
  const editing = state2.matches("edit");
  const placeholderProp = state2.context.placeholder;
  const placeholder = typeof placeholderProp === "string" ? { edit: placeholderProp, preview: placeholderProp } : placeholderProp;
  const value = state2.context.value;
  const valueText = empty ? (placeholder == null ? void 0 : placeholder.preview) ?? "" : value;
  return {
    editing,
    empty,
    value,
    valueText,
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: "" });
    },
    edit() {
      if (!interactive)
        return;
      send("EDIT");
    },
    cancel() {
      if (!interactive)
        return;
      send("CANCEL");
    },
    submit() {
      if (!interactive)
        return;
      send("SUBMIT");
    },
    getRootProps() {
      return normalize.element({
        ...parts11.root.attrs,
        id: dom11.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getAreaProps() {
      return normalize.element({
        ...parts11.area.attrs,
        id: dom11.getAreaId(state2.context),
        dir: state2.context.dir,
        style: autoResize ? { display: "inline-grid" } : void 0,
        "data-focus": dataAttr(editing),
        "data-disabled": dataAttr(disabled),
        "data-placeholder-shown": dataAttr(empty)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts11.label.attrs,
        id: dom11.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom11.getInputId(state2.context),
        "data-focus": dataAttr(editing),
        "data-invalid": dataAttr(invalid),
        onClick() {
          if (editing)
            return;
          const previewEl = dom11.getPreviewEl(state2.context);
          previewEl == null ? void 0 : previewEl.focus({ preventScroll: true });
        }
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts11.input.attrs,
        dir: state2.context.dir,
        "aria-label": translations.input,
        name: state2.context.name,
        form: state2.context.form,
        id: dom11.getInputId(state2.context),
        hidden: autoResize ? void 0 : !editing,
        placeholder: placeholder == null ? void 0 : placeholder.edit,
        maxLength: state2.context.maxLength,
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly,
        "data-readonly": dataAttr(readOnly),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        defaultValue: value,
        size: autoResize ? 1 : void 0,
        onChange(event) {
          send({ type: "TYPE", value: event.currentTarget.value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (isComposingEvent(event))
            return;
          const keyMap2 = {
            Escape() {
              send("CANCEL");
              event.preventDefault();
            },
            Enter(event2) {
              if (event2.currentTarget.localName === "textarea") {
                isModKey(event2) && send("ENTER");
                return;
              }
              if (event2.currentTarget.localName === "input") {
                if (!event2.shiftKey && !event2.metaKey) {
                  send("ENTER");
                  event2.preventDefault();
                }
              }
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            exec2(event);
          }
        },
        style: autoResize ? {
          all: "unset",
          gridArea: "1 / 1 / auto / auto",
          visibility: !editing ? "hidden" : void 0
        } : void 0
      });
    },
    getPreviewProps() {
      return normalize.element({
        id: dom11.getPreviewId(state2.context),
        ...parts11.preview.attrs,
        dir: state2.context.dir,
        "data-placeholder-shown": dataAttr(empty),
        "aria-readonly": ariaAttr(readOnly),
        "data-readonly": dataAttr(disabled),
        "data-disabled": dataAttr(disabled),
        "aria-disabled": ariaAttr(disabled),
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        children: valueText,
        hidden: autoResize ? void 0 : editing,
        tabIndex: interactive && state2.context.isPreviewFocusable ? 0 : void 0,
        onFocus() {
          if (!interactive)
            return;
          send("FOCUS");
        },
        onDoubleClick() {
          if (!interactive)
            return;
          send("DBLCLICK");
        },
        style: autoResize ? {
          whiteSpace: "pre",
          userSelect: "none",
          gridArea: "1 / 1 / auto / auto",
          visibility: editing ? "hidden" : void 0,
          // in event the preview overflow's the parent element
          overflow: "hidden",
          textOverflow: "ellipsis"
        } : void 0
      });
    },
    getEditTriggerProps() {
      return normalize.button({
        ...parts11.editTrigger.attrs,
        id: dom11.getEditTriggerId(state2.context),
        dir: state2.context.dir,
        "aria-label": translations.edit,
        hidden: editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          send("EDIT");
        }
      });
    },
    getControlProps() {
      return normalize.element({
        id: dom11.getControlId(state2.context),
        ...parts11.control.attrs,
        dir: state2.context.dir
      });
    },
    getSubmitTriggerProps() {
      return normalize.button({
        ...parts11.submitTrigger.attrs,
        dir: state2.context.dir,
        id: dom11.getSubmitTriggerId(state2.context),
        "aria-label": translations.submit,
        hidden: !editing,
        disabled,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          send("SUBMIT");
        }
      });
    },
    getCancelTriggerProps() {
      return normalize.button({
        ...parts11.cancelTrigger.attrs,
        dir: state2.context.dir,
        "aria-label": translations.cancel,
        id: dom11.getCancelTriggerId(state2.context),
        hidden: !editing,
        type: "button",
        disabled,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          send("CANCEL");
        }
      });
    }
  };
}
function machine11(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "editable",
      initial: ctx.startWithEditView ? "edit" : "preview",
      entry: ctx.startWithEditView ? ["focusInput"] : void 0,
      context: {
        activationMode: "focus",
        submitMode: "both",
        value: "",
        previousValue: "",
        selectOnFocus: true,
        disabled: false,
        readOnly: false,
        ...ctx,
        translations: {
          input: "editable input",
          edit: "edit",
          submit: "submit",
          cancel: "cancel",
          ...ctx.translations
        }
      },
      watch: {
        value: ["syncInputValue"]
      },
      computed: {
        submitOnEnter: (ctx2) => ["both", "enter"].includes(ctx2.submitMode),
        submitOnBlur: (ctx2) => ["both", "blur"].includes(ctx2.submitMode),
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isPreviewFocusable: (ctx2) => ctx2.activationMode === "focus"
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        }
      },
      states: {
        preview: {
          // // https://bugzilla.mozilla.org/show_bug.cgi?id=559561
          entry: ["blurInputIfNeeded"],
          on: {
            EDIT: {
              target: "edit",
              actions: ["focusInput", "invokeOnEdit"]
            },
            DBLCLICK: {
              guard: "activateOnDblClick",
              target: "edit",
              actions: ["focusInput", "invokeOnEdit"]
            },
            FOCUS: {
              guard: "activateOnFocus",
              target: "edit",
              actions: ["setPreviousValue", "focusInput", "invokeOnEdit"]
            }
          }
        },
        edit: {
          activities: ["trackInteractOutside"],
          on: {
            TYPE: {
              actions: "setValue"
            },
            BLUR: [
              {
                guard: "submitOnBlur",
                target: "preview",
                actions: ["restoreFocus", "invokeOnSubmit"]
              },
              {
                target: "preview",
                actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
              }
            ],
            CANCEL: {
              target: "preview",
              actions: ["revertValue", "restoreFocus", "invokeOnCancel"]
            },
            ENTER: {
              guard: "submitOnEnter",
              target: "preview",
              actions: ["setPreviousValue", "invokeOnSubmit", "restoreFocus"]
            },
            SUBMIT: {
              target: "preview",
              actions: ["setPreviousValue", "invokeOnSubmit", "restoreFocus"]
            }
          }
        }
      }
    },
    {
      guards: {
        submitOnBlur: (ctx2) => ctx2.submitOnBlur,
        submitOnEnter: (ctx2) => ctx2.submitOnEnter,
        activateOnDblClick: (ctx2) => ctx2.activationMode === "dblclick",
        activateOnFocus: (ctx2) => ctx2.activationMode === "focus"
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom11.getInputEl(ctx2), {
            exclude(target) {
              const ignore = [dom11.getCancelTriggerEl(ctx2), dom11.getSubmitTriggerEl(ctx2)];
              return ignore.some((el) => contains(el, target));
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              if (event.defaultPrevented)
                return;
              const { focusable: focusable3 } = event.detail;
              send({ type: "BLUR", src: "interact-outside", focusable: focusable3 });
            }
          });
        }
      },
      actions: {
        restoreFocus(ctx2, evt) {
          if (evt.focusable)
            return;
          raf(() => {
            var _a;
            const finalEl = ((_a = ctx2.finalFocusEl) == null ? void 0 : _a.call(ctx2)) ?? dom11.getEditTriggerEl(ctx2);
            finalEl == null ? void 0 : finalEl.focus({ preventScroll: true });
          });
        },
        focusInput(ctx2) {
          raf(() => {
            const inputEl = dom11.getInputEl(ctx2);
            if (!inputEl)
              return;
            if (ctx2.selectOnFocus) {
              inputEl.select();
            } else {
              inputEl.focus({ preventScroll: true });
            }
          });
        },
        invokeOnCancel(ctx2) {
          var _a;
          (_a = ctx2.onValueRevert) == null ? void 0 : _a.call(ctx2, { value: ctx2.previousValue });
        },
        invokeOnSubmit(ctx2) {
          var _a;
          (_a = ctx2.onValueCommit) == null ? void 0 : _a.call(ctx2, { value: ctx2.value });
        },
        invokeOnEdit(ctx2) {
          var _a;
          (_a = ctx2.onEdit) == null ? void 0 : _a.call(ctx2);
        },
        syncInputValue(ctx2) {
          sync3.value(ctx2);
        },
        setValue(ctx2, evt) {
          const value = ctx2.maxLength != null ? evt.value.slice(0, ctx2.maxLength) : evt.value;
          set9.value(ctx2, value);
        },
        setPreviousValue(ctx2) {
          ctx2.previousValue = ctx2.value;
        },
        revertValue(ctx2) {
          set9.value(ctx2, ctx2.previousValue);
        },
        blurInputIfNeeded(ctx2) {
          var _a;
          (_a = dom11.getInputEl(ctx2)) == null ? void 0 : _a.blur();
        }
      }
    }
  );
}
var sync3 = {
  value: (ctx) => {
    const inputEl = dom11.getInputEl(ctx);
    dom11.setValue(inputEl, ctx.value);
  }
};
var invoke7 = {
  change(ctx) {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: ctx.value });
    sync3.value(ctx);
  }
};
var set9 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke7.change(ctx);
  }
};
var props9 = createProps()([
  "activationMode",
  "autoResize",
  "dir",
  "disabled",
  "finalFocusEl",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "maxLength",
  "name",
  "onEdit",
  "onFocusOutside",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueCommit",
  "onValueRevert",
  "placeholder",
  "readOnly",
  "selectOnFocus",
  "startWithEditView",
  "submitMode",
  "translations",
  "value"
]);
var splitProps9 = createSplitProps(props9);

// node_modules/@zag-js/i18n-utils/dist/index.mjs
function i18nCache(Ins) {
  const formatterCache = /* @__PURE__ */ new Map();
  return function create(locale, options) {
    const cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
    if (formatterCache.has(cacheKey)) {
      return formatterCache.get(cacheKey);
    }
    let formatter = new Ins(locale, options);
    formatterCache.set(cacheKey, formatter);
    return formatter;
  };
}
var getNumberFormatter = i18nCache(Intl.NumberFormat);
function formatNumber(v, locale, options = {}) {
  const formatter = getNumberFormatter(locale, options);
  return formatter.format(v);
}
var bitPrefixes = ["", "kilo", "mega", "giga", "tera"];
var bytePrefixes = ["", "kilo", "mega", "giga", "tera", "peta"];
var formatBytes = (bytes, locale = "en-US", options = {}) => {
  if (isNaN(bytes))
    return "";
  if (bytes === 0)
    return "0 B";
  const { unit = "byte", unitDisplay = "short" } = options;
  const prefix = unit === "bit" ? bitPrefixes : bytePrefixes;
  const index = Math.max(0, Math.min(Math.floor(Math.log10(bytes) / 3), prefix.length - 1));
  const _unit = prefix[index] + unit;
  const _unitDisplay = unitDisplay || "short";
  const v = parseFloat((bytes / Math.pow(1e3, index)).toPrecision(3));
  return formatNumber(v, locale, {
    style: "unit",
    unit: _unit,
    unitDisplay: _unitDisplay
  });
};
var getListFormatter = i18nCache(Intl.ListFormat);
var getRelativeTimeFormatter = i18nCache(Intl.RelativeTimeFormat);
var MINUTE_TO_MS = 1e3 * 60;
var HOUR_TO_MS = 1e3 * 60 * 60;
var DAY_TO_MS = 1e3 * 60 * 60 * 24;
var WEEK_TO_MS = 1e3 * 60 * 60 * 24 * 7;
var MONTH_TO_MS = 1e3 * 60 * 60 * 24 * 30;
var YEAR_TO_MS = 1e3 * 60 * 60 * 24 * 365;
var RTL_SCRIPTS = /* @__PURE__ */ new Set([
  "Avst",
  "Arab",
  "Armi",
  "Syrc",
  "Samr",
  "Mand",
  "Thaa",
  "Mend",
  "Nkoo",
  "Adlm",
  "Rohg",
  "Hebr"
]);
var RTL_LANGS = /* @__PURE__ */ new Set([
  "ae",
  "ar",
  "arc",
  "bcc",
  "bqi",
  "ckb",
  "dv",
  "fa",
  "glk",
  "he",
  "ku",
  "mzn",
  "nqo",
  "pnb",
  "ps",
  "sd",
  "ug",
  "ur",
  "yi"
]);
function isRTL2(locale) {
  if (Intl.Locale) {
    const script = new Intl.Locale(locale).maximize().script ?? "";
    return RTL_SCRIPTS.has(script);
  }
  const lang = locale.split("-")[0];
  return RTL_LANGS.has(lang);
}

// node_modules/@zag-js/file-utils/dist/index.mjs
function isMIMEType(v) {
  return v === "audio/*" || v === "video/*" || v === "image/*" || v === "text/*" || /\w+\/[-+.\w]+/g.test(v);
}
function isExt(v) {
  return /^.*\.[\w]+$/.test(v);
}
function getAcceptAttrString(accept) {
  if (!accept)
    return;
  if (typeof accept === "string")
    return accept;
  return Object.entries(accept).reduce((a2, [mimeType, ext]) => [...a2, mimeType, ...ext], []).filter((v) => isMIMEType(v) || isExt(v)).join(",");
}
var isFileEqual = (file1, file2) => {
  return file1.name === file2.name && file1.size === file2.size && file1.type === file2.type;
};
var isDefined = (v) => v !== void 0 && v !== null;
function isValidFileSize(file, minSize, maxSize) {
  if (isDefined(file.size)) {
    if (isDefined(minSize) && isDefined(maxSize)) {
      if (file.size > maxSize)
        return [false, "FILE_TOO_LARGE"];
      if (file.size < minSize)
        return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(minSize) && file.size < minSize) {
      return [false, "FILE_TOO_SMALL"];
    } else if (isDefined(maxSize) && file.size > maxSize) {
      return [false, "FILE_TOO_LARGE"];
    }
  }
  return [true, null];
}
function isFileAccepted(file, accept) {
  if (file && accept) {
    const types = Array.isArray(accept) ? accept : accept.split(",");
    const fileName = file.name || "";
    const mimeType = (file.type || "").toLowerCase();
    const baseMimeType = mimeType.replace(/\/.*$/, "");
    return types.some((type) => {
      const validType = type.trim().toLowerCase();
      if (validType.charAt(0) === ".") {
        return fileName.toLowerCase().endsWith(validType);
      }
      if (validType.endsWith("/*")) {
        return baseMimeType === validType.replace(/\/.*$/, "");
      }
      return mimeType === validType;
    });
  }
  return true;
}
function isValidFileType(file, accept) {
  const isAcceptable = file.type === "application/x-moz-file" || isFileAccepted(file, accept);
  return [isAcceptable, isAcceptable ? null : "FILE_INVALID_TYPE"];
}

// node_modules/@zag-js/file-upload/dist/index.mjs
var anatomy16 = createAnatomy("file-upload").parts(
  "root",
  "dropzone",
  "item",
  "itemDeleteTrigger",
  "itemGroup",
  "itemName",
  "itemPreview",
  "itemPreviewImage",
  "itemSizeText",
  "label",
  "trigger"
);
var parts12 = anatomy16.build();
var dom12 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `file:${ctx.id}`;
  },
  getDropzoneId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.dropzone) ?? `file:${ctx.id}:dropzone`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `file:${ctx.id}:input`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `file:${ctx.id}:trigger`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `file:${ctx.id}:label`;
  },
  getItemId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, id)) ?? `file:${ctx.id}:item:${id}`;
  },
  getItemNameId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemName) == null ? void 0 : _b.call(_a, id)) ?? `file:${ctx.id}:item-name:${id}`;
  },
  getItemSizeTextId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemSizeText) == null ? void 0 : _b.call(_a, id)) ?? `file:${ctx.id}:item-size:${id}`;
  },
  getItemPreviewId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemPreview) == null ? void 0 : _b.call(_a, id)) ?? `file:${ctx.id}:item-preview:${id}`;
  },
  getHiddenInputEl: (ctx) => dom12.getById(ctx, dom12.getHiddenInputId(ctx)),
  getDropzoneEl: (ctx) => dom12.getById(ctx, dom12.getDropzoneId(ctx))
});
function isEventWithFiles(event) {
  if (!event.dataTransfer)
    return !!event.target && "files" in event.target;
  return event.dataTransfer.types.some((type) => {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function isFilesWithinRange(ctx, incomingCount) {
  if (!ctx.multiple && incomingCount > 1)
    return false;
  if (!ctx.multiple && incomingCount + ctx.acceptedFiles.length === 2)
    return true;
  if (incomingCount + ctx.acceptedFiles.length > ctx.maxFiles)
    return false;
  return true;
}
function getFilesFromEvent(ctx, files) {
  const acceptedFiles = [];
  const rejectedFiles = [];
  files.forEach((file) => {
    var _a;
    const [accepted, acceptError] = isValidFileType(file, ctx.acceptAttr);
    const [sizeMatch, sizeError] = isValidFileSize(file, ctx.minFileSize, ctx.maxFileSize);
    const validateErrors = (_a = ctx.validate) == null ? void 0 : _a.call(ctx, file);
    const valid = validateErrors ? validateErrors.length === 0 : true;
    if (accepted && sizeMatch && valid) {
      acceptedFiles.push(file);
    } else {
      const errors = [acceptError, sizeError];
      if (!valid)
        errors.push(...validateErrors ?? []);
      rejectedFiles.push({ file, errors: errors.filter(Boolean) });
    }
  });
  if (!isFilesWithinRange(ctx, acceptedFiles.length)) {
    acceptedFiles.forEach((file) => {
      rejectedFiles.push({ file, errors: ["TOO_MANY_FILES"] });
    });
    acceptedFiles.splice(0);
  }
  return {
    acceptedFiles,
    rejectedFiles
  };
}
function connect12(state2, send, normalize) {
  const disabled = state2.context.disabled;
  const allowDrop = state2.context.allowDrop;
  const translations = state2.context.translations;
  const dragging = state2.matches("dragging");
  const focused = state2.matches("focused") && !disabled;
  return {
    dragging,
    focused,
    openFilePicker() {
      send("OPEN");
    },
    deleteFile(file) {
      send({ type: "FILE.DELETE", file });
    },
    acceptedFiles: state2.context.acceptedFiles,
    rejectedFiles: state2.context.rejectedFiles,
    setFiles(files) {
      const count = files.length;
      send({ type: "FILES.SET", files, count });
    },
    clearFiles() {
      send({ type: "FILES.CLEAR" });
    },
    getFileSize(file) {
      return formatBytes(file.size, state2.context.locale);
    },
    createFileUrl(file, cb) {
      const win = dom12.getWin(state2.context);
      const url = win.URL.createObjectURL(file);
      cb(url);
      return () => win.URL.revokeObjectURL(url);
    },
    getRootProps() {
      return normalize.element({
        ...parts12.root.attrs,
        dir: state2.context.dir,
        id: dom12.getRootId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging)
      });
    },
    getDropzoneProps() {
      return normalize.element({
        ...parts12.dropzone.attrs,
        dir: state2.context.dir,
        id: dom12.getDropzoneId(state2.context),
        tabIndex: disabled ? void 0 : 0,
        "aria-disabled": disabled,
        "aria-invalid": state2.context.invalid,
        "data-invalid": dataAttr(state2.context.invalid),
        "data-disabled": dataAttr(disabled),
        "data-dragging": dataAttr(dragging),
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!isSelfTarget(event))
            return;
          if (event.key !== "Enter" && event.key !== " ")
            return;
          send({ type: "DROPZONE.CLICK", src: "keydown" });
        },
        onClick(event) {
          const isLabel = event.currentTarget.localName === "label";
          if (isLabel)
            event.preventDefault();
          send("DROPZONE.CLICK");
        },
        onDragOver(event) {
          if (!allowDrop)
            return;
          event.preventDefault();
          event.stopPropagation();
          try {
            event.dataTransfer.dropEffect = "copy";
          } catch {
          }
          const hasFiles = isEventWithFiles(event);
          if (!hasFiles)
            return;
          const count = event.dataTransfer.items.length;
          send({ type: "DROPZONE.DRAG_OVER", count });
        },
        onDragLeave(event) {
          if (!allowDrop || disabled)
            return;
          if (contains(event.currentTarget, event.relatedTarget))
            return;
          send({ type: "DROPZONE.DRAG_LEAVE" });
        },
        onDrop(event) {
          if (allowDrop) {
            event.preventDefault();
            event.stopPropagation();
          }
          const hasFiles = isEventWithFiles(event);
          if (disabled || !hasFiles)
            return;
          send({ type: "DROPZONE.DROP", files: Array.from(event.dataTransfer.files) });
        },
        onFocus() {
          send("DROPZONE.FOCUS");
        },
        onBlur() {
          send("DROPZONE.BLUR");
        }
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts12.trigger.attrs,
        dir: state2.context.dir,
        id: dom12.getTriggerId(state2.context),
        disabled,
        "data-disabled": dataAttr(disabled),
        type: "button",
        onClick(event) {
          if (disabled)
            return;
          if (contains(dom12.getDropzoneEl(state2.context), event.currentTarget)) {
            event.stopPropagation();
          }
          send("OPEN");
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: dom12.getHiddenInputId(state2.context),
        tabIndex: -1,
        disabled,
        type: "file",
        capture: state2.context.capture,
        name: state2.context.name,
        accept: state2.context.acceptAttr,
        webkitdirectory: state2.context.capture ? "" : void 0,
        multiple: state2.context.multiple || state2.context.maxFiles > 1,
        onClick(event) {
          event.stopPropagation();
          event.currentTarget.value = "";
        },
        onChange(event) {
          if (disabled)
            return;
          const { files } = event.currentTarget;
          send({ type: "FILES.SET", files: files ? Array.from(files) : [] });
        },
        style: visuallyHiddenStyle
      });
    },
    getItemGroupProps() {
      return normalize.element({
        ...parts12.itemGroup.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemProps(props29) {
      const { file } = props29;
      return normalize.element({
        ...parts12.item.attrs,
        dir: state2.context.dir,
        id: dom12.getItemId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemNameProps(props29) {
      const { file } = props29;
      return normalize.element({
        ...parts12.itemName.attrs,
        dir: state2.context.dir,
        id: dom12.getItemNameId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemSizeTextProps(props29) {
      const { file } = props29;
      return normalize.element({
        ...parts12.itemSizeText.attrs,
        dir: state2.context.dir,
        id: dom12.getItemSizeTextId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props29) {
      const { file } = props29;
      return normalize.element({
        ...parts12.itemPreview.attrs,
        dir: state2.context.dir,
        id: dom12.getItemPreviewId(state2.context, file.name),
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewImageProps(props29) {
      const { file, url } = props29;
      const isImage = file.type.startsWith("image/");
      if (!isImage) {
        throw new Error("Preview Image is only supported for image files");
      }
      return normalize.img({
        ...parts12.itemPreviewImage.attrs,
        alt: translations.itemPreview(file),
        src: url,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemDeleteTriggerProps(props29) {
      const { file } = props29;
      return normalize.button({
        ...parts12.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        type: "button",
        disabled,
        "data-disabled": dataAttr(disabled),
        "aria-label": translations.deleteFile(file),
        onClick() {
          if (disabled)
            return;
          send({ type: "FILE.DELETE", file });
        }
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts12.label.attrs,
        dir: state2.context.dir,
        id: dom12.getLabelId(state2.context),
        htmlFor: dom12.getHiddenInputId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    }
  };
}
var { not: not5 } = guards;
function machine12(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "fileupload",
      initial: "idle",
      context: {
        minFileSize: 0,
        maxFileSize: Infinity,
        maxFiles: 1,
        allowDrop: true,
        ...ctx,
        acceptedFiles: ref([]),
        rejectedFiles: ref([]),
        invalid: false,
        translations: {
          itemPreview: (file) => `preview of ${file.name}`,
          deleteFile: (file) => `delete file ${file.name}`,
          ...ctx.translations
        }
      },
      computed: {
        acceptAttr: (ctx2) => getAcceptAttrString(ctx2.accept),
        multiple: (ctx2) => ctx2.maxFiles > 1
      },
      on: {
        "FILES.SET": {
          actions: ["setFilesFromEvent"]
        },
        "FILE.DELETE": {
          actions: ["removeFile"]
        },
        "FILES.CLEAR": {
          actions: ["clearFiles"]
        }
      },
      states: {
        idle: {
          on: {
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.FOCUS": "focused",
            "DROPZONE.DRAG_OVER": [
              {
                guard: not5("isWithinRange"),
                target: "dragging",
                actions: ["setInvalid"]
              },
              { target: "dragging" }
            ]
          }
        },
        focused: {
          on: {
            "DROPZONE.BLUR": "idle",
            OPEN: {
              actions: ["openFilePicker"]
            },
            "DROPZONE.CLICK": {
              actions: ["openFilePicker"]
            },
            "DROPZONE.DRAG_OVER": [
              {
                guard: not5("isWithinRange"),
                target: "dragging",
                actions: ["setInvalid"]
              },
              { target: "dragging" }
            ]
          }
        },
        dragging: {
          on: {
            "DROPZONE.DROP": {
              target: "idle",
              actions: ["clearInvalid", "setFilesFromEvent", "syncInputElement"]
            },
            "DROPZONE.DRAG_LEAVE": {
              target: "idle",
              actions: ["clearInvalid"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2, evt) => isFilesWithinRange(ctx2, evt.count)
      },
      actions: {
        syncInputElement(ctx2) {
          const inputEl = dom12.getHiddenInputEl(ctx2);
          if (!inputEl)
            return;
          const win = dom12.getWin(ctx2);
          const dataTransfer = new win.DataTransfer();
          ctx2.acceptedFiles.forEach((v) => {
            dataTransfer.items.add(v);
          });
          inputEl.files = dataTransfer.files;
        },
        openFilePicker(ctx2) {
          raf(() => {
            var _a;
            (_a = dom12.getHiddenInputEl(ctx2)) == null ? void 0 : _a.click();
          });
        },
        setInvalid(ctx2) {
          ctx2.invalid = true;
        },
        clearInvalid(ctx2) {
          ctx2.invalid = false;
        },
        setFilesFromEvent(ctx2, evt) {
          const result = getFilesFromEvent(ctx2, evt.files);
          const { acceptedFiles, rejectedFiles } = result;
          if (ctx2.multiple) {
            const files = ref([...ctx2.acceptedFiles, ...acceptedFiles]);
            set10.files(ctx2, files, rejectedFiles);
            return;
          }
          if (acceptedFiles.length) {
            const files = ref([acceptedFiles[0]]);
            set10.files(ctx2, files, rejectedFiles);
          } else if (rejectedFiles.length) {
            set10.files(ctx2, [], rejectedFiles);
          }
        },
        removeFile(ctx2, evt) {
          const nextFiles = ctx2.acceptedFiles.filter((file) => file !== evt.file);
          ctx2.acceptedFiles = ref(nextFiles);
          invoke8.change(ctx2);
        },
        clearFiles(ctx2) {
          ctx2.acceptedFiles = ref([]);
          ctx2.rejectedFiles = ref([]);
          invoke8.change(ctx2);
        }
      },
      compareFns: {
        acceptedFiles: (a2, b2) => a2.length === b2.length && a2.every((file, i) => isFileEqual(file, b2[i]))
      }
    }
  );
}
var invoke8 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onFileChange) == null ? void 0 : _a.call(ctx, {
      acceptedFiles: ctx.acceptedFiles,
      rejectedFiles: ctx.rejectedFiles
    });
  },
  accept: (ctx) => {
    var _a;
    (_a = ctx.onFileAccept) == null ? void 0 : _a.call(ctx, { files: ctx.acceptedFiles });
  },
  reject: (ctx) => {
    var _a;
    (_a = ctx.onFileReject) == null ? void 0 : _a.call(ctx, { files: ctx.rejectedFiles });
  }
};
var set10 = {
  files: (ctx, acceptedFiles, rejectedFiles) => {
    ctx.acceptedFiles = ref(acceptedFiles);
    invoke8.accept(ctx);
    if (rejectedFiles) {
      ctx.rejectedFiles = ref(rejectedFiles);
      invoke8.reject(ctx);
    }
    invoke8.change(ctx);
  }
};
var props10 = createProps()([
  "accept",
  "allowDrop",
  "capture",
  "dir",
  "directory",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "locale",
  "maxFiles",
  "maxFileSize",
  "minFileSize",
  "name",
  "onFileAccept",
  "onFileReject",
  "onFileChange",
  "translations",
  "validate"
]);
var splitProps10 = createSplitProps(props10);
var itemProps2 = createProps()(["file"]);
var splitItemProps2 = createSplitProps(itemProps2);

// node_modules/@zag-js/hover-card/dist/index.mjs
var anatomy17 = createAnatomy("hoverCard").parts("arrow", "arrowTip", "trigger", "positioner", "content");
var parts13 = anatomy17.build();
var dom13 = createScope({
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `hover-card:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `hover-card:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `hover-card:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.arrow) ?? `hover-card:${ctx.id}:arrow`;
  },
  getTriggerEl: (ctx) => dom13.getById(ctx, dom13.getTriggerId(ctx)),
  getContentEl: (ctx) => dom13.getById(ctx, dom13.getContentId(ctx)),
  getPositionerEl: (ctx) => dom13.getById(ctx, dom13.getPositionerId(ctx))
});
function connect13(state2, send, normalize) {
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize.element({
        id: dom13.getArrowId(state2.context),
        ...parts13.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts13.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getTriggerProps() {
      return normalize.element({
        ...parts13.trigger.attrs,
        dir: state2.context.dir,
        "data-placement": state2.context.currentPlacement,
        id: dom13.getTriggerId(state2.context),
        "data-state": open ? "open" : "closed",
        onPointerEnter(event) {
          if (event.pointerType === "touch")
            return;
          send({ type: "POINTER_ENTER", src: "trigger" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch")
            return;
          send({ type: "POINTER_LEAVE", src: "trigger" });
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onTouchStart(event) {
          event.preventDefault();
        }
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: dom13.getPositionerId(state2.context),
        ...parts13.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts13.content.attrs,
        dir: state2.context.dir,
        id: dom13.getContentId(state2.context),
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType === "touch")
            return;
          send({ type: "POINTER_ENTER", src: "content" });
        },
        onPointerLeave(event) {
          if (event.pointerType === "touch")
            return;
          send({ type: "POINTER_LEAVE", src: "content" });
        }
      });
    }
  };
}
var { not: not6, and: and6 } = guards;
function machine13(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "hover-card",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 700,
        closeDelay: 300,
        currentPlacement: void 0,
        ...ctx,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      watch: {
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearIsPointer"],
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_ENTER: {
              target: "opening",
              actions: ["setIsPointer"]
            },
            TRIGGER_FOCUS: "opening",
            OPEN: "opening"
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and6("isOpenControlled", not6("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not6("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackDismissableElement", "trackPositioning"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              actions: ["setIsPointer"]
            },
            POINTER_LEAVE: "closing",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            TRIGGER_BLUR: [
              {
                guard: and6("isOpenControlled", not6("isPointer")),
                actions: ["invokeOnClose"]
              },
              {
                guard: not6("isPointer"),
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            POINTER_ENTER: {
              target: "open",
              // no need to invokeOnOpen here because it's still open (but about to close)
              actions: ["setIsPointer"]
            }
          }
        }
      }
    },
    {
      guards: {
        isPointer: (ctx2) => !!ctx2.isPointer,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom13.getPositionerEl(ctx2);
          return getPlacement(dom13.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom13.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom13.getTriggerEl(ctx2)],
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            },
            onFocusOutside(event) {
              event.preventDefault();
            }
          });
        }
      },
      actions: {
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        setIsPointer(ctx2) {
          ctx2.isPointer = true;
        },
        clearIsPointer(ctx2) {
          ctx2.isPointer = false;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom13.getPositionerEl(ctx2);
          getPlacement(dom13.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props11 = createProps()([
  "closeDelay",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps11 = createSplitProps(props11);

// node_modules/@zag-js/rect-utils/dist/index.mjs
var createPoint = (x, y) => ({ x, y });
function createRect(r) {
  const { x, y, width, height } = r;
  const midX = x + width / 2;
  const midY = y + height / 2;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height,
    midX,
    midY,
    center: createPoint(midX, midY)
  };
}
function getRectCorners(v) {
  const top = createPoint(v.minX, v.minY);
  const right = createPoint(v.maxX, v.minY);
  const bottom = createPoint(v.maxX, v.maxY);
  const left = createPoint(v.minX, v.maxY);
  return { top, right, bottom, left };
}
var { min: min2, max: max2 } = Math;
function getElementPolygon(rectValue, placement) {
  const rect = createRect(rectValue);
  const { top, right, left, bottom } = getRectCorners(rect);
  const [base] = placement.split("-");
  return {
    top: [left, top, right, bottom],
    right: [top, right, bottom, left],
    bottom: [top, left, bottom, right],
    left: [right, top, left, bottom]
  }[base];
}
function isPointInPolygon(polygon, point) {
  const { x, y } = point;
  let c = false;
  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i].x;
    const yi = polygon[i].y;
    const xj = polygon[j].x;
    const yj = polygon[j].y;
    if (yi > y !== yj > y && x < (xj - xi) * (y - yi) / (yj - yi) + xi) {
      c = !c;
    }
  }
  return c;
}
var { sign, abs, min: min22 } = Math;

// node_modules/@zag-js/menu/dist/index.mjs
var anatomy18 = createAnatomy("menu").parts(
  "arrow",
  "arrowTip",
  "content",
  "contextTrigger",
  "indicator",
  "item",
  "itemGroup",
  "itemGroupLabel",
  "itemIndicator",
  "itemText",
  "positioner",
  "separator",
  "trigger",
  "triggerItem"
);
var parts14 = anatomy18.build();
var dom14 = createScope({
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `menu:${ctx.id}:trigger`;
  },
  getContextTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.contextTrigger) ?? `menu:${ctx.id}:ctx-trigger`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `menu:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.arrow) ?? `menu:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `menu:${ctx.id}:popper`;
  },
  getGroupId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.group) == null ? void 0 : _b.call(_a, id)) ?? `menu:${ctx.id}:group:${id}`;
  },
  getGroupLabelId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.label) == null ? void 0 : _b.call(_a, id)) ?? `menu:${ctx.id}:label:${id}`;
  },
  getContentEl: (ctx) => dom14.getById(ctx, dom14.getContentId(ctx)),
  getPositionerEl: (ctx) => dom14.getById(ctx, dom14.getPositionerId(ctx)),
  getTriggerEl: (ctx) => dom14.getById(ctx, dom14.getTriggerId(ctx)),
  getHighlightedItemEl: (ctx) => ctx.highlightedValue ? dom14.getById(ctx, ctx.highlightedValue) : null,
  getArrowEl: (ctx) => dom14.getById(ctx, dom14.getArrowId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom14.getContentId(ctx));
    const selector = `[role^="menuitem"][data-ownedby=${ownerId}]:not([data-disabled])`;
    return queryAll(dom14.getContentEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom14.getElements(ctx)),
  getLastEl: (ctx) => last(dom14.getElements(ctx)),
  getNextEl: (ctx, loop) => nextById(dom14.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getPrevEl: (ctx, loop) => prevById(dom14.getElements(ctx), ctx.highlightedValue, loop ?? ctx.loopFocus),
  getElemByKey: (ctx, key) => getByTypeahead(dom14.getElements(ctx), { state: ctx.typeaheadState, key, activeId: ctx.highlightedValue }),
  isTargetDisabled: (v) => {
    return isHTMLElement(v) && (v.dataset.disabled === "" || v.hasAttribute("disabled"));
  },
  isTriggerItem: (el) => {
    var _a;
    return !!((_a = el == null ? void 0 : el.getAttribute("role")) == null ? void 0 : _a.startsWith("menuitem")) && !!(el == null ? void 0 : el.hasAttribute("aria-controls"));
  },
  getOptionFromItemEl(el) {
    return {
      id: el.id,
      name: el.dataset.name,
      value: el.dataset.value,
      valueText: el.dataset.valueText,
      type: el.dataset.type
    };
  }
});
function connect14(state2, send, normalize) {
  const isSubmenu = state2.context.isSubmenu;
  const isTypingAhead = state2.context.isTypingAhead;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.anchorPoint ? "bottom" : state2.context.currentPlacement
  });
  function getItemState(props29) {
    return {
      disabled: !!props29.disabled,
      highlighted: state2.context.highlightedValue === props29.value
    };
  }
  function getOptionItemProps(props29) {
    const valueText = props29.valueText ?? props29.value;
    return { ...props29, id: props29.value, valueText };
  }
  function getOptionItemState(props29) {
    const itemState = getItemState(getOptionItemProps(props29));
    return {
      ...itemState,
      checked: !!props29.checked
    };
  }
  function getItemProps(props29) {
    const { value: id, closeOnSelect, valueText } = props29;
    const itemState = getItemState(props29);
    return normalize.element({
      ...parts14.item.attrs,
      id,
      role: "menuitem",
      "aria-disabled": itemState.disabled,
      "data-disabled": dataAttr(itemState.disabled),
      "data-ownedby": dom14.getContentId(state2.context),
      "data-highlighted": dataAttr(itemState.highlighted),
      "data-valuetext": valueText,
      onDragStart(event) {
        const isLink = event.currentTarget.matches("a[href]");
        if (isLink)
          event.preventDefault();
      },
      onPointerMove(event) {
        if (itemState.disabled)
          return;
        if (event.pointerType !== "mouse")
          return;
        const target = event.currentTarget;
        if (itemState.highlighted)
          return;
        send({ type: "ITEM_POINTERMOVE", id, target, closeOnSelect });
      },
      onPointerLeave(event) {
        if (itemState.disabled)
          return;
        if (event.pointerType !== "mouse")
          return;
        const mouseMoved = state2.previousEvent.type.includes("POINTER");
        if (!mouseMoved)
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERLEAVE", id, target, closeOnSelect });
      },
      onPointerDown(event) {
        if (itemState.disabled)
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_POINTERDOWN", target, id, closeOnSelect });
      },
      onPointerUp(event) {
        if (isDownloadingEvent(event))
          return;
        if (isOpeningInNewTab(event))
          return;
        if (itemState.disabled)
          return;
        if (!isLeftClick(event))
          return;
        const target = event.currentTarget;
        send({ type: "ITEM_CLICK", src: "pointerup", target, id, closeOnSelect });
        if (event.pointerType === "touch")
          clickIfLink(target);
      },
      onTouchEnd(event) {
        event.preventDefault();
        event.stopPropagation();
      }
    });
  }
  return {
    highlightedValue: state2.context.highlightedValue,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    setHighlightedValue(value) {
      send({ type: "HIGHLIGHTED.SET", id: value });
    },
    setParent(parent) {
      send({ type: "PARENT.SET", value: parent, id: parent.state.context.id });
    },
    setChild(child) {
      send({ type: "CHILD.SET", value: child, id: child.state.context.id });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getContextTriggerProps() {
      return normalize.element({
        ...parts14.contextTrigger.attrs,
        dir: state2.context.dir,
        id: dom14.getContextTriggerId(state2.context),
        onPointerDown(event) {
          if (event.pointerType === "mouse")
            return;
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU_START", point });
        },
        onPointerCancel(event) {
          if (event.pointerType === "mouse")
            return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerMove(event) {
          if (event.pointerType === "mouse")
            return;
          send("CONTEXT_MENU_CANCEL");
        },
        onPointerUp(event) {
          if (event.pointerType === "mouse")
            return;
          send("CONTEXT_MENU_CANCEL");
        },
        onContextMenu(event) {
          const point = getEventPoint(event);
          send({ type: "CONTEXT_MENU", point });
          event.preventDefault();
        },
        style: {
          WebkitTouchCallout: "none",
          userSelect: "none"
        }
      });
    },
    getTriggerItemProps(childApi) {
      return mergeProps(
        getItemProps({ value: childApi.getTriggerProps().id }),
        childApi.getTriggerProps()
      );
    },
    getTriggerProps() {
      return normalize.button({
        ...isSubmenu ? parts14.triggerItem.attrs : parts14.trigger.attrs,
        "data-placement": state2.context.currentPlacement,
        type: "button",
        dir: state2.context.dir,
        id: dom14.getTriggerId(state2.context),
        "data-uid": state2.context.id,
        "aria-haspopup": composite ? "menu" : "dialog",
        "aria-controls": dom14.getContentId(state2.context),
        "aria-expanded": open || void 0,
        "data-state": open ? "open" : "closed",
        onPointerMove(event) {
          if (event.pointerType !== "mouse")
            return;
          const disabled = dom14.isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu)
            return;
          send({ type: "TRIGGER_POINTERMOVE", target: event.currentTarget });
        },
        onPointerLeave(event) {
          if (event.pointerType !== "mouse")
            return;
          const disabled = dom14.isTargetDisabled(event.currentTarget);
          if (disabled || !isSubmenu)
            return;
          const point = getEventPoint(event);
          send({ type: "TRIGGER_POINTERLEAVE", target: event.currentTarget, point });
        },
        onClick(event) {
          if (dom14.isTriggerItem(event.currentTarget)) {
            send({ type: "TRIGGER_CLICK", target: event.currentTarget });
          }
        },
        onPointerDown(event) {
          const disabled = dom14.isTargetDisabled(event.currentTarget);
          if (!isLeftClick(event) || disabled || isContextMenuEvent(event))
            return;
          event.preventDefault();
          if (!dom14.isTriggerItem(event.currentTarget)) {
            send({ type: "TRIGGER_CLICK", target: event.currentTarget });
          }
        },
        onBlur() {
          send("TRIGGER_BLUR");
        },
        onFocus() {
          send("TRIGGER_FOCUS");
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            Enter() {
              send({ type: "ARROW_DOWN", src: "enter" });
            },
            Space() {
              send({ type: "ARROW_DOWN", src: "space" });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts14.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts14.positioner.attrs,
        dir: state2.context.dir,
        id: dom14.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getArrowProps() {
      return normalize.element({
        id: dom14.getArrowId(state2.context),
        ...parts14.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts14.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts14.content.attrs,
        id: dom14.getContentId(state2.context),
        "aria-label": state2.context["aria-label"],
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: composite ? "menu" : "dialog",
        tabIndex: 0,
        dir: state2.context.dir,
        "aria-activedescendant": state2.context.highlightedValue ?? void 0,
        "aria-labelledby": dom14.getTriggerId(state2.context),
        "data-placement": state2.context.currentPlacement,
        onPointerEnter(event) {
          if (event.pointerType !== "mouse")
            return;
          send("MENU_POINTERENTER");
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!isSelfTarget(event))
            return;
          const target = getEventTarget(event);
          const sameMenu = (target == null ? void 0 : target.closest("[role=menu]")) === event.currentTarget || target === event.currentTarget;
          if (!sameMenu)
            return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const item = dom14.getHighlightedItemEl(state2.context);
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowUp() {
              send("ARROW_UP");
            },
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            Enter() {
              send("ENTER");
              clickIfLink(item);
            },
            Space(event2) {
              var _a;
              if (isTypingAhead) {
                send({ type: "TYPEAHEAD", key: event2.key });
              } else {
                (_a = keyMap2.Enter) == null ? void 0 : _a.call(keyMap2, event2);
              }
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, { dir: state2.context.dir });
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.stopPropagation();
            event.preventDefault();
            return;
          }
          if (!state2.context.typeahead)
            return;
          if (!isPrintableKey(event))
            return;
          if (isModifierKey(event))
            return;
          if (isEditableElement(target))
            return;
          send({ type: "TYPEAHEAD", key: event.key });
          event.preventDefault();
        }
      });
    },
    getSeparatorProps() {
      return normalize.element({
        ...parts14.separator.attrs,
        role: "separator",
        dir: state2.context.dir,
        "aria-orientation": "horizontal"
      });
    },
    getItemState,
    getItemProps,
    getOptionItemState,
    getOptionItemProps(props29) {
      const { type, disabled, onCheckedChange, closeOnSelect } = props29;
      const option = getOptionItemProps(props29);
      const itemState = getOptionItemState(props29);
      return {
        ...getItemProps(option),
        ...normalize.element({
          "data-type": type,
          ...parts14.item.attrs,
          dir: state2.context.dir,
          "data-value": option.value,
          role: `menuitem${type}`,
          "aria-checked": !!itemState.checked,
          "data-state": itemState.checked ? "checked" : "unchecked",
          onPointerUp(event) {
            if (!isLeftClick(event) || disabled)
              return;
            if (isDownloadingEvent(event))
              return;
            if (isOpeningInNewTab(event))
              return;
            const target = event.currentTarget;
            send({ type: "ITEM_CLICK", src: "pointerup", target, option, closeOnSelect });
            onCheckedChange == null ? void 0 : onCheckedChange(!itemState.checked);
          }
        })
      };
    },
    getItemIndicatorProps(props29) {
      const itemState = getOptionItemState(props29);
      return normalize.element({
        ...parts14.itemIndicator.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked",
        hidden: !itemState.checked
      });
    },
    getItemTextProps(props29) {
      const itemState = getOptionItemState(props29);
      return normalize.element({
        ...parts14.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-state": itemState.checked ? "checked" : "unchecked"
      });
    },
    getItemGroupLabelProps(props29) {
      return normalize.element({
        id: dom14.getGroupLabelId(state2.context, props29.htmlFor),
        dir: state2.context.dir,
        ...parts14.itemGroupLabel.attrs
      });
    },
    getItemGroupProps(props29) {
      return normalize.element({
        id: dom14.getGroupId(state2.context, props29.id),
        ...parts14.itemGroup.attrs,
        dir: state2.context.dir,
        "aria-labelledby": dom14.getGroupLabelId(state2.context, props29.id),
        role: "group"
      });
    }
  };
}
var { not: not7, and: and7, or: or2 } = guards;
function machine14(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "menu",
      initial: ctx.open ? "open" : "idle",
      context: {
        highlightedValue: null,
        loopFocus: false,
        anchorPoint: null,
        closeOnSelect: true,
        typeahead: true,
        composite: true,
        ...ctx,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        },
        intentPolygon: null,
        parent: null,
        lastHighlightedValue: null,
        children: cast(ref({})),
        suspendPointer: false,
        restoreFocus: true,
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isSubmenu: (ctx2) => ctx2.parent !== null,
        isRtl: (ctx2) => ctx2.dir === "rtl",
        isTypingAhead: (ctx2) => ctx2.typeaheadState.keysSoFar !== ""
      },
      watch: {
        isSubmenu: "setSubmenuPlacement",
        anchorPoint: "reposition",
        open: "toggleVisibility"
      },
      on: {
        "PARENT.SET": {
          actions: "setParentMenu"
        },
        "CHILD.SET": {
          actions: "setChildMenu"
        },
        OPEN: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnOpen"
          },
          {
            target: "open",
            actions: "invokeOnOpen"
          }
        ],
        OPEN_AUTOFOCUS: [
          {
            guard: "isOpenControlled",
            actions: ["invokeOnOpen"]
          },
          {
            internal: true,
            target: "open",
            actions: ["highlightFirstItem", "invokeOnOpen"]
          }
        ],
        CLOSE: [
          {
            guard: "isOpenControlled",
            actions: "invokeOnClose"
          },
          {
            target: "closed",
            actions: "invokeOnClose"
          }
        ],
        "HIGHLIGHTED.RESTORE": {
          actions: "restoreHighlightedItem"
        },
        "HIGHLIGHTED.SET": {
          actions: "setHighlightedItem"
        }
      },
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_FOCUS: {
              guard: not7("isSubmenu"),
              target: "closed"
            },
            TRIGGER_POINTERMOVE: {
              guard: "isSubmenu",
              target: "opening"
            }
          }
        },
        "opening:contextmenu": {
          tags: ["closed"],
          after: {
            LONG_PRESS_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            CONTEXT_MENU_CANCEL: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          after: {
            SUBMENU_OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            BLUR: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            TRIGGER_POINTERLEAVE: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: "invokeOnClose"
              }
            ]
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackPointerMove", "trackInteractOutside"],
          after: {
            SUBMENU_CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHiglightedItem", "invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["focusParentMenu", "restoreParentHiglightedItem"]
            },
            // don't invoke on open here since the menu is still open (we're only keeping it open)
            MENU_POINTERENTER: {
              target: "open",
              actions: "clearIntentPolygon"
            },
            POINTER_MOVED_AWAY_FROM_SUBMENU: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnClose"
              },
              {
                target: "closed",
                actions: ["focusParentMenu", "restoreParentHiglightedItem"]
              }
            ]
          }
        },
        closed: {
          tags: ["closed"],
          entry: ["clearHighlightedItem", "focusTrigger", "clearAnchorPoint", "resumePointer"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: or2("isOpenAutoFocusEvent", "isArrowDownEvent"),
                target: "open",
                actions: "highlightFirstItem"
              },
              {
                guard: "isArrowUpEvent",
                target: "open",
                actions: "highlightLastItem"
              },
              {
                target: "open"
              }
            ],
            CONTEXT_MENU_START: {
              target: "opening:contextmenu",
              actions: "setAnchorPoint"
            },
            CONTEXT_MENU: [
              {
                guard: "isOpenControlled",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setAnchorPoint", "invokeOnOpen"]
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: "invokeOnOpen"
              }
            ],
            TRIGGER_POINTERMOVE: {
              guard: "isTriggerItem",
              target: "opening"
            },
            TRIGGER_BLUR: "idle",
            ARROW_DOWN: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightFirstItem", "invokeOnOpen"]
              }
            ],
            ARROW_UP: [
              {
                guard: "isOpenControlled",
                actions: "invokeOnOpen"
              },
              {
                target: "open",
                actions: ["highlightLastItem", "invokeOnOpen"]
              }
            ]
          }
        },
        open: {
          tags: ["open"],
          activities: ["trackInteractOutside", "trackPositioning", "scrollToHighlightedItem"],
          entry: ["focusMenu", "resumePointer"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                target: "closed",
                guard: "isArrowLeftEvent",
                actions: ["focusParentMenu"]
              },
              {
                target: "closed"
              }
            ],
            TRIGGER_CLICK: [
              {
                guard: and7(not7("isTriggerItem"), "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: not7("isTriggerItem"),
                target: "closed",
                actions: "invokeOnClose"
              }
            ],
            ARROW_UP: {
              actions: ["highlightPrevItem", "focusMenu"]
            },
            ARROW_DOWN: {
              actions: ["highlightNextItem", "focusMenu"]
            },
            ARROW_LEFT: [
              {
                guard: and7("isSubmenu", "isOpenControlled"),
                actions: "invokeOnClose"
              },
              {
                guard: "isSubmenu",
                target: "closed",
                actions: ["focusParentMenu", "invokeOnClose"]
              }
            ],
            HOME: {
              actions: ["highlightFirstItem", "focusMenu"]
            },
            END: {
              actions: ["highlightLastItem", "focusMenu"]
            },
            ARROW_RIGHT: {
              guard: "isTriggerItemHighlighted",
              actions: "openSubmenu"
            },
            ENTER: [
              {
                guard: "isTriggerItemHighlighted",
                actions: "openSubmenu"
              },
              // == grouped ==
              {
                guard: and7("closeOnSelect", "isOpenControlled"),
                actions: ["clickHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "closed",
                actions: "clickHighlightedItem"
              },
              //
              {
                actions: "clickHighlightedItem"
              }
            ],
            ITEM_POINTERMOVE: [
              {
                guard: not7("suspendPointer"),
                actions: ["setHighlightedItem", "focusMenu"]
              },
              {
                actions: "setLastHighlightedItem"
              }
            ],
            ITEM_POINTERLEAVE: {
              guard: and7(not7("suspendPointer"), not7("isTriggerItem")),
              actions: "clearHighlightedItem"
            },
            ITEM_CLICK: [
              // == grouped ==
              {
                guard: and7(
                  not7("isTriggerItemHighlighted"),
                  not7("isHighlightedItemEditable"),
                  "closeOnSelect",
                  "isOpenControlled"
                ),
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              {
                guard: and7(not7("isTriggerItemHighlighted"), not7("isHighlightedItemEditable"), "closeOnSelect"),
                target: "closed",
                actions: ["invokeOnSelect", "setOptionState", "closeRootMenu", "invokeOnClose"]
              },
              //
              {
                guard: and7(not7("isTriggerItemHighlighted"), not7("isHighlightedItemEditable")),
                actions: ["invokeOnSelect", "setOptionState"]
              },
              { actions: "setHighlightedItem" }
            ],
            TRIGGER_POINTERLEAVE: {
              target: "closing",
              actions: "setIntentPolygon"
            },
            ITEM_POINTERDOWN: {
              actions: "setHighlightedItem"
            },
            TYPEAHEAD: {
              actions: "highlightMatchedItem"
            },
            FOCUS_MENU: {
              actions: "focusMenu"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      delays: {
        LONG_PRESS_DELAY: 700,
        SUBMENU_OPEN_DELAY: 100,
        SUBMENU_CLOSE_DELAY: 100
      },
      guards: {
        closeOnSelect: (ctx2, evt) => !!((evt == null ? void 0 : evt.closeOnSelect) ?? ctx2.closeOnSelect),
        // whether the trigger is also a menu item
        isTriggerItem: (_ctx, evt) => dom14.isTriggerItem(evt.target),
        // whether the trigger item is the active item
        isTriggerItemHighlighted: (ctx2, evt) => {
          const target = evt.target ?? dom14.getHighlightedItemEl(ctx2);
          return !!(target == null ? void 0 : target.hasAttribute("aria-controls"));
        },
        isSubmenu: (ctx2) => ctx2.isSubmenu,
        suspendPointer: (ctx2) => ctx2.suspendPointer,
        isHighlightedItemEditable: (ctx2) => isEditableElement(dom14.getHighlightedItemEl(ctx2)),
        isWithinPolygon: (ctx2, evt) => {
          if (!ctx2.intentPolygon)
            return false;
          return isPointInPolygon(ctx2.intentPolygon, evt.point);
        },
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isArrowLeftEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "ARROW_LEFT";
        },
        isArrowUpEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "ARROW_UP";
        },
        isArrowDownEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "ARROW_DOWN";
        },
        isOpenAutoFocusEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "OPEN_AUTOFOCUS";
        }
      },
      activities: {
        trackPositioning(ctx2) {
          if (ctx2.anchorPoint)
            return;
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom14.getPositionerEl(ctx2);
          return getPlacement(dom14.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackInteractOutside(ctx2, _evt, { send }) {
          const getContentEl = () => dom14.getContentEl(ctx2);
          return trackDismissableElement(getContentEl, {
            defer: true,
            exclude: [dom14.getTriggerEl(ctx2)],
            onInteractOutside: ctx2.onInteractOutside,
            onFocusOutside: ctx2.onFocusOutside,
            onEscapeKeyDown(event) {
              var _a;
              (_a = ctx2.onEscapeKeyDown) == null ? void 0 : _a.call(ctx2, event);
              if (ctx2.isSubmenu)
                event.preventDefault();
              closeRootMenu(ctx2);
            },
            onPointerDownOutside(event) {
              var _a;
              ctx2.restoreFocus = !event.detail.focusable;
              (_a = ctx2.onPointerDownOutside) == null ? void 0 : _a.call(ctx2, event);
            },
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside" });
            }
          });
        },
        trackPointerMove(ctx2, _evt, { guards: guards2, send }) {
          const { isWithinPolygon } = guards2;
          ctx2.parent.state.context.suspendPointer = true;
          const doc = dom14.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (e) => {
            const point = { x: e.clientX, y: e.clientY };
            const isMovingToSubmenu = isWithinPolygon(ctx2, { point });
            if (!isMovingToSubmenu) {
              send("POINTER_MOVED_AWAY_FROM_SUBMENU");
              ctx2.parent.state.context.suspendPointer = false;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = () => {
            const state2 = getState();
            if (state2.event.type.startsWith("ITEM_POINTER"))
              return;
            const itemEl = dom14.getHighlightedItemEl(ctx2);
            const contentEl2 = dom14.getContentEl(ctx2);
            scrollIntoView(itemEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2());
          const contentEl = () => dom14.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["aria-activedescendant"],
            callback: exec2
          });
        }
      },
      actions: {
        setAnchorPoint(ctx2, evt) {
          ctx2.anchorPoint = evt.point;
        },
        clearAnchorPoint(ctx2) {
          ctx2.anchorPoint = null;
        },
        setSubmenuPlacement(ctx2) {
          if (!ctx2.isSubmenu)
            return;
          ctx2.positioning.placement = ctx2.isRtl ? "left-start" : "right-start";
          ctx2.positioning.gutter = 0;
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom14.getPositionerEl(ctx2);
          const getAnchorRect = ctx2.anchorPoint ? () => ({ width: 0, height: 0, ...ctx2.anchorPoint }) : void 0;
          getPlacement(dom14.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            getAnchorRect,
            ...evt.options ?? {},
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        setOptionState(_ctx, evt) {
          if (!evt.option)
            return;
          const { checked, onCheckedChange, type } = evt.option;
          if (type === "radio") {
            onCheckedChange == null ? void 0 : onCheckedChange(true);
          } else if (type === "checkbox") {
            onCheckedChange == null ? void 0 : onCheckedChange(!checked);
          }
        },
        clickHighlightedItem(ctx2, _evt, { send }) {
          const itemEl = dom14.getHighlightedItemEl(ctx2);
          if (!itemEl || itemEl.dataset.disabled)
            return;
          const option = dom14.getOptionFromItemEl(itemEl);
          send({
            type: "ITEM_CLICK",
            src: "enter",
            target: itemEl,
            id: option.id,
            option,
            closeOnSelect: ctx2.closeOnSelect
          });
        },
        setIntentPolygon(ctx2, evt) {
          const menu = dom14.getContentEl(ctx2);
          const placement = ctx2.currentPlacement;
          if (!menu || !placement)
            return;
          const rect = menu.getBoundingClientRect();
          const polygon = getElementPolygon(rect, placement);
          if (!polygon)
            return;
          const rightSide = getPlacementSide(placement) === "right";
          const bleed = rightSide ? -5 : 5;
          ctx2.intentPolygon = [{ ...evt.point, x: evt.point.x + bleed }, ...polygon];
        },
        clearIntentPolygon(ctx2) {
          ctx2.intentPolygon = null;
        },
        resumePointer(ctx2) {
          if (!ctx2.parent)
            return;
          ctx2.parent.state.context.suspendPointer = false;
        },
        setHighlightedItem(ctx2, evt) {
          set11.highlighted(ctx2, evt.id);
        },
        clearHighlightedItem(ctx2) {
          set11.highlighted(ctx2, null);
        },
        focusMenu(ctx2) {
          raf(() => {
            const contentEl = dom14.getContentEl(ctx2);
            const initialFocusEl = getInitialFocus({
              root: contentEl,
              enabled: !contains(contentEl, dom14.getActiveElement(ctx2)),
              filter(node) {
                var _a;
                return !((_a = node.role) == null ? void 0 : _a.startsWith("menuitem"));
              }
            });
            initialFocusEl == null ? void 0 : initialFocusEl.focus({ preventScroll: true });
          });
        },
        highlightFirstItem(ctx2) {
          const first2 = dom14.getFirstEl(ctx2);
          if (!first2)
            return;
          set11.highlighted(ctx2, first2.id);
        },
        highlightLastItem(ctx2) {
          const last2 = dom14.getLastEl(ctx2);
          if (!last2)
            return;
          set11.highlighted(ctx2, last2.id);
        },
        highlightNextItem(ctx2, evt) {
          const next = dom14.getNextEl(ctx2, evt.loop);
          set11.highlighted(ctx2, (next == null ? void 0 : next.id) ?? null);
        },
        highlightPrevItem(ctx2, evt) {
          const prev = dom14.getPrevEl(ctx2, evt.loop);
          set11.highlighted(ctx2, (prev == null ? void 0 : prev.id) ?? null);
        },
        invokeOnSelect(ctx2) {
          var _a;
          if (!ctx2.highlightedValue)
            return;
          (_a = ctx2.onSelect) == null ? void 0 : _a.call(ctx2, { value: ctx2.highlightedValue });
        },
        focusTrigger(ctx2) {
          if (ctx2.isSubmenu || ctx2.anchorPoint || !ctx2.restoreFocus)
            return;
          raf(() => {
            var _a;
            return (_a = dom14.getTriggerEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        highlightMatchedItem(ctx2, evt) {
          const node = dom14.getElemByKey(ctx2, evt.key);
          if (!node)
            return;
          set11.highlighted(ctx2, node.id);
        },
        setParentMenu(ctx2, evt) {
          ctx2.parent = ref(evt.value);
        },
        setChildMenu(ctx2, evt) {
          ctx2.children[evt.id] = ref(evt.value);
        },
        closeRootMenu(ctx2) {
          closeRootMenu(ctx2);
        },
        openSubmenu(ctx2) {
          const item = dom14.getHighlightedItemEl(ctx2);
          const id = item == null ? void 0 : item.getAttribute("data-uid");
          const child = id ? ctx2.children[id] : null;
          child == null ? void 0 : child.send("OPEN_AUTOFOCUS");
        },
        focusParentMenu(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("FOCUS_MENU");
        },
        setLastHighlightedItem(ctx2, evt) {
          ctx2.lastHighlightedValue = evt.id;
        },
        restoreHighlightedItem(ctx2) {
          if (!ctx2.lastHighlightedValue)
            return;
          set11.highlighted(ctx2, ctx2.lastHighlightedValue);
          ctx2.lastHighlightedValue = null;
        },
        restoreParentHiglightedItem(ctx2) {
          var _a;
          (_a = ctx2.parent) == null ? void 0 : _a.send("HIGHLIGHTED.RESTORE");
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
function closeRootMenu(ctx) {
  let parent = ctx.parent;
  while (parent && parent.state.context.isSubmenu) {
    parent = parent.state.context.parent;
  }
  parent == null ? void 0 : parent.send("CLOSE");
}
var set11 = {
  highlighted(ctx, value) {
    var _a;
    if (isEqual(ctx.highlightedValue, value))
      return;
    ctx.highlightedValue = value;
    (_a = ctx.onHighlightChange) == null ? void 0 : _a.call(ctx, { highlightedValue: value });
  }
};
var props12 = createProps()([
  "anchorPoint",
  "aria-label",
  "closeOnSelect",
  "dir",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "loopFocus",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onEscapeKeyDown",
  "onSelect",
  "onHighlightChange",
  "open",
  "open.controlled",
  "positioning",
  "typeahead",
  "composite"
]);
var splitProps12 = createSplitProps(props12);
var itemProps3 = createProps()(["closeOnSelect", "disabled", "value", "valueText"]);
var splitItemProps3 = createSplitProps(itemProps3);
var itemGroupLabelProps = createProps()(["htmlFor"]);
var splitItemGroupLabelProps = createSplitProps(itemGroupLabelProps);
var itemGroupProps = createProps()(["id"]);
var splitItemGroupProps = createSplitProps(itemGroupProps);
var optionItemProps = createProps()([
  "disabled",
  "valueText",
  "closeOnSelect",
  "type",
  "value",
  "checked",
  "onCheckedChange"
]);
var splitOptionItemProps = createSplitProps(optionItemProps);

// node_modules/@zag-js/number-utils/dist/index.mjs
function wrap3(num, max3) {
  return (num % max3 + max3) % max3;
}
function roundToDevicePixel(num) {
  if (typeof window.devicePixelRatio !== "number")
    return Math.round(num);
  const dp = window.devicePixelRatio;
  return Math.floor(num * dp + 0.5) / dp;
}
function clamp3(v, o) {
  return Math.min(Math.max(nan(v), o.min), o.max);
}
function countDecimals(value) {
  if (!Number.isFinite(value))
    return 0;
  let e = 1, p = 0;
  while (Math.round(value * e) / e !== value) {
    e *= 10;
    p += 1;
  }
  return p;
}
var increment = (v, s) => decimalOperation(nan(v), "+", s);
var decrement = (v, s) => decimalOperation(nan(v), "-", s);
function nan(v) {
  return Number.isNaN(v) ? 0 : v;
}
function isAtMax(val, o) {
  return nan(val) >= o.max;
}
function isAtMin(val, o) {
  return nan(val) <= o.min;
}
function isWithinRange(val, o) {
  return nan(val) >= o.min && nan(val) <= o.max;
}
function decimalOperation(a2, op, b2) {
  let result = op === "+" ? a2 + b2 : a2 - b2;
  if (a2 % 1 !== 0 || b2 % 1 !== 0) {
    const multiplier = 10 ** Math.max(countDecimals(a2), countDecimals(b2));
    a2 = Math.round(a2 * multiplier);
    b2 = Math.round(b2 * multiplier);
    result = op === "+" ? a2 + b2 : a2 - b2;
    result /= multiplier;
  }
  return result;
}
var nf = new Intl.NumberFormat("en-US", { style: "decimal", maximumFractionDigits: 20 });

// node_modules/@internationalized/number/dist/NumberFormatter.mjs
var $488c6ddbf4ef74c2$var$formatterCache = /* @__PURE__ */ new Map();
var $488c6ddbf4ef74c2$var$supportsSignDisplay = false;
try {
  $488c6ddbf4ef74c2$var$supportsSignDisplay = new Intl.NumberFormat("de-DE", {
    signDisplay: "exceptZero"
  }).resolvedOptions().signDisplay === "exceptZero";
} catch (e) {
}
var $488c6ddbf4ef74c2$var$supportsUnit = false;
try {
  $488c6ddbf4ef74c2$var$supportsUnit = new Intl.NumberFormat("de-DE", {
    style: "unit",
    unit: "degree"
  }).resolvedOptions().style === "unit";
} catch (e) {
}
var $488c6ddbf4ef74c2$var$UNITS = {
  degree: {
    narrow: {
      default: "",
      "ja-JP": " ",
      "zh-TW": "",
      "sl-SI": " "
    }
  }
};
var $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5 = class {
  /** Formats a number value as a string, according to the locale and options provided to the constructor. */
  format(value) {
    let res = "";
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null)
      res = $488c6ddbf4ef74c2$export$711b50b3c525e0f2(this.numberFormatter, this.options.signDisplay, value);
    else
      res = this.numberFormatter.format(value);
    if (this.options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
      var _UNITS_unit;
      let { unit, unitDisplay = "short", locale } = this.resolvedOptions();
      if (!unit)
        return res;
      let values = (_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay];
      res += values[locale] || values.default;
    }
    return res;
  }
  /** Formats a number to an array of parts such as separators, digits, punctuation, and more. */
  formatToParts(value) {
    return this.numberFormatter.formatToParts(value);
  }
  /** Formats a number range as a string. */
  formatRange(start, end) {
    if (typeof this.numberFormatter.formatRange === "function")
      return this.numberFormatter.formatRange(start, end);
    if (end < start)
      throw new RangeError("End date must be >= start date");
    return `${this.format(start)}  ${this.format(end)}`;
  }
  /** Formats a number range as an array of parts. */
  formatRangeToParts(start, end) {
    if (typeof this.numberFormatter.formatRangeToParts === "function")
      return this.numberFormatter.formatRangeToParts(start, end);
    if (end < start)
      throw new RangeError("End date must be >= start date");
    let startParts = this.numberFormatter.formatToParts(start);
    let endParts = this.numberFormatter.formatToParts(end);
    return [
      ...startParts.map((p) => ({
        ...p,
        source: "startRange"
      })),
      {
        type: "literal",
        value: "  ",
        source: "shared"
      },
      ...endParts.map((p) => ({
        ...p,
        source: "endRange"
      }))
    ];
  }
  /** Returns the resolved formatting options based on the values passed to the constructor. */
  resolvedOptions() {
    let options = this.numberFormatter.resolvedOptions();
    if (!$488c6ddbf4ef74c2$var$supportsSignDisplay && this.options.signDisplay != null)
      options = {
        ...options,
        signDisplay: this.options.signDisplay
      };
    if (!$488c6ddbf4ef74c2$var$supportsUnit && this.options.style === "unit")
      options = {
        ...options,
        style: "unit",
        unit: this.options.unit,
        unitDisplay: this.options.unitDisplay
      };
    return options;
  }
  constructor(locale, options = {}) {
    this.numberFormatter = $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options);
    this.options = options;
  }
};
function $488c6ddbf4ef74c2$var$getCachedNumberFormatter(locale, options = {}) {
  let { numberingSystem } = options;
  if (numberingSystem && locale.includes("-nu-")) {
    if (!locale.includes("-u-"))
      locale += "-u-";
    locale += `-nu-${numberingSystem}`;
  }
  if (options.style === "unit" && !$488c6ddbf4ef74c2$var$supportsUnit) {
    var _UNITS_unit;
    let { unit, unitDisplay = "short" } = options;
    if (!unit)
      throw new Error('unit option must be provided with style: "unit"');
    if (!((_UNITS_unit = $488c6ddbf4ef74c2$var$UNITS[unit]) === null || _UNITS_unit === void 0 ? void 0 : _UNITS_unit[unitDisplay]))
      throw new Error(`Unsupported unit ${unit} with unitDisplay = ${unitDisplay}`);
    options = {
      ...options,
      style: "decimal"
    };
  }
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  if ($488c6ddbf4ef74c2$var$formatterCache.has(cacheKey))
    return $488c6ddbf4ef74c2$var$formatterCache.get(cacheKey);
  let numberFormatter = new Intl.NumberFormat(locale, options);
  $488c6ddbf4ef74c2$var$formatterCache.set(cacheKey, numberFormatter);
  return numberFormatter;
}
function $488c6ddbf4ef74c2$export$711b50b3c525e0f2(numberFormat, signDisplay, num) {
  if (signDisplay === "auto")
    return numberFormat.format(num);
  else if (signDisplay === "never")
    return numberFormat.format(Math.abs(num));
  else {
    let needsPositiveSign = false;
    if (signDisplay === "always")
      needsPositiveSign = num > 0 || Object.is(num, 0);
    else if (signDisplay === "exceptZero") {
      if (Object.is(num, -0) || Object.is(num, 0))
        num = Math.abs(num);
      else
        needsPositiveSign = num > 0;
    }
    if (needsPositiveSign) {
      let negative = numberFormat.format(-num);
      let noSign = numberFormat.format(num);
      let minus = negative.replace(noSign, "").replace(/\u200e|\u061C/, "");
      if ([
        ...minus
      ].length !== 1)
        console.warn("@react-aria/i18n polyfill for NumberFormat signDisplay: Unsupported case");
      let positive = negative.replace(noSign, "!!!").replace(minus, "+").replace("!!!", noSign);
      return positive;
    } else
      return numberFormat.format(num);
  }
}

// node_modules/@internationalized/number/dist/NumberParser.mjs
var $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX = new RegExp("^.*\\(.*\\).*$");
var $6c7bd7858deea686$var$NUMBERING_SYSTEMS = [
  "latn",
  "arab",
  "hanidec"
];
var $6c7bd7858deea686$export$cd11ab140839f11d = class {
  /**
  * Parses the given string to a number. Returns NaN if a valid number could not be parsed.
  */
  parse(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).parse(value);
  }
  /**
  * Returns whether the given string could potentially be a valid number. This should be used to
  * validate user input as the user types. If a `minValue` or `maxValue` is provided, the validity
  * of the minus/plus sign characters can be checked.
  */
  isValidPartialNumber(value, minValue, maxValue) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).isValidPartialNumber(value, minValue, maxValue);
  }
  /**
  * Returns a numbering system for which the given string is valid in the current locale.
  * If no numbering system could be detected, the default numbering system for the current
  * locale is returned.
  */
  getNumberingSystem(value) {
    return $6c7bd7858deea686$var$getNumberParserImpl(this.locale, this.options, value).options.numberingSystem;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.options = options;
  }
};
var $6c7bd7858deea686$var$numberParserCache = /* @__PURE__ */ new Map();
function $6c7bd7858deea686$var$getNumberParserImpl(locale, options, value) {
  let defaultParser = $6c7bd7858deea686$var$getCachedNumberParser(locale, options);
  if (!locale.includes("-nu-") && !defaultParser.isValidPartialNumber(value)) {
    for (let numberingSystem of $6c7bd7858deea686$var$NUMBERING_SYSTEMS)
      if (numberingSystem !== defaultParser.options.numberingSystem) {
        let parser = $6c7bd7858deea686$var$getCachedNumberParser(locale + (locale.includes("-u-") ? "-nu-" : "-u-nu-") + numberingSystem, options);
        if (parser.isValidPartialNumber(value))
          return parser;
      }
  }
  return defaultParser;
}
function $6c7bd7858deea686$var$getCachedNumberParser(locale, options) {
  let cacheKey = locale + (options ? Object.entries(options).sort((a2, b2) => a2[0] < b2[0] ? -1 : 1).join() : "");
  let parser = $6c7bd7858deea686$var$numberParserCache.get(cacheKey);
  if (!parser) {
    parser = new $6c7bd7858deea686$var$NumberParserImpl(locale, options);
    $6c7bd7858deea686$var$numberParserCache.set(cacheKey, parser);
  }
  return parser;
}
var $6c7bd7858deea686$var$NumberParserImpl = class {
  parse(value) {
    let fullySanitizedValue = this.sanitize(value);
    if (this.symbols.group)
      fullySanitizedValue = $6c7bd7858deea686$var$replaceAll(fullySanitizedValue, this.symbols.group, "");
    if (this.symbols.decimal)
      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.decimal, ".");
    if (this.symbols.minusSign)
      fullySanitizedValue = fullySanitizedValue.replace(this.symbols.minusSign, "-");
    fullySanitizedValue = fullySanitizedValue.replace(this.symbols.numeral, this.symbols.index);
    if (this.options.style === "percent") {
      let isNegative = fullySanitizedValue.indexOf("-");
      fullySanitizedValue = fullySanitizedValue.replace("-", "");
      let index = fullySanitizedValue.indexOf(".");
      if (index === -1)
        index = fullySanitizedValue.length;
      fullySanitizedValue = fullySanitizedValue.replace(".", "");
      if (index - 2 === 0)
        fullySanitizedValue = `0.${fullySanitizedValue}`;
      else if (index - 2 === -1)
        fullySanitizedValue = `0.0${fullySanitizedValue}`;
      else if (index - 2 === -2)
        fullySanitizedValue = "0.00";
      else
        fullySanitizedValue = `${fullySanitizedValue.slice(0, index - 2)}.${fullySanitizedValue.slice(index - 2)}`;
      if (isNegative > -1)
        fullySanitizedValue = `-${fullySanitizedValue}`;
    }
    let newValue = fullySanitizedValue ? +fullySanitizedValue : NaN;
    if (isNaN(newValue))
      return NaN;
    if (this.options.style === "percent") {
      var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
      let options = {
        ...this.options,
        style: "decimal",
        minimumFractionDigits: Math.min(((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) + 2, 20),
        maximumFractionDigits: Math.min(((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) + 2, 20)
      };
      return new $6c7bd7858deea686$export$cd11ab140839f11d(this.locale, options).parse(new (0, $488c6ddbf4ef74c2$export$cc77c4ff7e8673c5)(this.locale, options).format(newValue));
    }
    if (this.options.currencySign === "accounting" && $6c7bd7858deea686$var$CURRENCY_SIGN_REGEX.test(value))
      newValue = -1 * newValue;
    return newValue;
  }
  sanitize(value) {
    value = value.replace(this.symbols.literals, "");
    if (this.symbols.minusSign)
      value = value.replace("-", this.symbols.minusSign);
    if (this.options.numberingSystem === "arab") {
      if (this.symbols.decimal) {
        value = value.replace(",", this.symbols.decimal);
        value = value.replace(String.fromCharCode(1548), this.symbols.decimal);
      }
      if (this.symbols.group)
        value = $6c7bd7858deea686$var$replaceAll(value, ".", this.symbols.group);
    }
    if (this.options.locale === "fr-FR")
      value = $6c7bd7858deea686$var$replaceAll(value, ".", String.fromCharCode(8239));
    return value;
  }
  isValidPartialNumber(value, minValue = -Infinity, maxValue = Infinity) {
    value = this.sanitize(value);
    if (this.symbols.minusSign && value.startsWith(this.symbols.minusSign) && minValue < 0)
      value = value.slice(this.symbols.minusSign.length);
    else if (this.symbols.plusSign && value.startsWith(this.symbols.plusSign) && maxValue > 0)
      value = value.slice(this.symbols.plusSign.length);
    if (this.symbols.group && value.startsWith(this.symbols.group))
      return false;
    if (this.symbols.decimal && value.indexOf(this.symbols.decimal) > -1 && this.options.maximumFractionDigits === 0)
      return false;
    if (this.symbols.group)
      value = $6c7bd7858deea686$var$replaceAll(value, this.symbols.group, "");
    value = value.replace(this.symbols.numeral, "");
    if (this.symbols.decimal)
      value = value.replace(this.symbols.decimal, "");
    return value.length === 0;
  }
  constructor(locale, options = {}) {
    this.locale = locale;
    this.formatter = new Intl.NumberFormat(locale, options);
    this.options = this.formatter.resolvedOptions();
    this.symbols = $6c7bd7858deea686$var$getSymbols(locale, this.formatter, this.options, options);
    var _this_options_minimumFractionDigits, _this_options_maximumFractionDigits;
    if (this.options.style === "percent" && (((_this_options_minimumFractionDigits = this.options.minimumFractionDigits) !== null && _this_options_minimumFractionDigits !== void 0 ? _this_options_minimumFractionDigits : 0) > 18 || ((_this_options_maximumFractionDigits = this.options.maximumFractionDigits) !== null && _this_options_maximumFractionDigits !== void 0 ? _this_options_maximumFractionDigits : 0) > 18))
      console.warn("NumberParser cannot handle percentages with greater than 18 decimal places, please reduce the number in your options.");
  }
};
var $6c7bd7858deea686$var$nonLiteralParts = /* @__PURE__ */ new Set([
  "decimal",
  "fraction",
  "integer",
  "minusSign",
  "plusSign",
  "group"
]);
var $6c7bd7858deea686$var$pluralNumbers = [
  0,
  4,
  2,
  1,
  11,
  20,
  3,
  7,
  100,
  21,
  0.1,
  1.1
];
function $6c7bd7858deea686$var$getSymbols(locale, formatter, intlOptions, originalOptions) {
  var _allParts_find, _posAllParts_find, _decimalParts_find, _allParts_find1;
  let symbolFormatter = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumSignificantDigits: 1,
    maximumSignificantDigits: 21
  });
  let allParts = symbolFormatter.formatToParts(-10000.111);
  let posAllParts = symbolFormatter.formatToParts(10000.111);
  let pluralParts = $6c7bd7858deea686$var$pluralNumbers.map((n) => symbolFormatter.formatToParts(n));
  var _allParts_find_value;
  let minusSign = (_allParts_find_value = (_allParts_find = allParts.find((p) => p.type === "minusSign")) === null || _allParts_find === void 0 ? void 0 : _allParts_find.value) !== null && _allParts_find_value !== void 0 ? _allParts_find_value : "-";
  let plusSign = (_posAllParts_find = posAllParts.find((p) => p.type === "plusSign")) === null || _posAllParts_find === void 0 ? void 0 : _posAllParts_find.value;
  if (!plusSign && ((originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "exceptZero" || (originalOptions === null || originalOptions === void 0 ? void 0 : originalOptions.signDisplay) === "always"))
    plusSign = "+";
  let decimalParts = new Intl.NumberFormat(locale, {
    ...intlOptions,
    minimumFractionDigits: 2,
    maximumFractionDigits: 2
  }).formatToParts(1e-3);
  let decimal = (_decimalParts_find = decimalParts.find((p) => p.type === "decimal")) === null || _decimalParts_find === void 0 ? void 0 : _decimalParts_find.value;
  let group2 = (_allParts_find1 = allParts.find((p) => p.type === "group")) === null || _allParts_find1 === void 0 ? void 0 : _allParts_find1.value;
  let allPartsLiterals = allParts.filter((p) => !$6c7bd7858deea686$var$nonLiteralParts.has(p.type)).map((p) => $6c7bd7858deea686$var$escapeRegex(p.value));
  let pluralPartsLiterals = pluralParts.flatMap((p) => p.filter((p2) => !$6c7bd7858deea686$var$nonLiteralParts.has(p2.type)).map((p2) => $6c7bd7858deea686$var$escapeRegex(p2.value)));
  let sortedLiterals = [
    .../* @__PURE__ */ new Set([
      ...allPartsLiterals,
      ...pluralPartsLiterals
    ])
  ].sort((a2, b2) => b2.length - a2.length);
  let literals = sortedLiterals.length === 0 ? new RegExp("[\\p{White_Space}]", "gu") : new RegExp(`${sortedLiterals.join("|")}|[\\p{White_Space}]`, "gu");
  let numerals = [
    ...new Intl.NumberFormat(intlOptions.locale, {
      useGrouping: false
    }).format(9876543210)
  ].reverse();
  let indexes = new Map(numerals.map((d, i) => [
    d,
    i
  ]));
  let numeral = new RegExp(`[${numerals.join("")}]`, "g");
  let index = (d) => String(indexes.get(d));
  return {
    minusSign,
    plusSign,
    decimal,
    group: group2,
    literals,
    numeral,
    index
  };
}
function $6c7bd7858deea686$var$replaceAll(str, find, replace) {
  if (str.replaceAll)
    return str.replaceAll(find, replace);
  return str.split(find).join(replace);
}
function $6c7bd7858deea686$var$escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}

// node_modules/@zag-js/number-input/dist/index.mjs
var anatomy19 = createAnatomy("numberInput").parts(
  "root",
  "label",
  "input",
  "control",
  "incrementTrigger",
  "decrementTrigger",
  "scrubber"
);
var parts15 = anatomy19.build();
var dom15 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `number-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `number-input:${ctx.id}:input`;
  },
  getIncrementTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.incrementTrigger) ?? `number-input:${ctx.id}:inc`;
  },
  getDecrementTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.decrementTrigger) ?? `number-input:${ctx.id}:dec`;
  },
  getScrubberId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.scrubber) ?? `number-input:${ctx.id}:scrubber`;
  },
  getCursorId: (ctx) => `number-input:${ctx.id}:cursor`,
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `number-input:${ctx.id}:label`;
  },
  getInputEl: (ctx) => dom15.getById(ctx, dom15.getInputId(ctx)),
  getIncrementTriggerEl: (ctx) => dom15.getById(ctx, dom15.getIncrementTriggerId(ctx)),
  getDecrementTriggerEl: (ctx) => dom15.getById(ctx, dom15.getDecrementTriggerId(ctx)),
  getScrubberEl: (ctx) => dom15.getById(ctx, dom15.getScrubberId(ctx)),
  getCursorEl: (ctx) => dom15.getDoc(ctx).getElementById(dom15.getCursorId(ctx)),
  getPressedTriggerEl: (ctx, hint = ctx.hint) => {
    let btnEl = null;
    if (hint === "increment") {
      btnEl = dom15.getIncrementTriggerEl(ctx);
    }
    if (hint === "decrement") {
      btnEl = dom15.getDecrementTriggerEl(ctx);
    }
    return btnEl;
  },
  setupVirtualCursor(ctx) {
    if (isSafari())
      return;
    dom15.createVirtualCursor(ctx);
    return () => {
      var _a;
      (_a = dom15.getCursorEl(ctx)) == null ? void 0 : _a.remove();
    };
  },
  preventTextSelection(ctx) {
    const doc = dom15.getDoc(ctx);
    const html = doc.documentElement;
    const body = doc.body;
    body.style.pointerEvents = "none";
    html.style.userSelect = "none";
    html.style.cursor = "ew-resize";
    return () => {
      body.style.pointerEvents = "";
      html.style.userSelect = "";
      html.style.cursor = "";
      if (!html.style.length) {
        html.removeAttribute("style");
      }
      if (!body.style.length) {
        body.removeAttribute("style");
      }
    };
  },
  getMousementValue(ctx, event) {
    const x = roundToDevicePixel(event.movementX);
    const y = roundToDevicePixel(event.movementY);
    let hint = x > 0 ? "increment" : x < 0 ? "decrement" : null;
    if (ctx.isRtl && hint === "increment")
      hint = "decrement";
    if (ctx.isRtl && hint === "decrement")
      hint = "increment";
    const point = {
      x: ctx.scrubberCursorPoint.x + x,
      y: ctx.scrubberCursorPoint.y + y
    };
    const win = dom15.getWin(ctx);
    const width = win.innerWidth;
    const half = roundToDevicePixel(7.5);
    point.x = wrap3(point.x + half, width) - half;
    return { hint, point };
  },
  createVirtualCursor(ctx) {
    const doc = dom15.getDoc(ctx);
    const el = doc.createElement("div");
    el.className = "scrubber--cursor";
    el.id = dom15.getCursorId(ctx);
    Object.assign(el.style, {
      width: "15px",
      height: "15px",
      position: "fixed",
      pointerEvents: "none",
      left: "0px",
      top: "0px",
      zIndex: MAX_Z_INDEX,
      transform: ctx.scrubberCursorPoint ? `translate3d(${ctx.scrubberCursorPoint.x}px, ${ctx.scrubberCursorPoint.y}px, 0px)` : void 0,
      willChange: "transform"
    });
    el.innerHTML = `
        <svg width="46" height="15" style="left: -15.5px; position: absolute; top: 0; filter: drop-shadow(rgba(0, 0, 0, 0.4) 0px 1px 1.1px);">
          <g transform="translate(2 3)">
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z" style="stroke-width: 2px; stroke: white;"></path>
            <path fill-rule="evenodd" d="M 15 4.5L 15 2L 11.5 5.5L 15 9L 15 6.5L 31 6.5L 31 9L 34.5 5.5L 31 2L 31 4.5Z"></path>
          </g>
        </svg>`;
    doc.body.appendChild(el);
  }
});
function connect15(state2, send, normalize) {
  const focused = state2.hasTag("focus");
  const disabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  const empty = state2.context.isValueEmpty;
  const invalid = state2.context.isOutOfRange || !!state2.context.invalid;
  const isIncrementDisabled = disabled || !state2.context.canIncrement || readOnly;
  const isDecrementDisabled = disabled || !state2.context.canDecrement || readOnly;
  const translations = state2.context.translations;
  return {
    focused,
    invalid,
    empty,
    value: state2.context.formattedValue,
    valueAsNumber: state2.context.valueAsNumber,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send("VALUE.CLEAR");
    },
    increment() {
      send("VALUE.INCREMENT");
    },
    decrement() {
      send("VALUE.DECREMENT");
    },
    setToMax() {
      send({ type: "VALUE.SET", value: state2.context.max });
    },
    setToMin() {
      send({ type: "VALUE.SET", value: state2.context.min });
    },
    focus() {
      var _a;
      (_a = dom15.getInputEl(state2.context)) == null ? void 0 : _a.focus();
    },
    getRootProps() {
      return normalize.element({
        id: dom15.getRootId(state2.context),
        ...parts15.root.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts15.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        id: dom15.getLabelId(state2.context),
        htmlFor: dom15.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts15.control.attrs,
        dir: state2.context.dir,
        role: "group",
        "aria-disabled": disabled,
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(state2.context.invalid)
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts15.input.attrs,
        dir: state2.context.dir,
        name: state2.context.name,
        form: state2.context.form,
        id: dom15.getInputId(state2.context),
        role: "spinbutton",
        defaultValue: state2.context.formattedValue,
        pattern: state2.context.pattern,
        inputMode: state2.context.inputMode,
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        disabled,
        "data-disabled": dataAttr(disabled),
        readOnly: !!state2.context.readOnly,
        autoComplete: "off",
        autoCorrect: "off",
        spellCheck: "false",
        type: "text",
        "aria-roledescription": "numberfield",
        "aria-valuemin": state2.context.min,
        "aria-valuemax": state2.context.max,
        "aria-valuenow": Number.isNaN(state2.context.valueAsNumber) ? void 0 : state2.context.valueAsNumber,
        "aria-valuetext": state2.context.valueText,
        onFocus() {
          send("INPUT.FOCUS");
        },
        onBlur() {
          send({ type: "INPUT.COMMIT", src: "blur" });
        },
        onChange(event) {
          send({ type: "INPUT.CHANGE", target: event.currentTarget, hint: "set" });
        },
        onBeforeInput(event) {
          try {
            const { selectionStart, selectionEnd, value } = event.currentTarget;
            const nextValue = value.slice(0, selectionStart) + (event.data ?? "") + value.slice(selectionEnd);
            const isValid = state2.context.parser.isValidPartialNumber(nextValue);
            if (!isValid) {
              event.preventDefault();
            }
          } catch {
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (readOnly)
            return;
          if (isComposingEvent(event))
            return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "INPUT.ARROW_UP", step });
              event.preventDefault();
            },
            ArrowDown() {
              send({ type: "INPUT.ARROW_DOWN", step });
              event.preventDefault();
            },
            Home() {
              send("INPUT.HOME");
              event.preventDefault();
            },
            End() {
              send("INPUT.END");
              event.preventDefault();
            },
            Enter() {
              send({ type: "INPUT.COMMIT", src: "enter" });
            }
          };
          const exec2 = keyMap2[event.key];
          exec2 == null ? void 0 : exec2(event);
        }
      });
    },
    getDecrementTriggerProps() {
      return normalize.button({
        ...parts15.decrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom15.getDecrementTriggerId(state2.context),
        disabled: isDecrementDisabled,
        "data-disabled": dataAttr(isDecrementDisabled),
        "aria-label": translations.decrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom15.getInputId(state2.context),
        onPointerDown(event) {
          var _a;
          if (isDecrementDisabled || !isLeftClick(event))
            return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "decrement", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a = event.currentTarget) == null ? void 0 : _a.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement", pointerType: event.pointerType });
        },
        onPointerLeave() {
          if (isDecrementDisabled)
            return;
          send({ type: "TRIGGER.PRESS_UP", hint: "decrement" });
        }
      });
    },
    getIncrementTriggerProps() {
      return normalize.button({
        ...parts15.incrementTrigger.attrs,
        dir: state2.context.dir,
        id: dom15.getIncrementTriggerId(state2.context),
        disabled: isIncrementDisabled,
        "data-disabled": dataAttr(isIncrementDisabled),
        "aria-label": translations.incrementLabel,
        type: "button",
        tabIndex: -1,
        "aria-controls": dom15.getInputId(state2.context),
        onPointerDown(event) {
          var _a;
          if (isIncrementDisabled || !isLeftClick(event))
            return;
          send({ type: "TRIGGER.PRESS_DOWN", hint: "increment", pointerType: event.pointerType });
          if (event.pointerType === "mouse") {
            event.preventDefault();
          }
          if (event.pointerType === "touch") {
            (_a = event.currentTarget) == null ? void 0 : _a.focus({ preventScroll: true });
          }
        },
        onPointerUp(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        },
        onPointerLeave(event) {
          send({ type: "TRIGGER.PRESS_UP", hint: "increment", pointerType: event.pointerType });
        }
      });
    },
    getScrubberProps() {
      return normalize.element({
        ...parts15.scrubber.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        id: dom15.getScrubberId(state2.context),
        role: "presentation",
        onMouseDown(event) {
          if (disabled)
            return;
          const point = getEventPoint(event);
          point.x = point.x - roundToDevicePixel(7.5);
          point.y = point.y - roundToDevicePixel(7.5);
          send({ type: "SCRUBBER.PRESS_DOWN", point });
          event.preventDefault();
        },
        style: {
          cursor: disabled ? void 0 : "ew-resize"
        }
      });
    }
  };
}
function recordCursor(inputEl) {
  if (inputEl.ownerDocument.activeElement !== inputEl)
    return;
  try {
    const { selectionStart: start, selectionEnd: end, value } = inputEl;
    const beforeTxt = value.substring(0, start);
    const afterTxt = value.substring(end);
    return {
      start,
      end,
      value,
      beforeTxt,
      afterTxt
    };
  } catch {
  }
}
function restoreCursor(inputEl, selection) {
  if (inputEl.ownerDocument.activeElement !== inputEl)
    return;
  if (!selection) {
    inputEl.setSelectionRange(inputEl.value.length, inputEl.value.length);
    return;
  }
  try {
    const { value } = inputEl;
    const { beforeTxt = "", afterTxt = "", start } = selection;
    let startPos = value.length;
    if (value.endsWith(afterTxt)) {
      startPos = value.length - afterTxt.length;
    } else if (value.startsWith(beforeTxt)) {
      startPos = beforeTxt.length;
    } else if (start != null) {
      const beforeLastChar = beforeTxt[start - 1];
      const newIndex = value.indexOf(beforeLastChar, start - 1);
      if (newIndex !== -1) {
        startPos = newIndex + 1;
      }
    }
    inputEl.setSelectionRange(startPos, startPos);
  } catch {
  }
}
var createFormatter = (locale, options = {}) => {
  return ref(new Intl.NumberFormat(locale, options));
};
var createParser = (locale, options = {}) => {
  return ref(new $6c7bd7858deea686$export$cd11ab140839f11d(locale, options));
};
var parseValue = (ctx, value) => {
  if (!ctx.formatOptions)
    return parseFloat(value);
  return ctx.parser.parse(String(value));
};
var formatValue = (ctx, value) => {
  if (Number.isNaN(value))
    return "";
  if (!ctx.formatOptions)
    return value.toString();
  return ctx.formatter.format(value);
};
var { not: not8, and: and8 } = guards;
function machine15(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "number-input",
      initial: "idle",
      context: {
        dir: "ltr",
        locale: "en-US",
        focusInputOnChange: true,
        clampValueOnBlur: true,
        allowOverflow: false,
        inputMode: "decimal",
        pattern: "[0-9]*(.[0-9]+)?",
        value: "",
        step: 1,
        min: Number.MIN_SAFE_INTEGER,
        max: Number.MAX_SAFE_INTEGER,
        invalid: false,
        spinOnPress: true,
        ...ctx,
        hint: null,
        scrubberCursorPoint: null,
        fieldsetDisabled: false,
        formatter: createFormatter(ctx.locale || "en-US", ctx.formatOptions),
        parser: createParser(ctx.locale || "en-US", ctx.formatOptions),
        translations: {
          incrementLabel: "increment value",
          decrementLabel: "decrease value",
          ...ctx.translations
        }
      },
      computed: {
        isRtl: (ctx2) => ctx2.dir === "rtl",
        valueAsNumber: (ctx2) => parseValue(ctx2, ctx2.value),
        formattedValue: (ctx2) => formatValue(ctx2, ctx2.valueAsNumber),
        isAtMin: (ctx2) => isAtMin(ctx2.valueAsNumber, ctx2),
        isAtMax: (ctx2) => isAtMax(ctx2.valueAsNumber, ctx2),
        isOutOfRange: (ctx2) => !isWithinRange(ctx2.valueAsNumber, ctx2),
        isValueEmpty: (ctx2) => ctx2.value === "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        canIncrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMax,
        canDecrement: (ctx2) => ctx2.allowOverflow || !ctx2.isAtMin,
        valueText: (ctx2) => {
          var _a, _b;
          return (_b = (_a = ctx2.translations).valueText) == null ? void 0 : _b.call(_a, ctx2.value);
        }
      },
      watch: {
        formatOptions: ["setFormatterAndParser", "syncInputElement"],
        locale: ["setFormatterAndParser", "syncInputElement"],
        value: ["syncInputElement"],
        isOutOfRange: ["invokeOnInvalid"],
        scrubberCursorPoint: ["setVirtualCursorPosition"]
      },
      activities: ["trackFormControl"],
      on: {
        "VALUE.SET": {
          actions: ["setRawValue", "setHintToSet"]
        },
        "VALUE.CLEAR": {
          actions: ["clearValue"]
        },
        "VALUE.INCREMENT": {
          actions: ["increment"]
        },
        "VALUE.DECREMENT": {
          actions: ["decrement"]
        }
      },
      states: {
        idle: {
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              {
                target: "before:spin",
                actions: ["focusInput", "invokeOnFocus", "setHint"]
              }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "invokeOnFocus", "setHint", "setCursorPoint"]
            },
            "INPUT.FOCUS": {
              target: "focused",
              actions: ["focusInput", "invokeOnFocus"]
            }
          }
        },
        focused: {
          tags: "focus",
          activities: "attachWheelListener",
          on: {
            "TRIGGER.PRESS_DOWN": [
              { guard: "isTouchPointer", target: "before:spin", actions: ["setHint"] },
              { target: "before:spin", actions: ["focusInput", "setHint"] }
            ],
            "SCRUBBER.PRESS_DOWN": {
              target: "scrubbing",
              actions: ["focusInput", "setHint", "setCursorPoint"]
            },
            "INPUT.ARROW_UP": {
              actions: "increment"
            },
            "INPUT.ARROW_DOWN": {
              actions: "decrement"
            },
            "INPUT.HOME": {
              actions: "decrementToMin"
            },
            "INPUT.END": {
              actions: "incrementToMax"
            },
            "INPUT.CHANGE": {
              actions: ["setValue", "setHint"]
            },
            "INPUT.COMMIT": [
              {
                guard: and8("clampValueOnBlur", not8("isInRange")),
                target: "idle",
                actions: ["setClampedValue", "clearHint", "invokeOnBlur"]
              },
              {
                target: "idle",
                actions: ["setFormattedValue", "clearHint", "invokeOnBlur"]
              }
            ]
          }
        },
        "before:spin": {
          tags: "focus",
          activities: "trackButtonDisabled",
          entry: choose([
            { guard: "isIncrementHint", actions: "increment" },
            { guard: "isDecrementHint", actions: "decrement" }
          ]),
          after: {
            CHANGE_DELAY: {
              target: "spinning",
              guard: and8("isInRange", "spinOnPress")
            }
          },
          on: {
            "TRIGGER.PRESS_UP": [
              { guard: "isTouchPointer", target: "focused", actions: "clearHint" },
              { target: "focused", actions: ["focusInput", "clearHint"] }
            ]
          }
        },
        spinning: {
          tags: "focus",
          activities: "trackButtonDisabled",
          every: [
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not8("isAtMin"), "isIncrementHint"),
              actions: "increment"
            },
            {
              delay: "CHANGE_INTERVAL",
              guard: and8(not8("isAtMax"), "isDecrementHint"),
              actions: "decrement"
            }
          ],
          on: {
            "TRIGGER.PRESS_UP": {
              target: "focused",
              actions: ["focusInput", "clearHint"]
            }
          }
        },
        scrubbing: {
          tags: "focus",
          activities: ["activatePointerLock", "trackMousemove", "setupVirtualCursor", "preventTextSelection"],
          on: {
            "SCRUBBER.POINTER_UP": {
              target: "focused",
              actions: ["focusInput", "clearCursorPoint"]
            },
            "SCRUBBER.POINTER_MOVE": [
              {
                guard: "isIncrementHint",
                actions: ["increment", "setCursorPoint"]
              },
              {
                guard: "isDecrementHint",
                actions: ["decrement", "setCursorPoint"]
              }
            ]
          }
        }
      }
    },
    {
      delays: {
        CHANGE_INTERVAL: 50,
        CHANGE_DELAY: 300
      },
      guards: {
        clampValueOnBlur: (ctx2) => ctx2.clampValueOnBlur,
        isAtMin: (ctx2) => ctx2.isAtMin,
        spinOnPress: (ctx2) => !!ctx2.spinOnPress,
        isAtMax: (ctx2) => ctx2.isAtMax,
        isInRange: (ctx2) => !ctx2.isOutOfRange,
        isDecrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "decrement",
        isIncrementHint: (ctx2, evt) => (evt.hint ?? ctx2.hint) === "increment",
        isTouchPointer: (_ctx, evt) => evt.pointerType === "touch"
      },
      activities: {
        trackFormControl(ctx2, _evt, { initialContext }) {
          const inputEl = dom15.getInputEl(ctx2);
          return trackFormControl(inputEl, {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set12.value(ctx2, initialContext.value);
            }
          });
        },
        setupVirtualCursor(ctx2) {
          return dom15.setupVirtualCursor(ctx2);
        },
        preventTextSelection(ctx2) {
          return dom15.preventTextSelection(ctx2);
        },
        trackButtonDisabled(ctx2, _evt, { send }) {
          const btn = dom15.getPressedTriggerEl(ctx2, ctx2.hint);
          return observeAttributes(btn, {
            attributes: ["disabled"],
            callback() {
              send({ type: "TRIGGER.PRESS_UP", src: "attr" });
            }
          });
        },
        attachWheelListener(ctx2, _evt, { send }) {
          const inputEl = dom15.getInputEl(ctx2);
          if (!inputEl || !dom15.isActiveElement(ctx2, inputEl) || !ctx2.allowMouseWheel)
            return;
          function onWheel(event) {
            event.preventDefault();
            const dir = Math.sign(event.deltaY) * -1;
            if (dir === 1) {
              send("VALUE.INCREMENT");
            } else if (dir === -1) {
              send("VALUE.DECREMENT");
            }
          }
          return addDomEvent(inputEl, "wheel", onWheel, { passive: false });
        },
        activatePointerLock(ctx2) {
          if (isSafari())
            return;
          return requestPointerLock(dom15.getDoc(ctx2));
        },
        trackMousemove(ctx2, _evt, { send }) {
          const doc = dom15.getDoc(ctx2);
          function onMousemove(event) {
            if (!ctx2.scrubberCursorPoint)
              return;
            const value = dom15.getMousementValue(ctx2, event);
            if (!value.hint)
              return;
            send({
              type: "SCRUBBER.POINTER_MOVE",
              hint: value.hint,
              point: value.point
            });
          }
          function onMouseup() {
            send("SCRUBBER.POINTER_UP");
          }
          return callAll(
            addDomEvent(doc, "mousemove", onMousemove, false),
            addDomEvent(doc, "mouseup", onMouseup, false)
          );
        }
      },
      actions: {
        focusInput(ctx2) {
          if (!ctx2.focusInputOnChange)
            return;
          const inputEl = dom15.getInputEl(ctx2);
          if (dom15.isActiveElement(ctx2, inputEl))
            return;
          raf(() => inputEl == null ? void 0 : inputEl.focus({ preventScroll: true }));
        },
        increment(ctx2, evt) {
          const nextValue = increment(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clamp3(nextValue, ctx2));
          set12.value(ctx2, value);
        },
        decrement(ctx2, evt) {
          const nextValue = decrement(ctx2.valueAsNumber, evt.step ?? ctx2.step);
          const value = formatValue(ctx2, clamp3(nextValue, ctx2));
          set12.value(ctx2, value);
        },
        setClampedValue(ctx2) {
          const nextValue = clamp3(ctx2.valueAsNumber, ctx2);
          set12.value(ctx2, formatValue(ctx2, nextValue));
        },
        setRawValue(ctx2, evt) {
          const parsedValue = parseValue(ctx2, evt.value);
          const value = formatValue(ctx2, clamp3(parsedValue, ctx2));
          set12.value(ctx2, value);
        },
        setValue(ctx2, evt) {
          var _a;
          const value = ((_a = evt.target) == null ? void 0 : _a.value) ?? evt.value;
          set12.value(ctx2, value);
        },
        clearValue(ctx2) {
          set12.value(ctx2, "");
        },
        incrementToMax(ctx2) {
          const value = formatValue(ctx2, ctx2.max);
          set12.value(ctx2, value);
        },
        decrementToMin(ctx2) {
          const value = formatValue(ctx2, ctx2.min);
          set12.value(ctx2, value);
        },
        setHint(ctx2, evt) {
          ctx2.hint = evt.hint;
        },
        clearHint(ctx2) {
          ctx2.hint = null;
        },
        setHintToSet(ctx2) {
          ctx2.hint = "set";
        },
        invokeOnFocus(ctx2) {
          var _a;
          (_a = ctx2.onFocusChange) == null ? void 0 : _a.call(ctx2, {
            focused: true,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnBlur(ctx2) {
          var _a;
          (_a = ctx2.onFocusChange) == null ? void 0 : _a.call(ctx2, {
            focused: false,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        invokeOnInvalid(ctx2) {
          var _a;
          if (!ctx2.isOutOfRange)
            return;
          const reason = ctx2.valueAsNumber > ctx2.max ? "rangeOverflow" : "rangeUnderflow";
          (_a = ctx2.onValueInvalid) == null ? void 0 : _a.call(ctx2, {
            reason,
            value: ctx2.formattedValue,
            valueAsNumber: ctx2.valueAsNumber
          });
        },
        syncInputElement(ctx2, evt) {
          const value = evt.type.endsWith("CHANGE") ? ctx2.value : ctx2.formattedValue;
          sync4.input(ctx2, value);
        },
        setFormattedValue(ctx2) {
          set12.value(ctx2, ctx2.formattedValue);
        },
        setCursorPoint(ctx2, evt) {
          ctx2.scrubberCursorPoint = evt.point;
        },
        clearCursorPoint(ctx2) {
          ctx2.scrubberCursorPoint = null;
        },
        setVirtualCursorPosition(ctx2) {
          const cursorEl = dom15.getCursorEl(ctx2);
          if (!cursorEl || !ctx2.scrubberCursorPoint)
            return;
          const { x, y } = ctx2.scrubberCursorPoint;
          cursorEl.style.transform = `translate3d(${x}px, ${y}px, 0px)`;
        },
        setFormatterAndParser(ctx2) {
          if (!ctx2.locale)
            return;
          ctx2.formatter = createFormatter(ctx2.locale, ctx2.formatOptions);
          ctx2.parser = createParser(ctx2.locale, ctx2.formatOptions);
        }
      },
      compareFns: {
        formatOptions: (a2, b2) => isEqual(a2, b2),
        scrubberCursorPoint: (a2, b2) => isEqual(a2, b2)
      }
    }
  );
}
var sync4 = {
  input(ctx, value) {
    const inputEl = dom15.getInputEl(ctx);
    if (!inputEl)
      return;
    const sel = recordCursor(inputEl);
    raf(() => {
      dom15.setValue(inputEl, value);
      restoreCursor(inputEl, sel);
    });
  }
};
var invoke9 = {
  onChange: (ctx) => {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value: ctx.value,
      valueAsNumber: ctx.valueAsNumber
    });
  }
};
var set12 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke9.onChange(ctx);
  }
};

// node_modules/@zag-js/pagination/dist/index.mjs
var anatomy20 = createAnatomy("pagination").parts("root", "item", "ellipsis", "prevTrigger", "nextTrigger");
var parts16 = anatomy20.build();
var dom16 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `pagination:${ctx.id}`;
  },
  getPrevTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.prevTrigger) ?? `pagination:${ctx.id}:prev`;
  },
  getNextTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.nextTrigger) ?? `pagination:${ctx.id}:next`;
  },
  getEllipsisId: (ctx, index) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.ellipsis) == null ? void 0 : _b.call(_a, index)) ?? `pagination:${ctx.id}:ellipsis:${index}`;
  },
  getItemId: (ctx, page) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, page)) ?? `pagination:${ctx.id}:item:${page}`;
  }
});
var range = (start, end) => {
  let length = end - start + 1;
  return Array.from({ length }, (_, idx) => idx + start);
};
var transform = (items) => {
  return items.map((value) => {
    if (typeof value === "number")
      return { type: "page", value };
    return { type: "ellipsis" };
  });
};
var ELLIPSIS = "ellipsis";
var getRange = (ctx) => {
  const totalPageNumbers = Math.min(2 * ctx.siblingCount + 5, ctx.totalPages);
  const firstPageIndex = 1;
  const lastPageIndex = ctx.totalPages;
  const leftSiblingIndex = Math.max(ctx.page - ctx.siblingCount, firstPageIndex);
  const rightSiblingIndex = Math.min(ctx.page + ctx.siblingCount, lastPageIndex);
  const showLeftEllipsis = leftSiblingIndex > firstPageIndex + 1;
  const showRightEllipsis = rightSiblingIndex < lastPageIndex - 1;
  const itemCount = totalPageNumbers - 2;
  if (!showLeftEllipsis && showRightEllipsis) {
    const leftRange = range(1, itemCount);
    return [...leftRange, ELLIPSIS, lastPageIndex];
  }
  if (showLeftEllipsis && !showRightEllipsis) {
    const rightRange = range(lastPageIndex - itemCount + 1, lastPageIndex);
    return [firstPageIndex, ELLIPSIS, ...rightRange];
  }
  if (showLeftEllipsis && showRightEllipsis) {
    const middleRange = range(leftSiblingIndex, rightSiblingIndex);
    return [firstPageIndex, ELLIPSIS, ...middleRange, ELLIPSIS, lastPageIndex];
  }
  const fullRange = range(firstPageIndex, lastPageIndex);
  return fullRange;
};
var getTransformedRange = (ctx) => transform(getRange(ctx));
function connect16(state2, send, normalize) {
  const totalPages = state2.context.totalPages;
  const page = state2.context.page;
  const translations = state2.context.translations;
  const previousPage = state2.context.previousPage;
  const nextPage = state2.context.nextPage;
  const pageRange = state2.context.pageRange;
  const type = state2.context.type;
  const isButton = type === "button";
  const isFirstPage = page === 1;
  const isLastPage = page === totalPages;
  return {
    page,
    pageSize: state2.context.pageSize,
    totalPages,
    pages: getTransformedRange(state2.context),
    previousPage,
    nextPage,
    pageRange,
    slice(data) {
      return data.slice(pageRange.start, pageRange.end);
    },
    setCount(count) {
      send({ type: "SET_COUNT", count });
    },
    setPageSize(size3) {
      send({ type: "SET_PAGE_SIZE", size: size3 });
    },
    setPage(page2) {
      send({ type: "SET_PAGE", page: page2 });
    },
    getRootProps() {
      return normalize.element({
        id: dom16.getRootId(state2.context),
        ...parts16.root.attrs,
        dir: state2.context.dir,
        "aria-label": translations.rootLabel
      });
    },
    getEllipsisProps(props29) {
      return normalize.element({
        id: dom16.getEllipsisId(state2.context, props29.index),
        ...parts16.ellipsis.attrs,
        dir: state2.context.dir
      });
    },
    getItemProps(props29) {
      var _a;
      const index = props29.value;
      const isCurrentPage = index === state2.context.page;
      return normalize.element({
        id: dom16.getItemId(state2.context, index),
        ...parts16.item.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-selected": dataAttr(isCurrentPage),
        "aria-current": isCurrentPage ? "page" : void 0,
        "aria-label": (_a = translations.itemLabel) == null ? void 0 : _a.call(translations, { page: index, totalPages }),
        onClick() {
          send({ type: "SET_PAGE", page: index });
        },
        ...isButton && { type: "button" }
      });
    },
    getPrevTriggerProps() {
      return normalize.element({
        id: dom16.getPrevTriggerId(state2.context),
        ...parts16.prevTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isFirstPage),
        "aria-label": translations.prevTriggerLabel,
        onClick() {
          send({ type: "PREVIOUS_PAGE" });
        },
        ...isButton && { disabled: isFirstPage, type: "button" }
      });
    },
    getNextTriggerProps() {
      return normalize.element({
        id: dom16.getNextTriggerId(state2.context),
        ...parts16.nextTrigger.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(isLastPage),
        "aria-label": translations.nextTriggerLabel,
        onClick() {
          send({ type: "NEXT_PAGE" });
        },
        ...isButton && { disabled: isLastPage, type: "button" }
      });
    }
  };
}
function machine16(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "pagination",
      initial: "idle",
      context: {
        pageSize: 10,
        siblingCount: 1,
        page: 1,
        type: "button",
        translations: {
          rootLabel: "pagination",
          prevTriggerLabel: "previous page",
          nextTriggerLabel: "next page",
          itemLabel({ page, totalPages }) {
            const isLastPage = totalPages > 1 && page === totalPages;
            return `${isLastPage ? "last page, " : ""}page ${page}`;
          },
          ...ctx.translations
        },
        ...ctx
      },
      watch: {
        pageSize: ["setPageIfNeeded"]
      },
      computed: {
        totalPages: (ctx2) => Math.ceil(ctx2.count / ctx2.pageSize),
        previousPage: (ctx2) => ctx2.page === 1 ? null : ctx2.page - 1,
        nextPage: (ctx2) => ctx2.page === ctx2.totalPages ? null : ctx2.page + 1,
        pageRange: (ctx2) => {
          const start = (ctx2.page - 1) * ctx2.pageSize;
          const end = start + ctx2.pageSize;
          return { start, end };
        },
        isValidPage: (ctx2) => ctx2.page >= 1 && ctx2.page <= ctx2.totalPages
      },
      on: {
        SET_COUNT: [
          {
            guard: "isValidCount",
            actions: ["setCount", "goToFirstPage"]
          },
          {
            actions: "setCount"
          }
        ],
        SET_PAGE: {
          guard: "isValidPage",
          actions: "setPage"
        },
        SET_PAGE_SIZE: {
          actions: "setPageSize"
        },
        PREVIOUS_PAGE: {
          guard: "canGoToPrevPage",
          actions: "goToPrevPage"
        },
        NEXT_PAGE: {
          guard: "canGoToNextPage",
          actions: "goToNextPage"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isValidPage: (ctx2, evt) => evt.page >= 1 && evt.page <= ctx2.totalPages,
        isValidCount: (ctx2, evt) => ctx2.page > evt.count,
        canGoToNextPage: (ctx2) => ctx2.page < ctx2.totalPages,
        canGoToPrevPage: (ctx2) => ctx2.page > 1
      },
      actions: {
        setCount(ctx2, evt) {
          ctx2.count = evt.count;
        },
        setPage(ctx2, evt) {
          set13.page(ctx2, evt.page);
        },
        setPageSize(ctx2, evt) {
          set13.pageSize(ctx2, evt.size);
        },
        goToFirstPage(ctx2) {
          set13.page(ctx2, 1);
        },
        goToPrevPage(ctx2) {
          set13.page(ctx2, ctx2.page - 1);
        },
        goToNextPage(ctx2) {
          set13.page(ctx2, ctx2.page + 1);
        },
        setPageIfNeeded(ctx2, _evt) {
          if (ctx2.isValidPage)
            return;
          set13.page(ctx2, 1);
        }
      }
    }
  );
}
var set13 = {
  pageSize: (ctx, value) => {
    var _a;
    if (isEqual(ctx.pageSize, value))
      return;
    ctx.pageSize = value;
    (_a = ctx.onPageSizeChange) == null ? void 0 : _a.call(ctx, { pageSize: ctx.pageSize });
  },
  page: (ctx, value) => {
    var _a;
    if (isEqual(ctx.page, value))
      return;
    ctx.page = value;
    (_a = ctx.onPageChange) == null ? void 0 : _a.call(ctx, { page: ctx.page, pageSize: ctx.pageSize });
  }
};
var props13 = createProps()([
  "count",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onPageChange",
  "onPageSizeChange",
  "page",
  "pageSize",
  "siblingCount",
  "translations",
  "type"
]);
var splitProps13 = createSplitProps(props13);
var itemProps4 = createProps()(["value", "type"]);
var splitItemProps4 = createSplitProps(itemProps4);
var ellipsisProps = createProps()(["index"]);
var splitEllipsisProps = createSplitProps(ellipsisProps);

// node_modules/@zag-js/pin-input/dist/index.mjs
var anatomy21 = createAnatomy("pinInput").parts("root", "label", "input", "control");
var parts17 = anatomy21.build();
var dom17 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `pin-input:${ctx.id}`;
  },
  getInputId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.input) == null ? void 0 : _b.call(_a, id)) ?? `pin-input:${ctx.id}:${id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `pin-input:${ctx.id}:hidden`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `pin-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `pin-input:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom17.getById(ctx, dom17.getRootId(ctx)),
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom17.getRootId(ctx));
    const selector = `input[data-ownedby=${ownerId}]`;
    return queryAll(dom17.getRootEl(ctx), selector);
  },
  getInputEl: (ctx, id) => dom17.getById(ctx, dom17.getInputId(ctx, id)),
  getFocusedInputEl: (ctx) => dom17.getInputEls(ctx)[ctx.focusedIndex],
  getFirstInputEl: (ctx) => dom17.getInputEls(ctx)[0],
  getHiddenInputEl: (ctx) => dom17.getById(ctx, dom17.getHiddenInputId(ctx))
});
var REGEX = {
  numeric: /^[0-9]+$/,
  alphabetic: /^[A-Za-z]+$/,
  alphanumeric: /^[a-zA-Z0-9]+$/i
};
function isValidType(ctx, value) {
  var _a;
  if (!ctx.type)
    return true;
  return !!((_a = REGEX[ctx.type]) == null ? void 0 : _a.test(value));
}
function isValidValue(ctx, value) {
  if (!ctx.pattern)
    return isValidType(ctx, value);
  const regex = new RegExp(ctx.pattern, "g");
  return regex.test(value);
}
function connect17(state2, send, normalize) {
  const complete = state2.context.isValueComplete;
  const invalid = state2.context.invalid;
  const focusedIndex = state2.context.focusedIndex;
  const translations = state2.context.translations;
  function focus() {
    var _a;
    (_a = dom17.getFirstInputEl(state2.context)) == null ? void 0 : _a.focus();
  }
  return {
    focus,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    complete,
    setValue(value) {
      if (!Array.isArray(value)) {
        invariant("[pin-input/setValue] value must be an array");
      }
      send({ type: "VALUE.SET", value });
    },
    clearValue() {
      send({ type: "VALUE.CLEAR" });
    },
    setValueAtIndex(index, value) {
      send({ type: "VALUE.SET", value, index });
    },
    getRootProps() {
      return normalize.element({
        dir: state2.context.dir,
        ...parts17.root.attrs,
        id: dom17.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete)
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts17.label.attrs,
        dir: state2.context.dir,
        htmlFor: dom17.getHiddenInputId(state2.context),
        id: dom17.getLabelId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        onClick(event) {
          event.preventDefault();
          focus();
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        "aria-hidden": true,
        type: "text",
        tabIndex: -1,
        id: dom17.getHiddenInputId(state2.context),
        name: state2.context.name,
        form: state2.context.form,
        style: visuallyHiddenStyle,
        maxLength: state2.context.valueLength,
        defaultValue: state2.context.valueAsString
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts17.control.attrs,
        dir: state2.context.dir,
        id: dom17.getControlId(state2.context)
      });
    },
    getInputProps(props29) {
      const { index } = props29;
      const inputType = state2.context.type === "numeric" ? "tel" : "text";
      return normalize.input({
        ...parts17.input.attrs,
        dir: state2.context.dir,
        disabled: state2.context.disabled,
        "data-disabled": dataAttr(state2.context.disabled),
        "data-complete": dataAttr(complete),
        id: dom17.getInputId(state2.context, index.toString()),
        "data-ownedby": dom17.getRootId(state2.context),
        "aria-label": translations.inputLabel(index, state2.context.valueLength),
        inputMode: state2.context.otp || state2.context.type === "numeric" ? "numeric" : "text",
        "aria-invalid": ariaAttr(invalid),
        "data-invalid": dataAttr(invalid),
        type: state2.context.mask ? "password" : inputType,
        defaultValue: state2.context.value[index] || "",
        autoCapitalize: "none",
        autoComplete: state2.context.otp ? "one-time-code" : "off",
        placeholder: focusedIndex === index ? "" : state2.context.placeholder,
        onBeforeInput(event) {
          try {
            const value = getBeforeInputValue(event);
            const isValid = isValidValue(state2.context, value);
            if (!isValid) {
              send({ type: "VALUE.INVALID", value });
              event.preventDefault();
            }
            if (value.length > 2) {
              event.currentTarget.setSelectionRange(0, 1, "forward");
            }
          } catch {
          }
        },
        onChange(event) {
          const evt = getNativeEvent(event);
          const { value } = event.currentTarget;
          if (evt.inputType === "insertFromPaste" || value.length > 2) {
            send({ type: "INPUT.PASTE", value });
            event.target.value = value[0];
            event.preventDefault();
            return;
          }
          if (evt.inputType === "deleteContentBackward") {
            send("INPUT.BACKSPACE");
            return;
          }
          send({ type: "INPUT.CHANGE", value, index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (isComposingEvent(event))
            return;
          if (isModifierKey(event))
            return;
          const keyMap2 = {
            Backspace() {
              send("INPUT.BACKSPACE");
            },
            Delete() {
              send("INPUT.DELETE");
            },
            ArrowLeft() {
              send("INPUT.ARROW_LEFT");
            },
            ArrowRight() {
              send("INPUT.ARROW_RIGHT");
            },
            Enter() {
              send("INPUT.ENTER");
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        },
        onFocus() {
          send({ type: "INPUT.FOCUS", index });
        },
        onBlur() {
          send({ type: "INPUT.BLUR", index });
        }
      });
    }
  };
}
function machine17(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "pin-input",
      initial: "idle",
      context: {
        value: [],
        placeholder: "",
        otp: false,
        type: "numeric",
        ...ctx,
        focusedIndex: -1,
        translations: {
          inputLabel: (index, length) => `pin code ${index + 1} of ${length}`,
          ...ctx.translations
        }
      },
      computed: {
        valueLength: (ctx2) => ctx2.value.length,
        filledValueLength: (ctx2) => ctx2.value.filter((v) => (v == null ? void 0 : v.trim()) !== "").length,
        isValueComplete: (ctx2) => ctx2.valueLength === ctx2.filledValueLength,
        valueAsString: (ctx2) => ctx2.value.join(""),
        focusedValue: (ctx2) => ctx2.value[ctx2.focusedIndex] || ""
      },
      entry: choose([
        {
          guard: "autoFocus",
          actions: ["setupValue", "setFocusIndexToFirst"]
        },
        { actions: ["setupValue"] }
      ]),
      watch: {
        focusedIndex: ["focusInput", "selectInputIfNeeded"],
        value: ["syncInputElements"],
        isValueComplete: ["invokeOnComplete", "blurFocusedInputIfNeeded"]
      },
      on: {
        "VALUE.SET": [
          {
            guard: "hasIndex",
            actions: ["setValueAtIndex"]
          },
          { actions: ["setValue"] }
        ],
        "VALUE.CLEAR": {
          actions: ["clearValue", "setFocusIndexToFirst"]
        }
      },
      states: {
        idle: {
          on: {
            "INPUT.FOCUS": {
              target: "focused",
              actions: "setFocusedIndex"
            }
          }
        },
        focused: {
          on: {
            "INPUT.CHANGE": [
              {
                guard: "isFinalValue",
                actions: ["setFocusedValue", "syncInputValue"]
              },
              {
                actions: ["setFocusedValue", "setNextFocusedIndex", "syncInputValue"]
              }
            ],
            "INPUT.PASTE": {
              actions: ["setPastedValue", "setLastValueFocusIndex"]
            },
            "INPUT.BLUR": {
              target: "idle",
              actions: "clearFocusedIndex"
            },
            "INPUT.DELETE": {
              guard: "hasValue",
              actions: "clearFocusedValue"
            },
            "INPUT.ARROW_LEFT": {
              actions: "setPrevFocusedIndex"
            },
            "INPUT.ARROW_RIGHT": {
              actions: "setNextFocusedIndex"
            },
            "INPUT.BACKSPACE": [
              {
                guard: "hasValue",
                actions: ["clearFocusedValue"]
              },
              {
                actions: ["setPrevFocusedIndex", "clearFocusedValue"]
              }
            ],
            "INPUT.ENTER": {
              guard: "isValueComplete",
              actions: "requestFormSubmit"
            },
            "VALUE.INVALID": {
              actions: "invokeOnInvalid"
            }
          }
        }
      }
    },
    {
      guards: {
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        isValueEmpty: (_ctx, evt) => evt.value === "",
        hasValue: (ctx2) => ctx2.value[ctx2.focusedIndex] !== "",
        isValueComplete: (ctx2) => ctx2.isValueComplete,
        isFinalValue: (ctx2) => ctx2.filledValueLength + 1 === ctx2.valueLength && ctx2.value.findIndex((v) => v.trim() === "") === ctx2.focusedIndex,
        hasIndex: (_ctx, evt) => evt.index !== void 0,
        isDisabled: (ctx2) => !!ctx2.disabled
      },
      actions: {
        setupValue(ctx2) {
          if (ctx2.value.length)
            return;
          const inputEls = dom17.getInputEls(ctx2);
          const emptyValues = Array.from({ length: inputEls.length }).fill("");
          assignValue(ctx2, emptyValues);
        },
        focusInput(ctx2) {
          var _a;
          if (ctx2.focusedIndex === -1)
            return;
          (_a = dom17.getFocusedInputEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
        },
        selectInputIfNeeded(ctx2) {
          if (!ctx2.selectOnFocus || ctx2.focusedIndex === -1)
            return;
          raf(() => {
            var _a;
            (_a = dom17.getFocusedInputEl(ctx2)) == null ? void 0 : _a.select();
          });
        },
        invokeOnComplete(ctx2) {
          var _a;
          if (!ctx2.isValueComplete)
            return;
          (_a = ctx2.onValueComplete) == null ? void 0 : _a.call(ctx2, {
            value: Array.from(ctx2.value),
            valueAsString: ctx2.valueAsString
          });
        },
        invokeOnInvalid(ctx2, evt) {
          var _a;
          (_a = ctx2.onValueInvalid) == null ? void 0 : _a.call(ctx2, {
            value: evt.value,
            index: ctx2.focusedIndex
          });
        },
        clearFocusedIndex(ctx2) {
          ctx2.focusedIndex = -1;
        },
        setFocusedIndex(ctx2, evt) {
          ctx2.focusedIndex = evt.index;
        },
        setValue(ctx2, evt) {
          set14.value(ctx2, evt.value);
        },
        setFocusedValue(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, nextValue);
        },
        revertInputValue(ctx2) {
          const inputEl = dom17.getFocusedInputEl(ctx2);
          dom17.setValue(inputEl, ctx2.focusedValue);
        },
        syncInputValue(ctx2, evt) {
          const inputEl = dom17.getInputEl(ctx2, evt.index.toString());
          dom17.setValue(inputEl, ctx2.value[evt.index]);
        },
        syncInputElements(ctx2) {
          const inputEls = dom17.getInputEls(ctx2);
          inputEls.forEach((inputEl, index) => {
            dom17.setValue(inputEl, ctx2.value[index]);
          });
        },
        setPastedValue(ctx2, evt) {
          raf(() => {
            const startIndex = Math.min(ctx2.focusedIndex, ctx2.filledValueLength);
            const left = startIndex > 0 ? ctx2.valueAsString.substring(0, ctx2.focusedIndex) : "";
            const right = evt.value.substring(0, ctx2.valueLength - startIndex);
            const value = left + right;
            set14.value(ctx2, value.split(""));
          });
        },
        setValueAtIndex(ctx2, evt) {
          const nextValue = getNextValue(ctx2.focusedValue, evt.value);
          set14.valueAtIndex(ctx2, evt.index, nextValue);
        },
        clearValue(ctx2) {
          const nextValue = Array.from({ length: ctx2.valueLength }).fill("");
          set14.value(ctx2, nextValue);
        },
        clearFocusedValue(ctx2) {
          set14.valueAtIndex(ctx2, ctx2.focusedIndex, "");
        },
        setFocusIndexToFirst(ctx2) {
          ctx2.focusedIndex = 0;
        },
        setNextFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.min(ctx2.focusedIndex + 1, ctx2.valueLength - 1);
        },
        setPrevFocusedIndex(ctx2) {
          ctx2.focusedIndex = Math.max(ctx2.focusedIndex - 1, 0);
        },
        setLastValueFocusIndex(ctx2) {
          raf(() => {
            ctx2.focusedIndex = Math.min(ctx2.filledValueLength, ctx2.valueLength - 1);
          });
        },
        blurFocusedInputIfNeeded(ctx2) {
          if (!ctx2.blurOnComplete)
            return;
          raf(() => {
            var _a;
            (_a = dom17.getFocusedInputEl(ctx2)) == null ? void 0 : _a.blur();
          });
        },
        requestFormSubmit(ctx2) {
          var _a;
          if (!ctx2.name || !ctx2.isValueComplete)
            return;
          const inputEl = dom17.getHiddenInputEl(ctx2);
          (_a = inputEl == null ? void 0 : inputEl.form) == null ? void 0 : _a.requestSubmit();
        }
      }
    }
  );
}
function assignValue(ctx, value) {
  const arr = Array.isArray(value) ? value : value.split("").filter(Boolean);
  arr.forEach((value2, index) => {
    ctx.value[index] = value2;
  });
}
function getNextValue(current, next) {
  let nextValue = next;
  if (current[0] === next[0])
    nextValue = next[1];
  else if (current[0] === next[1])
    nextValue = next[0];
  return nextValue.split("")[nextValue.length - 1];
}
var invoke10 = {
  change(ctx) {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value: Array.from(ctx.value),
      valueAsString: ctx.valueAsString
    });
    const inputEl = dom17.getHiddenInputEl(ctx);
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
};
var set14 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value))
      return;
    assignValue(ctx, value);
    invoke10.change(ctx);
  },
  valueAtIndex(ctx, index, value) {
    if (isEqual(ctx.value[index], value))
      return;
    ctx.value[index] = value;
    invoke10.change(ctx);
  }
};

// node_modules/@zag-js/popover/dist/index.mjs
var anatomy22 = createAnatomy("popover").parts(
  "arrow",
  "arrowTip",
  "anchor",
  "trigger",
  "indicator",
  "positioner",
  "content",
  "title",
  "description",
  "closeTrigger"
);
var parts18 = anatomy22.build();
var dom18 = createScope({
  getAnchorId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.anchor) ?? `popover:${ctx.id}:anchor`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `popover:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `popover:${ctx.id}:content`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `popover:${ctx.id}:popper`;
  },
  getArrowId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.arrow) ?? `popover:${ctx.id}:arrow`;
  },
  getTitleId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.title) ?? `popover:${ctx.id}:title`;
  },
  getDescriptionId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.description) ?? `popover:${ctx.id}:desc`;
  },
  getCloseTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.closeTrigger) ?? `popover:${ctx.id}:close`;
  },
  getAnchorEl: (ctx) => dom18.getById(ctx, dom18.getAnchorId(ctx)),
  getTriggerEl: (ctx) => dom18.getById(ctx, dom18.getTriggerId(ctx)),
  getContentEl: (ctx) => dom18.getById(ctx, dom18.getContentId(ctx)),
  getPositionerEl: (ctx) => dom18.getById(ctx, dom18.getPositionerId(ctx)),
  getTitleEl: (ctx) => dom18.getById(ctx, dom18.getTitleId(ctx)),
  getDescriptionEl: (ctx) => dom18.getById(ctx, dom18.getDescriptionId(ctx)),
  getFocusableEls: (ctx) => getFocusables(dom18.getContentEl(ctx)),
  getFirstFocusableEl: (ctx) => dom18.getFocusableEls(ctx)[0]
});
function connect18(state2, send, normalize) {
  const open = state2.matches("open");
  const currentPlacement = state2.context.currentPlacement;
  const portalled = state2.context.currentPortalled;
  const rendered = state2.context.renderedElements;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: currentPlacement
  });
  return {
    portalled,
    open,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getArrowProps() {
      return normalize.element({
        id: dom18.getArrowId(state2.context),
        ...parts18.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts18.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getAnchorProps() {
      return normalize.element({
        ...parts18.anchor.attrs,
        dir: state2.context.dir,
        id: dom18.getAnchorId(state2.context)
      });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts18.trigger.attrs,
        dir: state2.context.dir,
        type: "button",
        "data-placement": currentPlacement,
        id: dom18.getTriggerId(state2.context),
        "aria-haspopup": "dialog",
        "aria-expanded": open,
        "data-state": open ? "open" : "closed",
        "aria-controls": dom18.getContentId(state2.context),
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("TOGGLE");
        },
        onBlur(event) {
          send({ type: "TRIGGER_BLUR", target: event.relatedTarget });
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts18.indicator.attrs,
        dir: state2.context.dir,
        "data-state": open ? "open" : "closed"
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: dom18.getPositionerId(state2.context),
        ...parts18.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts18.content.attrs,
        dir: state2.context.dir,
        id: dom18.getContentId(state2.context),
        tabIndex: -1,
        role: "dialog",
        hidden: !open,
        "data-state": open ? "open" : "closed",
        "data-expanded": dataAttr(open),
        "aria-labelledby": rendered.title ? dom18.getTitleId(state2.context) : void 0,
        "aria-describedby": rendered.description ? dom18.getDescriptionId(state2.context) : void 0,
        "data-placement": currentPlacement
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts18.title.attrs,
        id: dom18.getTitleId(state2.context),
        dir: state2.context.dir
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts18.description.attrs,
        id: dom18.getDescriptionId(state2.context),
        dir: state2.context.dir
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        ...parts18.closeTrigger.attrs,
        dir: state2.context.dir,
        id: dom18.getCloseTriggerId(state2.context),
        type: "button",
        "aria-label": "close",
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("CLOSE");
        }
      });
    }
  };
}
function machine18(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "popover",
      initial: ctx.open ? "open" : "closed",
      context: {
        closeOnInteractOutside: true,
        closeOnEscape: true,
        autoFocus: true,
        modal: false,
        portalled: true,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        },
        currentPlacement: void 0,
        ...ctx,
        renderedElements: {
          title: true,
          description: true
        }
      },
      computed: {
        currentPortalled: (ctx2) => !!ctx2.modal || !!ctx2.portalled
      },
      watch: {
        open: ["toggleVisibility"]
      },
      entry: ["checkRenderedElements"],
      states: {
        closed: {
          on: {
            "CONTROLLED.OPEN": {
              target: "open",
              actions: ["setInitialFocus"]
            },
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "setInitialFocus"]
              }
            ]
          }
        },
        open: {
          activities: [
            "trapFocus",
            "preventScroll",
            "hideContentBelow",
            "trackPositioning",
            "trackDismissableElement",
            "proxyTabFocus"
          ],
          on: {
            "CONTROLLED.CLOSE": {
              target: "closed",
              actions: ["setFinalFocus"]
            },
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose", "setFinalFocus"]
              }
            ],
            TOGGLE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      guards: {
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const anchorEl = dom18.getAnchorEl(ctx2) ?? dom18.getTriggerEl(ctx2);
          const getPositionerEl = () => dom18.getPositionerEl(ctx2);
          return getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const getContentEl = () => dom18.getContentEl(ctx2);
          let restoreFocus = true;
          return trackDismissableElement(getContentEl, {
            pointerBlocking: ctx2.modal,
            exclude: dom18.getTriggerEl(ctx2),
            defer: true,
            onEscapeKeyDown(event) {
              var _a;
              (_a = ctx2.onEscapeKeyDown) == null ? void 0 : _a.call(ctx2, event);
              if (ctx2.closeOnEscape)
                return;
              event.preventDefault();
            },
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              if (event.defaultPrevented)
                return;
              restoreFocus = !(event.detail.focusable || event.detail.contextmenu);
              if (!ctx2.closeOnInteractOutside) {
                event.preventDefault();
              }
            },
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onFocusOutside: ctx2.onFocusOutside,
            persistentElements: ctx2.persistentElements,
            onDismiss() {
              send({ type: "CLOSE", src: "interact-outside", restoreFocus });
            }
          });
        },
        proxyTabFocus(ctx2) {
          if (ctx2.modal || !ctx2.portalled)
            return;
          const getContentEl = () => dom18.getContentEl(ctx2);
          return proxyTabFocus(getContentEl, {
            triggerElement: dom18.getTriggerEl(ctx2),
            defer: true,
            onFocus(el) {
              el.focus({ preventScroll: true });
            }
          });
        },
        hideContentBelow(ctx2) {
          if (!ctx2.modal)
            return;
          const getElements = () => [dom18.getContentEl(ctx2), dom18.getTriggerEl(ctx2)];
          return ariaHidden(getElements, { defer: true });
        },
        preventScroll(ctx2) {
          if (!ctx2.modal)
            return;
          return preventBodyScroll(dom18.getDoc(ctx2));
        },
        trapFocus(ctx2) {
          if (!ctx2.modal)
            return;
          let trap;
          nextTick(() => {
            const contentEl = dom18.getContentEl(ctx2);
            if (!contentEl)
              return;
            trap = createFocusTrap(contentEl, {
              escapeDeactivates: false,
              allowOutsideClick: true,
              preventScroll: true,
              returnFocusOnDeactivate: true,
              document: dom18.getDoc(ctx2),
              fallbackFocus: contentEl,
              initialFocus: getInitialFocus({
                root: dom18.getContentEl(ctx2),
                getInitialEl: ctx2.initialFocusEl,
                enabled: ctx2.autoFocus
              })
            });
            try {
              trap.activate();
            } catch {
            }
          });
          return () => trap == null ? void 0 : trap.deactivate();
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const anchorEl = dom18.getAnchorEl(ctx2) ?? dom18.getTriggerEl(ctx2);
          const getPositionerEl = () => dom18.getPositionerEl(ctx2);
          getPlacement(anchorEl, getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        checkRenderedElements(ctx2) {
          raf(() => {
            Object.assign(ctx2.renderedElements, {
              title: !!dom18.getTitleEl(ctx2),
              description: !!dom18.getDescriptionEl(ctx2)
            });
          });
        },
        setInitialFocus(ctx2) {
          if (ctx2.modal)
            return;
          raf(() => {
            const element = getInitialFocus({
              root: dom18.getContentEl(ctx2),
              getInitialEl: ctx2.initialFocusEl,
              enabled: ctx2.autoFocus
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2, evt) {
          if (!evt.restoreFocus)
            return;
          raf(() => {
            const element = dom18.getTriggerEl(ctx2);
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        }
      }
    }
  );
}
var props14 = createProps()([
  "autoFocus",
  "closeOnEscape",
  "closeOnInteractOutside",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "initialFocusEl",
  "modal",
  "onEscapeKeyDown",
  "onFocusOutside",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "open.controlled",
  "open",
  "persistentElements",
  "portalled",
  "positioning"
]);
var splitProps14 = createSplitProps(props14);

// node_modules/@zag-js/progress/dist/index.mjs
var anatomy23 = createAnatomy("progress").parts(
  "root",
  "label",
  "track",
  "range",
  "valueText",
  "view",
  "circle",
  "circleTrack",
  "circleRange"
);
var parts19 = anatomy23.build();
var dom19 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `progress-${ctx.id}`;
  },
  getTrackId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.track) ?? `progress-${ctx.id}-track`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `progress-${ctx.id}-label`;
  },
  getCircleId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.circle) ?? `progress-${ctx.id}-circle`;
  }
});
function connect19(state2, send, normalize) {
  const percent = state2.context.percent;
  const max3 = state2.context.max;
  const min3 = state2.context.min;
  const orientation = state2.context.orientation;
  const translations = state2.context.translations;
  const indeterminate = state2.context.isIndeterminate;
  const value = state2.context.value;
  const valueAsString = translations.value({ value, max: max3, percent, min: min3 });
  const progressState = getProgressState(value, max3);
  const progressbarProps = {
    role: "progressbar",
    "aria-label": valueAsString,
    "data-max": max3,
    "aria-valuemin": min3,
    "aria-valuemax": max3,
    "aria-valuenow": value ?? void 0,
    "data-orientation": orientation,
    "data-state": progressState
  };
  const circleProps = getCircleProps(state2.context);
  return {
    value,
    valueAsString,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    setToMax() {
      send({ type: "VALUE.SET", value: max3 });
    },
    getRootProps() {
      return normalize.element({
        dir: state2.context.dir,
        ...parts19.root.attrs,
        id: dom19.getRootId(state2.context),
        "data-max": max3,
        "data-value": value ?? void 0,
        "data-state": progressState,
        "data-orientation": orientation,
        style: {
          "--percent": indeterminate ? void 0 : percent
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        dir: state2.context.dir,
        id: dom19.getLabelId(state2.context),
        ...parts19.label.attrs,
        "data-orientation": orientation
      });
    },
    getValueTextProps() {
      return normalize.element({
        dir: state2.context.dir,
        "aria-live": "polite",
        ...parts19.valueText.attrs
      });
    },
    getTrackProps() {
      return normalize.element({
        dir: state2.context.dir,
        id: dom19.getTrackId(state2.context),
        ...parts19.track.attrs,
        ...progressbarProps
      });
    },
    getRangeProps() {
      return normalize.element({
        dir: state2.context.dir,
        ...parts19.range.attrs,
        "data-orientation": orientation,
        "data-state": progressState,
        style: {
          [state2.context.isHorizontal ? "width" : "height"]: indeterminate ? void 0 : `${percent}%`
        }
      });
    },
    getCircleProps() {
      return normalize.element({
        dir: state2.context.dir,
        id: dom19.getCircleId(state2.context),
        ...parts19.circle.attrs,
        ...progressbarProps,
        ...circleProps.root
      });
    },
    getCircleTrackProps() {
      return normalize.element({
        dir: state2.context.dir,
        "data-orientation": orientation,
        ...parts19.circleTrack.attrs,
        ...circleProps.track
      });
    },
    getCircleRangeProps() {
      return normalize.element({
        dir: state2.context.dir,
        ...parts19.circleRange.attrs,
        ...circleProps.range,
        "data-state": progressState
      });
    },
    getViewProps(props29) {
      return normalize.element({
        dir: state2.context.dir,
        ...parts19.view.attrs,
        "data-state": props29.state,
        hidden: props29.state !== progressState
      });
    }
  };
}
function getProgressState(value, maxValue) {
  return value == null ? "indeterminate" : value === maxValue ? "complete" : "loading";
}
function getCircleProps(ctx) {
  const circleProps = {
    style: {
      "--radius": "calc(var(--size) / 2 - var(--thickness) / 2)",
      cx: "calc(var(--size) / 2)",
      cy: "calc(var(--size) / 2)",
      r: "var(--radius)",
      fill: "transparent",
      strokeWidth: "var(--thickness)"
    }
  };
  return {
    root: {
      viewBox: "0 0 var(--size) var(--size)",
      style: {
        width: "var(--size)",
        height: "var(--size)"
      }
    },
    track: circleProps,
    range: {
      opacity: ctx.value === 0 ? 0 : void 0,
      style: {
        ...circleProps.style,
        "--percent": ctx.percent,
        "--circumference": `calc(2 * 3.14159 * var(--radius))`,
        "--offset": `calc(var(--circumference) * (100 - var(--percent)) / 100}))`,
        strokeDashoffset: `calc(var(--circumference) * ((100 - var(--percent)) / 100))`,
        strokeDasharray: ctx.isIndeterminate ? void 0 : `var(--circumference)`,
        transformOrigin: "center",
        transform: "rotate(-90deg)"
      }
    }
  };
}
function midValue(min3, max3) {
  return min3 + (max3 - min3) / 2;
}
function machine19(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "progress",
      initial: "idle",
      context: {
        max: ctx.max ?? 100,
        min: ctx.min ?? 0,
        value: midValue(ctx.min ?? 0, ctx.max ?? 100),
        orientation: "horizontal",
        translations: {
          value: ({ percent }) => percent === -1 ? "loading..." : `${percent} percent`,
          ...ctx.translations
        },
        ...ctx
      },
      created: ["validateContext"],
      computed: {
        isIndeterminate: (ctx2) => ctx2.value === null,
        percent(ctx2) {
          if (!isNumber(ctx2.value))
            return -1;
          return Math.round((ctx2.value - ctx2.min) / (ctx2.max - ctx2.min) * 100);
        },
        isAtMax: (ctx2) => ctx2.value === ctx2.max,
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isRtl: (ctx2) => ctx2.dir === "rtl"
      },
      states: {
        idle: {
          on: {
            "VALUE.SET": {
              actions: ["setValue"]
            }
          }
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, evt) => {
          ctx2.value = evt.value === null ? null : Math.max(0, Math.min(evt.value, ctx2.max));
        },
        validateContext: (ctx2) => {
          if (ctx2.value == null)
            return;
          if (!isValidNumber(ctx2.max)) {
            throw new Error(`[progress] The max value passed \`${ctx2.max}\` is not a valid number`);
          }
          if (!isValidMax(ctx2.value, ctx2.max)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the max value \`${ctx2.max}\``);
          }
          if (!isValidMin(ctx2.value, ctx2.min)) {
            throw new Error(`[progress] The value passed \`${ctx2.value}\` exceeds the min value \`${ctx2.min}\``);
          }
        }
      }
    }
  );
}
function isValidNumber(max3) {
  return isNumber(max3) && !isNaN(max3);
}
function isValidMax(value, max3) {
  return isValidNumber(value) && value <= max3;
}
function isValidMin(value, min3) {
  return isValidNumber(value) && value >= min3;
}
var props15 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "max",
  "min",
  "orientation",
  "translations",
  "value"
]);
var splitProps15 = createSplitProps(props15);

// node_modules/proxy-memoize/dist/memoize.js
var targetCache2 = /* @__PURE__ */ new WeakMap();
var HAS_KEY_PROPERTY2 = "h";
var ALL_OWN_KEYS_PROPERTY2 = "w";
var HAS_OWN_KEY_PROPERTY2 = "o";
var KEYS_PROPERTY2 = "k";
var trackMemoOriginalObjSet = /* @__PURE__ */ new WeakSet();
var isObject5 = (x) => typeof x === "object" && x !== null;
var untrack = (x, seen) => {
  if (!isObject5(x))
    return x;
  const originalObj = getUntracked(x);
  if (originalObj !== null) {
    trackMemo(x);
    trackMemoOriginalObjSet.add(originalObj);
    return originalObj;
  }
  if (!seen.has(x)) {
    seen.add(x);
    Object.entries(x).forEach(([k, v]) => {
      const vv = untrack(v, seen);
      if (!Object.is(vv, v))
        x[k] = vv;
    });
  }
  return x;
};
var touchAffected = (dst, src, affected) => {
  var _a, _b, _c;
  if (!isObject5(dst) || !isObject5(src))
    return;
  if (trackMemoOriginalObjSet.has(getUntracked(src))) {
    trackMemo(dst);
    return;
  }
  const used = affected.get(getUntracked(src) || src);
  if (!used)
    return;
  (_a = used[HAS_KEY_PROPERTY2]) === null || _a === void 0 ? void 0 : _a.forEach((key) => {
    Reflect.has(dst, key);
  });
  if (used[ALL_OWN_KEYS_PROPERTY2] === true) {
    Reflect.ownKeys(dst);
  }
  (_b = used[HAS_OWN_KEY_PROPERTY2]) === null || _b === void 0 ? void 0 : _b.forEach((key) => {
    Reflect.getOwnPropertyDescriptor(dst, key);
  });
  (_c = used[KEYS_PROPERTY2]) === null || _c === void 0 ? void 0 : _c.forEach((key) => {
    touchAffected(dst[key], src[key], affected);
  });
};
var isOriginalEqual = (x, y) => {
  for (let xx = x; xx; x = xx, xx = getUntracked(xx))
    ;
  for (let yy = y; yy; y = yy, yy = getUntracked(yy))
    ;
  return Object.is(x, y);
};
var OBJ_PROPERTY = "o";
var RESULT_PROPERTY = "r";
var AFFECTED_PROPERTY2 = "a";
function memoize(fn, options) {
  var _a;
  let memoListHead = 0;
  const size3 = (_a = options === null || options === void 0 ? void 0 : options.size) !== null && _a !== void 0 ? _a : 1;
  const memoList = [];
  const resultCache = (options === null || options === void 0 ? void 0 : options.noWeakMap) ? null : /* @__PURE__ */ new WeakMap();
  const memoizedFn = (obj) => {
    const cache = resultCache === null || resultCache === void 0 ? void 0 : resultCache.get(obj);
    if (cache) {
      return cache;
    }
    for (let i = 0; i < size3; i += 1) {
      const memo2 = memoList[(memoListHead + i) % size3];
      if (!memo2)
        break;
      const { [OBJ_PROPERTY]: memoObj, [AFFECTED_PROPERTY2]: memoAffected, [RESULT_PROPERTY]: memoResult } = memo2;
      if (!isChanged(memoObj, obj, memoAffected, /* @__PURE__ */ new WeakMap(), isOriginalEqual)) {
        touchAffected(obj, memoObj, memoAffected);
        resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, memoResult);
        return memoResult;
      }
    }
    const affected = /* @__PURE__ */ new WeakMap();
    const proxy2 = createProxy(obj, affected, void 0, targetCache2);
    const result = untrack(fn(proxy2), /* @__PURE__ */ new WeakSet());
    touchAffected(obj, obj, affected);
    const entry = {
      [OBJ_PROPERTY]: obj,
      [RESULT_PROPERTY]: result,
      [AFFECTED_PROPERTY2]: affected
    };
    memoListHead = (memoListHead - 1 + size3) % size3;
    memoList[memoListHead] = entry;
    resultCache === null || resultCache === void 0 ? void 0 : resultCache.set(obj, result);
    return result;
  };
  return memoizedFn;
}

// node_modules/uqr/dist/index.mjs
var QrCodeDataType = ((QrCodeDataType2) => {
  QrCodeDataType2[QrCodeDataType2["Border"] = -1] = "Border";
  QrCodeDataType2[QrCodeDataType2["Data"] = 0] = "Data";
  QrCodeDataType2[QrCodeDataType2["Function"] = 1] = "Function";
  QrCodeDataType2[QrCodeDataType2["Position"] = 2] = "Position";
  QrCodeDataType2[QrCodeDataType2["Timing"] = 3] = "Timing";
  QrCodeDataType2[QrCodeDataType2["Alignment"] = 4] = "Alignment";
  return QrCodeDataType2;
})(QrCodeDataType || {});
var __defProp4 = Object.defineProperty;
var __defNormalProp4 = (obj, key, value) => key in obj ? __defProp4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField4 = (obj, key, value) => {
  __defNormalProp4(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var LOW = [0, 1];
var MEDIUM = [1, 0];
var QUARTILE = [2, 3];
var HIGH = [3, 2];
var EccMap = {
  L: LOW,
  M: MEDIUM,
  Q: QUARTILE,
  H: HIGH
};
var NUMERIC_REGEX = /^[0-9]*$/;
var ALPHANUMERIC_REGEX = /^[A-Z0-9 $%*+.\/:-]*$/;
var ALPHANUMERIC_CHARSET = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ $%*+-./:";
var MIN_VERSION = 1;
var MAX_VERSION = 40;
var PENALTY_N1 = 3;
var PENALTY_N2 = 3;
var PENALTY_N3 = 40;
var PENALTY_N4 = 10;
var ECC_CODEWORDS_PER_BLOCK = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 7, 10, 15, 20, 26, 18, 20, 24, 30, 18, 20, 24, 26, 30, 22, 24, 28, 30, 28, 28, 28, 28, 30, 30, 26, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Low
  [-1, 10, 16, 26, 18, 24, 16, 18, 22, 22, 26, 30, 22, 22, 24, 24, 28, 28, 26, 26, 26, 26, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28],
  // Medium
  [-1, 13, 22, 18, 26, 18, 24, 18, 22, 20, 24, 28, 26, 24, 20, 30, 24, 28, 28, 26, 30, 28, 30, 30, 30, 30, 28, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30],
  // Quartile
  [-1, 17, 28, 22, 16, 22, 28, 26, 26, 24, 28, 24, 28, 22, 24, 24, 30, 28, 28, 26, 28, 30, 24, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30, 30]
  // High
];
var NUM_ERROR_CORRECTION_BLOCKS = [
  // Version: (note that index 0 is for padding, and is set to an illegal value)
  // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40    Error correction level
  [-1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 4, 4, 4, 4, 4, 6, 6, 6, 6, 7, 8, 8, 9, 9, 10, 12, 12, 12, 13, 14, 15, 16, 17, 18, 19, 19, 20, 21, 22, 24, 25],
  // Low
  [-1, 1, 1, 1, 2, 2, 4, 4, 4, 5, 5, 5, 8, 9, 9, 10, 10, 11, 13, 14, 16, 17, 17, 18, 20, 21, 23, 25, 26, 28, 29, 31, 33, 35, 37, 38, 40, 43, 45, 47, 49],
  // Medium
  [-1, 1, 1, 2, 2, 4, 4, 6, 6, 8, 8, 8, 10, 12, 16, 12, 17, 16, 18, 21, 20, 23, 23, 25, 27, 29, 34, 34, 35, 38, 40, 43, 45, 48, 51, 53, 56, 59, 62, 65, 68],
  // Quartile
  [-1, 1, 1, 2, 4, 4, 4, 5, 6, 8, 8, 11, 11, 16, 16, 18, 16, 19, 21, 25, 25, 25, 34, 30, 32, 35, 37, 40, 42, 45, 48, 51, 54, 57, 60, 63, 66, 70, 74, 77, 81]
  // High
];
var QrCode = class {
  /* -- Constructor (low level) and fields -- */
  // Creates a new QR Code with the given version number,
  // error correction level, data codeword bytes, and mask number.
  // This is a low-level API that most users should not use directly.
  // A mid-level API is the encodeSegments() function.
  constructor(version, ecc, dataCodewords, msk) {
    this.version = version;
    this.ecc = ecc;
    __publicField4(this, "size");
    __publicField4(this, "mask");
    __publicField4(this, "modules", []);
    __publicField4(this, "types", []);
    if (version < MIN_VERSION || version > MAX_VERSION)
      throw new RangeError("Version value out of range");
    if (msk < -1 || msk > 7)
      throw new RangeError("Mask value out of range");
    this.size = version * 4 + 17;
    const row = Array.from({ length: this.size }, () => false);
    for (let i = 0; i < this.size; i++) {
      this.modules.push(row.slice());
      this.types.push(row.map(() => 0));
    }
    this.drawFunctionPatterns();
    const allCodewords = this.addEccAndInterleave(dataCodewords);
    this.drawCodewords(allCodewords);
    if (msk === -1) {
      let minPenalty = 1e9;
      for (let i = 0; i < 8; i++) {
        this.applyMask(i);
        this.drawFormatBits(i);
        const penalty = this.getPenaltyScore();
        if (penalty < minPenalty) {
          msk = i;
          minPenalty = penalty;
        }
        this.applyMask(i);
      }
    }
    this.mask = msk;
    this.applyMask(msk);
    this.drawFormatBits(msk);
  }
  /* -- Accessor methods -- */
  // Returns the color of the module (pixel) at the given coordinates, which is false
  // for light or true for dark. The top left corner has the coordinates (x=0, y=0).
  // If the given coordinates are out of bounds, then false (light) is returned.
  getModule(x, y) {
    return x >= 0 && x < this.size && y >= 0 && y < this.size && this.modules[y][x];
  }
  /* -- Private helper methods for constructor: Drawing function modules -- */
  // Reads this object's version field, and draws and marks all function modules.
  drawFunctionPatterns() {
    for (let i = 0; i < this.size; i++) {
      this.setFunctionModule(6, i, i % 2 === 0, QrCodeDataType.Timing);
      this.setFunctionModule(i, 6, i % 2 === 0, QrCodeDataType.Timing);
    }
    this.drawFinderPattern(3, 3);
    this.drawFinderPattern(this.size - 4, 3);
    this.drawFinderPattern(3, this.size - 4);
    const alignPatPos = this.getAlignmentPatternPositions();
    const numAlign = alignPatPos.length;
    for (let i = 0; i < numAlign; i++) {
      for (let j = 0; j < numAlign; j++) {
        if (!(i === 0 && j === 0 || i === 0 && j === numAlign - 1 || i === numAlign - 1 && j === 0))
          this.drawAlignmentPattern(alignPatPos[i], alignPatPos[j]);
      }
    }
    this.drawFormatBits(0);
    this.drawVersion();
  }
  // Draws two copies of the format bits (with its own error correction code)
  // based on the given mask and this object's error correction level field.
  drawFormatBits(mask) {
    const data = this.ecc[1] << 3 | mask;
    let rem = data;
    for (let i = 0; i < 10; i++)
      rem = rem << 1 ^ (rem >>> 9) * 1335;
    const bits = (data << 10 | rem) ^ 21522;
    for (let i = 0; i <= 5; i++)
      this.setFunctionModule(8, i, getBit(bits, i));
    this.setFunctionModule(8, 7, getBit(bits, 6));
    this.setFunctionModule(8, 8, getBit(bits, 7));
    this.setFunctionModule(7, 8, getBit(bits, 8));
    for (let i = 9; i < 15; i++)
      this.setFunctionModule(14 - i, 8, getBit(bits, i));
    for (let i = 0; i < 8; i++)
      this.setFunctionModule(this.size - 1 - i, 8, getBit(bits, i));
    for (let i = 8; i < 15; i++)
      this.setFunctionModule(8, this.size - 15 + i, getBit(bits, i));
    this.setFunctionModule(8, this.size - 8, true);
  }
  // Draws two copies of the version bits (with its own error correction code),
  // based on this object's version field, iff 7 <= version <= 40.
  drawVersion() {
    if (this.version < 7)
      return;
    let rem = this.version;
    for (let i = 0; i < 12; i++)
      rem = rem << 1 ^ (rem >>> 11) * 7973;
    const bits = this.version << 12 | rem;
    for (let i = 0; i < 18; i++) {
      const color = getBit(bits, i);
      const a2 = this.size - 11 + i % 3;
      const b2 = Math.floor(i / 3);
      this.setFunctionModule(a2, b2, color);
      this.setFunctionModule(b2, a2, color);
    }
  }
  // Draws a 9*9 finder pattern including the border separator,
  // with the center module at (x, y). Modules can be out of bounds.
  drawFinderPattern(x, y) {
    for (let dy = -4; dy <= 4; dy++) {
      for (let dx = -4; dx <= 4; dx++) {
        const dist = Math.max(Math.abs(dx), Math.abs(dy));
        const xx = x + dx;
        const yy = y + dy;
        if (xx >= 0 && xx < this.size && yy >= 0 && yy < this.size)
          this.setFunctionModule(xx, yy, dist !== 2 && dist !== 4, QrCodeDataType.Position);
      }
    }
  }
  // Draws a 5*5 alignment pattern, with the center module
  // at (x, y). All modules must be in bounds.
  drawAlignmentPattern(x, y) {
    for (let dy = -2; dy <= 2; dy++) {
      for (let dx = -2; dx <= 2; dx++) {
        this.setFunctionModule(
          x + dx,
          y + dy,
          Math.max(Math.abs(dx), Math.abs(dy)) !== 1,
          QrCodeDataType.Alignment
        );
      }
    }
  }
  // Sets the color of a module and marks it as a function module.
  // Only used by the constructor. Coordinates must be in bounds.
  setFunctionModule(x, y, isDark, type = QrCodeDataType.Function) {
    this.modules[y][x] = isDark;
    this.types[y][x] = type;
  }
  /* -- Private helper methods for constructor: Codewords and masking -- */
  // Returns a new byte string representing the given data with the appropriate error correction
  // codewords appended to it, based on this object's version and error correction level.
  addEccAndInterleave(data) {
    const ver = this.version;
    const ecl = this.ecc;
    if (data.length !== getNumDataCodewords(ver, ecl))
      throw new RangeError("Invalid argument");
    const numBlocks = NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
    const blockEccLen = ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver];
    const rawCodewords = Math.floor(getNumRawDataModules(ver) / 8);
    const numShortBlocks = numBlocks - rawCodewords % numBlocks;
    const shortBlockLen = Math.floor(rawCodewords / numBlocks);
    const blocks = [];
    const rsDiv = reedSolomonComputeDivisor(blockEccLen);
    for (let i = 0, k = 0; i < numBlocks; i++) {
      const dat = data.slice(k, k + shortBlockLen - blockEccLen + (i < numShortBlocks ? 0 : 1));
      k += dat.length;
      const ecc = reedSolomonComputeRemainder(dat, rsDiv);
      if (i < numShortBlocks)
        dat.push(0);
      blocks.push(dat.concat(ecc));
    }
    const result = [];
    for (let i = 0; i < blocks[0].length; i++) {
      blocks.forEach((block, j) => {
        if (i !== shortBlockLen - blockEccLen || j >= numShortBlocks)
          result.push(block[i]);
      });
    }
    return result;
  }
  // Draws the given sequence of 8-bit codewords (data and error correction) onto the entire
  // data area of this QR Code. Function modules need to be marked off before this is called.
  drawCodewords(data) {
    if (data.length !== Math.floor(getNumRawDataModules(this.version) / 8))
      throw new RangeError("Invalid argument");
    let i = 0;
    for (let right = this.size - 1; right >= 1; right -= 2) {
      if (right === 6)
        right = 5;
      for (let vert = 0; vert < this.size; vert++) {
        for (let j = 0; j < 2; j++) {
          const x = right - j;
          const upward = (right + 1 & 2) === 0;
          const y = upward ? this.size - 1 - vert : vert;
          if (!this.types[y][x] && i < data.length * 8) {
            this.modules[y][x] = getBit(data[i >>> 3], 7 - (i & 7));
            i++;
          }
        }
      }
    }
  }
  // XORs the codeword modules in this QR Code with the given mask pattern.
  // The function modules must be marked and the codeword bits must be drawn
  // before masking. Due to the arithmetic of XOR, calling applyMask() with
  // the same mask value a second time will undo the mask. A final well-formed
  // QR Code needs exactly one (not zero, two, etc.) mask applied.
  applyMask(mask) {
    if (mask < 0 || mask > 7)
      throw new RangeError("Mask value out of range");
    for (let y = 0; y < this.size; y++) {
      for (let x = 0; x < this.size; x++) {
        let invert;
        switch (mask) {
          case 0:
            invert = (x + y) % 2 === 0;
            break;
          case 1:
            invert = y % 2 === 0;
            break;
          case 2:
            invert = x % 3 === 0;
            break;
          case 3:
            invert = (x + y) % 3 === 0;
            break;
          case 4:
            invert = (Math.floor(x / 3) + Math.floor(y / 2)) % 2 === 0;
            break;
          case 5:
            invert = x * y % 2 + x * y % 3 === 0;
            break;
          case 6:
            invert = (x * y % 2 + x * y % 3) % 2 === 0;
            break;
          case 7:
            invert = ((x + y) % 2 + x * y % 3) % 2 === 0;
            break;
          default:
            throw new Error("Unreachable");
        }
        if (!this.types[y][x] && invert)
          this.modules[y][x] = !this.modules[y][x];
      }
    }
  }
  // Calculates and returns the penalty score based on state of this QR Code's current modules.
  // This is used by the automatic mask choice algorithm to find the mask pattern that yields the lowest score.
  getPenaltyScore() {
    let result = 0;
    for (let y = 0; y < this.size; y++) {
      let runColor = false;
      let runX = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let x = 0; x < this.size; x++) {
        if (this.modules[y][x] === runColor) {
          runX++;
          if (runX === 5)
            result += PENALTY_N1;
          else if (runX > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runX, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runX = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runX, runHistory) * PENALTY_N3;
    }
    for (let x = 0; x < this.size; x++) {
      let runColor = false;
      let runY = 0;
      const runHistory = [0, 0, 0, 0, 0, 0, 0];
      for (let y = 0; y < this.size; y++) {
        if (this.modules[y][x] === runColor) {
          runY++;
          if (runY === 5)
            result += PENALTY_N1;
          else if (runY > 5)
            result++;
        } else {
          this.finderPenaltyAddHistory(runY, runHistory);
          if (!runColor)
            result += this.finderPenaltyCountPatterns(runHistory) * PENALTY_N3;
          runColor = this.modules[y][x];
          runY = 1;
        }
      }
      result += this.finderPenaltyTerminateAndCount(runColor, runY, runHistory) * PENALTY_N3;
    }
    for (let y = 0; y < this.size - 1; y++) {
      for (let x = 0; x < this.size - 1; x++) {
        const color = this.modules[y][x];
        if (color === this.modules[y][x + 1] && color === this.modules[y + 1][x] && color === this.modules[y + 1][x + 1])
          result += PENALTY_N2;
      }
    }
    let dark = 0;
    for (const row of this.modules)
      dark = row.reduce((sum, color) => sum + (color ? 1 : 0), dark);
    const total = this.size * this.size;
    const k = Math.ceil(Math.abs(dark * 20 - total * 10) / total) - 1;
    result += k * PENALTY_N4;
    return result;
  }
  /* -- Private helper functions -- */
  // Returns an ascending list of positions of alignment patterns for this version number.
  // Each position is in the range [0,177), and are used on both the x and y axes.
  // This could be implemented as lookup table of 40 variable-length lists of integers.
  getAlignmentPatternPositions() {
    if (this.version === 1) {
      return [];
    } else {
      const numAlign = Math.floor(this.version / 7) + 2;
      const step = this.version === 32 ? 26 : Math.ceil((this.version * 4 + 4) / (numAlign * 2 - 2)) * 2;
      const result = [6];
      for (let pos = this.size - 7; result.length < numAlign; pos -= step)
        result.splice(1, 0, pos);
      return result;
    }
  }
  // Can only be called immediately after a light run is added, and
  // returns either 0, 1, or 2. A helper function for getPenaltyScore().
  finderPenaltyCountPatterns(runHistory) {
    const n = runHistory[1];
    const core = n > 0 && runHistory[2] === n && runHistory[3] === n * 3 && runHistory[4] === n && runHistory[5] === n;
    return (core && runHistory[0] >= n * 4 && runHistory[6] >= n ? 1 : 0) + (core && runHistory[6] >= n * 4 && runHistory[0] >= n ? 1 : 0);
  }
  // Must be called at the end of a line (row or column) of modules. A helper function for getPenaltyScore().
  finderPenaltyTerminateAndCount(currentRunColor, currentRunLength, runHistory) {
    if (currentRunColor) {
      this.finderPenaltyAddHistory(currentRunLength, runHistory);
      currentRunLength = 0;
    }
    currentRunLength += this.size;
    this.finderPenaltyAddHistory(currentRunLength, runHistory);
    return this.finderPenaltyCountPatterns(runHistory);
  }
  // Pushes the given value to the front and drops the last value. A helper function for getPenaltyScore().
  finderPenaltyAddHistory(currentRunLength, runHistory) {
    if (runHistory[0] === 0)
      currentRunLength += this.size;
    runHistory.pop();
    runHistory.unshift(currentRunLength);
  }
};
function appendBits(val, len, bb) {
  if (len < 0 || len > 31 || val >>> len !== 0)
    throw new RangeError("Value out of range");
  for (let i = len - 1; i >= 0; i--)
    bb.push(val >>> i & 1);
}
function getBit(x, i) {
  return (x >>> i & 1) !== 0;
}
var QrSegment = class {
  // Creates a new QR Code segment with the given attributes and data.
  // The character count (numChars) must agree with the mode and the bit buffer length,
  // but the constraint isn't checked. The given bit buffer is cloned and stored.
  constructor(mode, numChars, bitData) {
    this.mode = mode;
    this.numChars = numChars;
    this.bitData = bitData;
    if (numChars < 0)
      throw new RangeError("Invalid argument");
    this.bitData = bitData.slice();
  }
  /* -- Methods -- */
  // Returns a new copy of the data bits of this segment.
  getData() {
    return this.bitData.slice();
  }
};
var MODE_NUMERIC = [1, 10, 12, 14];
var MODE_ALPHANUMERIC = [2, 9, 11, 13];
var MODE_BYTE = [4, 8, 16, 16];
function numCharCountBits(mode, ver) {
  return mode[Math.floor((ver + 7) / 17) + 1];
}
function makeBytes(data) {
  const bb = [];
  for (const b2 of data)
    appendBits(b2, 8, bb);
  return new QrSegment(MODE_BYTE, data.length, bb);
}
function makeNumeric(digits) {
  if (!isNumeric(digits))
    throw new RangeError("String contains non-numeric characters");
  const bb = [];
  for (let i = 0; i < digits.length; ) {
    const n = Math.min(digits.length - i, 3);
    appendBits(Number.parseInt(digits.substring(i, i + n), 10), n * 3 + 1, bb);
    i += n;
  }
  return new QrSegment(MODE_NUMERIC, digits.length, bb);
}
function makeAlphanumeric(text) {
  if (!isAlphanumeric(text))
    throw new RangeError("String contains unencodable characters in alphanumeric mode");
  const bb = [];
  let i;
  for (i = 0; i + 2 <= text.length; i += 2) {
    let temp = ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)) * 45;
    temp += ALPHANUMERIC_CHARSET.indexOf(text.charAt(i + 1));
    appendBits(temp, 11, bb);
  }
  if (i < text.length)
    appendBits(ALPHANUMERIC_CHARSET.indexOf(text.charAt(i)), 6, bb);
  return new QrSegment(MODE_ALPHANUMERIC, text.length, bb);
}
function makeSegments(text) {
  if (text === "")
    return [];
  else if (isNumeric(text))
    return [makeNumeric(text)];
  else if (isAlphanumeric(text))
    return [makeAlphanumeric(text)];
  else
    return [makeBytes(toUtf8ByteArray(text))];
}
function isNumeric(text) {
  return NUMERIC_REGEX.test(text);
}
function isAlphanumeric(text) {
  return ALPHANUMERIC_REGEX.test(text);
}
function getTotalBits(segs, version) {
  let result = 0;
  for (const seg of segs) {
    const ccbits = numCharCountBits(seg.mode, version);
    if (seg.numChars >= 1 << ccbits)
      return Number.POSITIVE_INFINITY;
    result += 4 + ccbits + seg.bitData.length;
  }
  return result;
}
function toUtf8ByteArray(str) {
  str = encodeURI(str);
  const result = [];
  for (let i = 0; i < str.length; i++) {
    if (str.charAt(i) !== "%") {
      result.push(str.charCodeAt(i));
    } else {
      result.push(Number.parseInt(str.substring(i + 1, i + 3), 16));
      i += 2;
    }
  }
  return result;
}
function getNumRawDataModules(ver) {
  if (ver < MIN_VERSION || ver > MAX_VERSION)
    throw new RangeError("Version number out of range");
  let result = (16 * ver + 128) * ver + 64;
  if (ver >= 2) {
    const numAlign = Math.floor(ver / 7) + 2;
    result -= (25 * numAlign - 10) * numAlign - 55;
    if (ver >= 7)
      result -= 36;
  }
  return result;
}
function getNumDataCodewords(ver, ecl) {
  return Math.floor(getNumRawDataModules(ver) / 8) - ECC_CODEWORDS_PER_BLOCK[ecl[0]][ver] * NUM_ERROR_CORRECTION_BLOCKS[ecl[0]][ver];
}
function reedSolomonComputeDivisor(degree) {
  if (degree < 1 || degree > 255)
    throw new RangeError("Degree out of range");
  const result = [];
  for (let i = 0; i < degree - 1; i++)
    result.push(0);
  result.push(1);
  let root = 1;
  for (let i = 0; i < degree; i++) {
    for (let j = 0; j < result.length; j++) {
      result[j] = reedSolomonMultiply(result[j], root);
      if (j + 1 < result.length)
        result[j] ^= result[j + 1];
    }
    root = reedSolomonMultiply(root, 2);
  }
  return result;
}
function reedSolomonComputeRemainder(data, divisor) {
  const result = divisor.map((_) => 0);
  for (const b2 of data) {
    const factor = b2 ^ result.shift();
    result.push(0);
    divisor.forEach((coef, i) => result[i] ^= reedSolomonMultiply(coef, factor));
  }
  return result;
}
function reedSolomonMultiply(x, y) {
  if (x >>> 8 !== 0 || y >>> 8 !== 0)
    throw new RangeError("Byte out of range");
  let z = 0;
  for (let i = 7; i >= 0; i--) {
    z = z << 1 ^ (z >>> 7) * 285;
    z ^= (y >>> i & 1) * x;
  }
  return z;
}
function encodeSegments(segs, ecl, minVersion = 1, maxVersion = 40, mask = -1, boostEcl = true) {
  if (!(MIN_VERSION <= minVersion && minVersion <= maxVersion && maxVersion <= MAX_VERSION) || mask < -1 || mask > 7)
    throw new RangeError("Invalid value");
  let version;
  let dataUsedBits;
  for (version = minVersion; ; version++) {
    const dataCapacityBits2 = getNumDataCodewords(version, ecl) * 8;
    const usedBits = getTotalBits(segs, version);
    if (usedBits <= dataCapacityBits2) {
      dataUsedBits = usedBits;
      break;
    }
    if (version >= maxVersion)
      throw new RangeError("Data too long");
  }
  for (const newEcl of [MEDIUM, QUARTILE, HIGH]) {
    if (boostEcl && dataUsedBits <= getNumDataCodewords(version, newEcl) * 8)
      ecl = newEcl;
  }
  const bb = [];
  for (const seg of segs) {
    appendBits(seg.mode[0], 4, bb);
    appendBits(seg.numChars, numCharCountBits(seg.mode, version), bb);
    for (const b2 of seg.getData())
      bb.push(b2);
  }
  const dataCapacityBits = getNumDataCodewords(version, ecl) * 8;
  appendBits(0, Math.min(4, dataCapacityBits - bb.length), bb);
  appendBits(0, (8 - bb.length % 8) % 8, bb);
  for (let padByte = 236; bb.length < dataCapacityBits; padByte ^= 236 ^ 17)
    appendBits(padByte, 8, bb);
  const dataCodewords = Array.from({ length: Math.ceil(bb.length / 8) }, () => 0);
  bb.forEach((b2, i) => dataCodewords[i >>> 3] |= b2 << 7 - (i & 7));
  return new QrCode(version, ecl, dataCodewords, mask);
}
function encode(data, options) {
  var _a;
  const {
    ecc = "L",
    boostEcc = false,
    minVersion = 1,
    maxVersion = 40,
    maskPattern = -1,
    border = 1
  } = options || {};
  const segment = typeof data === "string" ? makeSegments(data) : Array.isArray(data) ? [makeBytes(data)] : void 0;
  if (!segment)
    throw new Error(`uqr only supports encoding string and binary data, but got: ${typeof data}`);
  const qr = encodeSegments(
    segment,
    EccMap[ecc],
    minVersion,
    maxVersion,
    maskPattern,
    boostEcc
  );
  const result = addBorder({
    version: qr.version,
    maskPattern: qr.mask,
    size: qr.size,
    data: qr.modules,
    types: qr.types
  }, border);
  if (options == null ? void 0 : options.invert)
    result.data = result.data.map((row) => row.map((mod2) => !mod2));
  (_a = options == null ? void 0 : options.onEncoded) == null ? void 0 : _a.call(options, result);
  return result;
}
function addBorder(input, border = 1) {
  if (!border)
    return input;
  const { size: size3 } = input;
  const newSize = size3 + border * 2;
  input.size = newSize;
  input.data.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(false);
      row.push(false);
    }
  });
  for (let i = 0; i < border; i++) {
    input.data.unshift(Array.from({ length: newSize }, (_) => false));
    input.data.push(Array.from({ length: newSize }, (_) => false));
  }
  const b2 = QrCodeDataType.Border;
  input.types.forEach((row) => {
    for (let i = 0; i < border; i++) {
      row.unshift(b2);
      row.push(b2);
    }
  });
  for (let i = 0; i < border; i++) {
    input.types.unshift(Array.from({ length: newSize }, (_) => b2));
    input.types.push(Array.from({ length: newSize }, (_) => b2));
  }
  return input;
}

// node_modules/@zag-js/qr-code/dist/index.mjs
var anatomy24 = createAnatomy("qr-code").parts("root", "frame", "pattern", "overlay");
var parts20 = anatomy24.build();
var dom20 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `qrcode:${ctx.id}:root`;
  },
  getFrameId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.frame) ?? `qrcode:${ctx.id}:frame`;
  },
  getFrameEl: (ctx) => dom20.getById(ctx, dom20.getFrameId(ctx))
});
function connect20(state2, send, normalize) {
  const encoded = state2.context.encoded;
  const pixelSize = state2.context.pixelSize;
  const height = encoded.size * pixelSize;
  const width = encoded.size * pixelSize;
  const paths = [];
  for (let row = 0; row < encoded.size; row++) {
    for (let col = 0; col < encoded.size; col++) {
      const x = col * pixelSize;
      const y = row * pixelSize;
      if (encoded.data[row][col]) {
        paths.push(`M${x},${y}h${pixelSize}v${pixelSize}h-${pixelSize}z`);
      }
    }
  }
  return {
    value: state2.context.value,
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    getDataUrl(type, quality) {
      const svgEl = dom20.getFrameEl(state2.context);
      return getDataUrl(svgEl, { type, quality });
    },
    getRootProps() {
      return normalize.element({
        id: dom20.getRootId(state2.context),
        ...parts20.root.attrs,
        style: {
          "--qrcode-pixel-size": `${pixelSize}px`,
          "--qrcode-width": `${width}px`,
          "--qrcode-height": `${height}px`,
          position: "relative"
        }
      });
    },
    getFrameProps() {
      return normalize.svg({
        id: dom20.getFrameId(state2.context),
        ...parts20.frame.attrs,
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: `0 0 ${width} ${height}`
      });
    },
    getPatternProps() {
      return normalize.path({
        d: paths.join(""),
        ...parts20.pattern.attrs
      });
    },
    getOverlayProps() {
      return normalize.element({
        ...parts20.overlay.attrs,
        style: {
          position: "absolute",
          top: "50%",
          left: "50%",
          translate: "-50% -50%"
        }
      });
    }
  };
}
function machine20(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "qr-code",
      initial: "idle",
      context: {
        value: "",
        ...ctx,
        pixelSize: 10
      },
      computed: {
        encoded: memoize((ctx2) => encode(ctx2.value, ctx2.encoding))
      },
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        }
      }
    },
    {
      actions: {
        setValue: (ctx2, e) => {
          ctx2.value = e.value;
        }
      }
    }
  );
}
var props16 = createProps()(["ids", "value", "id", "encoding", "dir", "getRootNode"]);
var splitProps16 = createSplitProps(props16);

// node_modules/@zag-js/element-rect/dist/index.mjs
var rafId;
var observedElements = /* @__PURE__ */ new Map();
var getRectFn = (el) => el.getBoundingClientRect();
function trackElementRect(el, options) {
  const { scope = "rect", getRect = getRectFn, onChange } = options;
  const loop = getLoopFn({ scope, getRect });
  const data = observedElements.get(el);
  if (!data) {
    observedElements.set(el, {
      rect: {},
      callbacks: [onChange]
    });
    if (observedElements.size === 1) {
      rafId = requestAnimationFrame(loop);
    }
  } else {
    data.callbacks.push(onChange);
    onChange(getRect(el));
  }
  return function unobserve() {
    const data2 = observedElements.get(el);
    if (!data2)
      return;
    const index = data2.callbacks.indexOf(onChange);
    if (index > -1) {
      data2.callbacks.splice(index, 1);
    }
    if (data2.callbacks.length === 0) {
      observedElements.delete(el);
      if (observedElements.size === 0) {
        cancelAnimationFrame(rafId);
      }
    }
  };
}
function getLoopFn(options) {
  const { scope, getRect } = options;
  const isEqual3 = getEqualityFn(scope);
  return function loop() {
    const changedRectsData = [];
    observedElements.forEach((data, element) => {
      const newRect = getRect(element);
      if (!isEqual3(data.rect, newRect)) {
        data.rect = newRect;
        changedRectsData.push(data);
      }
    });
    changedRectsData.forEach((data) => {
      data.callbacks.forEach((callback) => callback(data.rect));
    });
    rafId = requestAnimationFrame(loop);
  };
}
var isEqualSize = (a2, b2) => a2.width === b2.width && a2.height === b2.height;
var isEqualPosition = (a2, b2) => a2.top === b2.top && a2.left === b2.left;
var isEqualRect = (a2, b2) => isEqualSize(a2, b2) && isEqualPosition(a2, b2);
function getEqualityFn(scope) {
  if (scope === "size")
    return isEqualSize;
  if (scope === "position")
    return isEqualPosition;
  return isEqualRect;
}

// node_modules/@zag-js/radio-group/dist/index.mjs
var anatomy25 = createAnatomy("radio-group").parts(
  "root",
  "label",
  "item",
  "itemText",
  "itemControl",
  "indicator"
);
var parts21 = anatomy25.build();
var dom21 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `radio-group:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `radio-group:${ctx.id}:label`;
  },
  getItemId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, value)) ?? `radio-group:${ctx.id}:radio:${value}`;
  },
  getItemHiddenInputId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemHiddenInput) == null ? void 0 : _b.call(_a, value)) ?? `radio-group:${ctx.id}:radio:input:${value}`;
  },
  getItemControlId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemControl) == null ? void 0 : _b.call(_a, value)) ?? `radio-group:${ctx.id}:radio:control:${value}`;
  },
  getItemLabelId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemLabel) == null ? void 0 : _b.call(_a, value)) ?? `radio-group:${ctx.id}:radio:label:${value}`;
  },
  getIndicatorId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.indicator) ?? `radio-group:${ctx.id}:indicator`;
  },
  getRootEl: (ctx) => dom21.getById(ctx, dom21.getRootId(ctx)),
  getItemHiddenInputEl: (ctx, value) => dom21.getById(ctx, dom21.getItemHiddenInputId(ctx, value)),
  getIndicatorEl: (ctx) => dom21.getById(ctx, dom21.getIndicatorId(ctx)),
  getFirstEnabledInputEl: (ctx) => {
    var _a;
    return (_a = dom21.getRootEl(ctx)) == null ? void 0 : _a.querySelector("input:not(:disabled)");
  },
  getFirstEnabledAndCheckedInputEl: (ctx) => {
    var _a;
    return (_a = dom21.getRootEl(ctx)) == null ? void 0 : _a.querySelector("input:not(:disabled):checked");
  },
  getInputEls: (ctx) => {
    const ownerId = CSS.escape(dom21.getRootId(ctx));
    const selector = `input[type=radio][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom21.getRootEl(ctx), selector);
  },
  getActiveRadioEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom21.getById(ctx, dom21.getItemId(ctx, ctx.value));
  },
  getOffsetRect: (el) => ({
    left: (el == null ? void 0 : el.offsetLeft) ?? 0,
    top: (el == null ? void 0 : el.offsetTop) ?? 0,
    width: (el == null ? void 0 : el.offsetWidth) ?? 0,
    height: (el == null ? void 0 : el.offsetHeight) ?? 0
  }),
  getRectById: (ctx, id) => {
    const radioEl = dom21.getById(ctx, dom21.getItemId(ctx, id));
    if (!radioEl)
      return;
    return dom21.resolveRect(dom21.getOffsetRect(radioEl));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect21(state2, send, normalize) {
  const groupDisabled = state2.context.isDisabled;
  const readOnly = state2.context.readOnly;
  function getItemState(props29) {
    return {
      invalid: !!props29.invalid,
      disabled: !!props29.disabled || groupDisabled,
      checked: state2.context.value === props29.value,
      focused: state2.context.focusedValue === props29.value,
      hovered: state2.context.hoveredValue === props29.value,
      active: state2.context.activeValue === props29.value
    };
  }
  function getItemDataAttrs(props29) {
    const radioState = getItemState(props29);
    return {
      "data-focus": dataAttr(radioState.focused),
      "data-disabled": dataAttr(radioState.disabled),
      "dats-readonly": dataAttr(readOnly),
      "data-state": radioState.checked ? "checked" : "unchecked",
      "data-hover": dataAttr(radioState.hovered),
      "data-invalid": dataAttr(radioState.invalid),
      "data-orientation": state2.context.orientation,
      "data-ssr": dataAttr(state2.context.ssr)
    };
  }
  const focus = () => {
    const firstEnabledAndCheckedInput = dom21.getFirstEnabledAndCheckedInputEl(state2.context);
    if (firstEnabledAndCheckedInput) {
      firstEnabledAndCheckedInput.focus();
      return;
    }
    const firstEnabledInput = dom21.getFirstEnabledInputEl(state2.context);
    firstEnabledInput == null ? void 0 : firstEnabledInput.focus();
  };
  return {
    focus,
    value: state2.context.value,
    setValue(value) {
      send({ type: "SET_VALUE", value, isTrusted: false });
    },
    clearValue() {
      send({ type: "SET_VALUE", value: null, isTrusted: false });
    },
    getRootProps() {
      return normalize.element({
        ...parts21.root.attrs,
        role: "radiogroup",
        id: dom21.getRootId(state2.context),
        "aria-labelledby": dom21.getLabelId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        "aria-orientation": state2.context.orientation,
        dir: state2.context.dir,
        style: {
          position: "relative"
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts21.label.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(groupDisabled),
        id: dom21.getLabelId(state2.context),
        onClick: focus
      });
    },
    getItemState,
    getItemProps(props29) {
      const itemState = getItemState(props29);
      return normalize.label({
        ...parts21.item.attrs,
        dir: state2.context.dir,
        id: dom21.getItemId(state2.context, props29.value),
        htmlFor: dom21.getItemHiddenInputId(state2.context, props29.value),
        ...getItemDataAttrs(props29),
        onPointerMove() {
          if (itemState.disabled)
            return;
          if (itemState.hovered)
            return;
          send({ type: "SET_HOVERED", value: props29.value, hovered: true });
        },
        onPointerLeave() {
          if (itemState.disabled)
            return;
          send({ type: "SET_HOVERED", value: null });
        },
        onPointerDown(event) {
          if (itemState.disabled)
            return;
          if (itemState.focused && event.pointerType === "mouse") {
            event.preventDefault();
          }
          send({ type: "SET_ACTIVE", value: props29.value, active: true });
        },
        onPointerUp() {
          if (itemState.disabled)
            return;
          send({ type: "SET_ACTIVE", value: null });
        }
      });
    },
    getItemTextProps(props29) {
      return normalize.element({
        ...parts21.itemText.attrs,
        dir: state2.context.dir,
        id: dom21.getItemLabelId(state2.context, props29.value),
        ...getItemDataAttrs(props29)
      });
    },
    getItemControlProps(props29) {
      const controlState = getItemState(props29);
      return normalize.element({
        ...parts21.itemControl.attrs,
        dir: state2.context.dir,
        id: dom21.getItemControlId(state2.context, props29.value),
        "data-active": dataAttr(controlState.active),
        "aria-hidden": true,
        ...getItemDataAttrs(props29)
      });
    },
    getItemHiddenInputProps(props29) {
      const inputState = getItemState(props29);
      return normalize.input({
        "data-ownedby": dom21.getRootId(state2.context),
        id: dom21.getItemHiddenInputId(state2.context, props29.value),
        type: "radio",
        name: state2.context.name || state2.context.id,
        form: state2.context.form,
        value: props29.value,
        onChange(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          if (event.target.checked) {
            send({ type: "SET_VALUE", value: props29.value, isTrusted: true });
          }
        },
        onBlur() {
          send({ type: "SET_FOCUSED", value: null });
        },
        onFocus() {
          send({ type: "SET_FOCUSED", value: props29.value, focused: true });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: props29.value, active: true });
          }
        },
        onKeyUp(event) {
          if (event.defaultPrevented)
            return;
          if (event.key === " ") {
            send({ type: "SET_ACTIVE", value: null });
          }
        },
        disabled: inputState.disabled,
        defaultChecked: inputState.checked,
        style: visuallyHiddenStyle
      });
    },
    getIndicatorProps() {
      var _a, _b, _c, _d;
      return normalize.element({
        id: dom21.getIndicatorId(state2.context),
        ...parts21.indicator.attrs,
        dir: state2.context.dir,
        hidden: state2.context.value == null,
        "data-disabled": dataAttr(groupDisabled),
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, top, width, height",
          "--left": (_a = state2.context.indicatorRect) == null ? void 0 : _a.left,
          "--top": (_b = state2.context.indicatorRect) == null ? void 0 : _b.top,
          "--width": (_c = state2.context.indicatorRect) == null ? void 0 : _c.width,
          "--height": (_d = state2.context.indicatorRect) == null ? void 0 : _d.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: state2.context.canIndicatorTransition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [state2.context.orientation === "horizontal" ? "left" : "top"]: state2.context.orientation === "horizontal" ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not9 } = guards;
function machine21(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "radio",
      initial: "idle",
      context: {
        value: null,
        activeValue: null,
        focusedValue: null,
        hoveredValue: null,
        disabled: false,
        orientation: "vertical",
        ...ctx,
        indicatorRect: {},
        canIndicatorTransition: false,
        fieldsetDisabled: false,
        ssr: true
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled
      },
      entry: ["syncIndicatorRect", "syncSsr"],
      exit: ["cleanupObserver"],
      activities: ["trackFormControlState"],
      watch: {
        value: ["setIndicatorTransition", "syncIndicatorRect", "syncInputElements"]
      },
      on: {
        SET_VALUE: [
          {
            guard: not9("isTrusted"),
            actions: ["setValue", "dispatchChangeEvent"]
          },
          {
            actions: ["setValue"]
          }
        ],
        SET_HOVERED: {
          actions: "setHovered"
        },
        SET_ACTIVE: {
          actions: "setActive"
        },
        SET_FOCUSED: {
          actions: "setFocused"
        }
      },
      states: {
        idle: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom21.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value });
            }
          });
        }
      },
      actions: {
        setValue(ctx2, evt) {
          set15.value(ctx2, evt.value);
        },
        setHovered(ctx2, evt) {
          ctx2.hoveredValue = evt.value;
        },
        setActive(ctx2, evt) {
          ctx2.activeValue = evt.value;
        },
        setFocused(ctx2, evt) {
          ctx2.focusedValue = evt.value;
        },
        syncInputElements(ctx2) {
          const inputs = dom21.getInputEls(ctx2);
          inputs.forEach((input) => {
            input.checked = input.value === ctx2.value;
          });
        },
        setIndicatorTransition(ctx2) {
          ctx2.canIndicatorTransition = isString(ctx2.value);
        },
        cleanupObserver(ctx2) {
          var _a;
          (_a = ctx2.indicatorCleanup) == null ? void 0 : _a.call(ctx2);
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a;
          (_a = ctx2.indicatorCleanup) == null ? void 0 : _a.call(ctx2);
          if (!dom21.getIndicatorEl(ctx2))
            return;
          const value = ctx2.value;
          const radioEl = dom21.getActiveRadioEl(ctx2);
          if (value == null || !radioEl) {
            ctx2.indicatorRect = {};
            return;
          }
          ctx2.indicatorCleanup = trackElementRect(radioEl, {
            getRect(el) {
              return dom21.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorRect = dom21.resolveRect(rect);
              nextTick(() => {
                ctx2.canIndicatorTransition = false;
              });
            }
          });
        },
        dispatchChangeEvent(ctx2) {
          const inputEls = dom21.getInputEls(ctx2);
          inputEls.forEach((inputEl) => {
            const checked = inputEl.value === ctx2.value;
            if (checked === inputEl.checked)
              return;
            dispatchInputCheckedEvent(inputEl, { checked });
          });
        }
      }
    }
  );
}
var invoke11 = {
  change: (ctx) => {
    var _a;
    if (ctx.value == null)
      return;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: ctx.value });
  }
};
var set15 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke11.change(ctx);
  }
};
var props17 = createProps()([
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onValueChange",
  "orientation",
  "readOnly",
  "value"
]);
var splitProps17 = createSplitProps(props17);
var itemProps5 = createProps()(["value", "disabled", "invalid"]);
var splitItemProps5 = createSplitProps(itemProps5);

// node_modules/@zag-js/rating-group/dist/index.mjs
var anatomy26 = createAnatomy("rating-group").parts("root", "label", "item", "control");
var parts22 = anatomy26.build();
var dom22 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `rating:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `rating:${ctx.id}:label`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `rating:${ctx.id}:input`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `rating:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.rating) == null ? void 0 : _b.call(_a, id)) ?? `rating:${ctx.id}:star:${id}`;
  },
  getRootEl: (ctx) => dom22.getById(ctx, dom22.getRootId(ctx)),
  getControlEl: (ctx) => dom22.getById(ctx, dom22.getControlId(ctx)),
  getRadioEl: (ctx) => {
    var _a;
    return (_a = dom22.getControlEl(ctx)) == null ? void 0 : _a.querySelector(`[role=radio][aria-posinset='${Math.ceil(ctx.value)}']`);
  },
  getActiveEl: (ctx) => dom22.getRootNode(ctx).activeElement,
  getHiddenInputEl: (ctx) => dom22.getById(ctx, dom22.getHiddenInputId(ctx)),
  dispatchChangeEvent: (ctx) => {
    const inputEl = dom22.getHiddenInputEl(ctx);
    if (!inputEl)
      return;
    dispatchInputValueEvent(inputEl, { value: ctx.value });
  }
});
function connect22(state2, send, normalize) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.isDisabled;
  const value = state2.context.value;
  const hoveredValue = state2.context.hoveredValue;
  const translations = state2.context.translations;
  function getItemState(props29) {
    const value2 = state2.context.isHovering ? state2.context.hoveredValue : state2.context.value;
    const equal = Math.ceil(value2) === props29.index;
    const highlighted = props29.index <= value2 || equal;
    const half = equal && Math.abs(value2 - props29.index) === 0.5;
    return {
      highlighted,
      half,
      checked: equal || state2.context.value === -1 && props29.index === 1
    };
  }
  return {
    hovering: state2.context.isHovering,
    value,
    hoveredValue,
    count: state2.context.count,
    items: Array.from({ length: state2.context.count }).map((_, index) => index + 1),
    setValue(value2) {
      send({ type: "SET_VALUE", value: value2 });
    },
    clearValue() {
      send("CLEAR_VALUE");
    },
    getRootProps() {
      return normalize.element({
        dir: state2.context.dir,
        ...parts22.root.attrs,
        id: dom22.getRootId(state2.context)
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        name: state2.context.name,
        form: state2.context.form,
        type: "text",
        hidden: true,
        id: dom22.getHiddenInputId(state2.context),
        defaultValue: state2.context.value
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts22.label.attrs,
        dir: state2.context.dir,
        id: dom22.getLabelId(state2.context),
        "data-disabled": dataAttr(disabled)
      });
    },
    getControlProps() {
      return normalize.element({
        id: dom22.getControlId(state2.context),
        ...parts22.control.attrs,
        dir: state2.context.dir,
        role: "radiogroup",
        "aria-orientation": "horizontal",
        "aria-labelledby": dom22.getLabelId(state2.context),
        "aria-readonly": ariaAttr(state2.context.readOnly),
        "data-readonly": dataAttr(state2.context.readOnly),
        tabIndex: state2.context.readOnly ? 0 : -1,
        "data-disabled": dataAttr(disabled),
        onPointerMove(event) {
          if (!interactive || event.pointerType === "touch")
            return;
          send("GROUP_POINTER_OVER");
        },
        onPointerLeave(event) {
          if (!interactive || event.pointerType === "touch")
            return;
          send("GROUP_POINTER_LEAVE");
        }
      });
    },
    getItemState,
    getItemProps(props29) {
      const { index } = props29;
      const itemState = getItemState(props29);
      const valueText = translations.ratingValueText(index);
      return normalize.element({
        ...parts22.item.attrs,
        dir: state2.context.dir,
        id: dom22.getItemId(state2.context, index.toString()),
        role: "radio",
        tabIndex: disabled ? void 0 : itemState.checked ? 0 : -1,
        "aria-roledescription": "rating",
        "aria-label": valueText,
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(state2.context.readOnly),
        "aria-setsize": state2.context.count,
        "aria-checked": itemState.checked,
        "data-checked": dataAttr(itemState.checked),
        "aria-posinset": index,
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-half": dataAttr(itemState.half),
        onPointerDown(event) {
          if (!interactive)
            return;
          if (isLeftClick(event)) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!interactive)
            return;
          const point = getEventPoint(event);
          const relativePoint = getRelativePoint(point, event.currentTarget);
          const percentX = relativePoint.getPercentValue({
            orientation: "horizontal",
            dir: state2.context.dir
          });
          const isMidway = percentX < 0.5;
          send({ type: "POINTER_OVER", index, isMidway });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          const keyMap2 = {
            ArrowLeft() {
              send("ARROW_LEFT");
            },
            ArrowRight() {
              send("ARROW_RIGHT");
            },
            ArrowUp() {
              send("ARROW_LEFT");
            },
            ArrowDown() {
              send("ARROW_RIGHT");
            },
            Space() {
              send({ type: "SPACE", value: index });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        },
        onClick() {
          if (!interactive)
            return;
          send({ type: "CLICK", value: index });
        },
        onFocus() {
          if (!interactive)
            return;
          send("FOCUS");
        },
        onBlur() {
          if (!interactive)
            return;
          send("BLUR");
        }
      });
    }
  };
}
function machine22(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "rating",
      initial: "idle",
      context: {
        name: "rating",
        count: 5,
        dir: "ltr",
        value: -1,
        readOnly: false,
        disabled: false,
        ...ctx,
        hoveredValue: -1,
        fieldsetDisabled: false,
        translations: {
          ratingValueText: (index) => `${index} stars`,
          ...ctx.translations
        }
      },
      created: ["roundValueIfNeeded"],
      watch: {
        allowHalf: ["roundValueIfNeeded"]
      },
      computed: {
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly),
        isHovering: (ctx2) => ctx2.hoveredValue > -1
      },
      activities: ["trackFormControlState"],
      on: {
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_VALUE: {
          actions: ["clearValue"]
        }
      },
      states: {
        idle: {
          entry: "clearHoveredValue",
          on: {
            GROUP_POINTER_OVER: "hover",
            FOCUS: "focus",
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        },
        focus: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: {
              actions: "clearHoveredValue"
            },
            BLUR: "idle",
            SPACE: {
              guard: "isValueEmpty",
              actions: ["setValue"]
            },
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            },
            ARROW_LEFT: {
              actions: ["setPrevValue", "focusActiveRadio"]
            },
            ARROW_RIGHT: {
              actions: ["setNextValue", "focusActiveRadio"]
            },
            HOME: {
              actions: ["setValueToMin", "focusActiveRadio"]
            },
            END: {
              actions: ["setValueToMax", "focusActiveRadio"]
            }
          }
        },
        hover: {
          on: {
            POINTER_OVER: {
              actions: "setHoveredValue"
            },
            GROUP_POINTER_LEAVE: [
              {
                guard: "isRadioFocused",
                target: "focus",
                actions: "clearHoveredValue"
              },
              {
                target: "idle",
                actions: "clearHoveredValue"
              }
            ],
            CLICK: {
              actions: ["setValue", "focusActiveRadio"]
            }
          }
        }
      }
    },
    {
      guards: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isHoveredValueEmpty: (ctx2) => ctx2.hoveredValue === -1,
        isValueEmpty: (ctx2) => ctx2.value <= 0,
        isRadioFocused: (ctx2) => {
          var _a;
          return !!((_a = dom22.getControlEl(ctx2)) == null ? void 0 : _a.contains(dom22.getActiveEl(ctx2)));
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom22.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set16.value(ctx2, initialContext.value);
            }
          });
        }
      },
      actions: {
        clearHoveredValue(ctx2) {
          set16.hoveredValue(ctx2, -1);
        },
        focusActiveRadio(ctx2) {
          raf(() => {
            var _a;
            return (_a = dom22.getRadioEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        setPrevValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          set16.value(ctx2, Math.max(0, ctx2.value - factor));
        },
        setNextValue(ctx2) {
          const factor = ctx2.allowHalf ? 0.5 : 1;
          const value = ctx2.value === -1 ? 0 : ctx2.value;
          set16.value(ctx2, Math.min(ctx2.count, value + factor));
        },
        setValueToMin(ctx2) {
          set16.value(ctx2, 1);
        },
        setValueToMax(ctx2) {
          set16.value(ctx2, ctx2.count);
        },
        setValue(ctx2, evt) {
          const value = ctx2.hoveredValue === -1 ? evt.value : ctx2.hoveredValue;
          set16.value(ctx2, value);
        },
        clearValue(ctx2) {
          set16.value(ctx2, -1);
        },
        setHoveredValue(ctx2, evt) {
          const half = ctx2.allowHalf && evt.isMidway;
          const factor = half ? 0.5 : 0;
          set16.hoveredValue(ctx2, evt.index - factor);
        },
        roundValueIfNeeded(ctx2) {
          if (ctx2.allowHalf)
            return;
          ctx2.value = Math.round(ctx2.value);
        }
      }
    }
  );
}
var invoke12 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: ctx.value });
    dom22.dispatchChangeEvent(ctx);
  },
  hoverChange: (ctx) => {
    var _a;
    (_a = ctx.onHoverChange) == null ? void 0 : _a.call(ctx, { hoveredValue: ctx.hoveredValue });
  }
};
var set16 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke12.change(ctx);
  },
  hoveredValue: (ctx, value) => {
    if (isEqual(ctx.hoveredValue, value))
      return;
    ctx.hoveredValue = value;
    invoke12.hoverChange(ctx);
  }
};
var props18 = createProps()([
  "allowHalf",
  "autoFocus",
  "count",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "name",
  "onHoverChange",
  "onValueChange",
  "readOnly",
  "translations",
  "value"
]);
var splitProps18 = createSplitProps(props18);
var itemProps6 = createProps()(["index"]);
var splitItemProps6 = createSplitProps(itemProps6);

// node_modules/@ark-ui/anatomy/dist/segment-group/index.js
var anatomy27 = anatomy25.rename("segment-group");

// node_modules/@zag-js/select/dist/index.mjs
var anatomy28 = createAnatomy("select").parts(
  "label",
  "positioner",
  "trigger",
  "indicator",
  "clearTrigger",
  "item",
  "itemText",
  "itemIndicator",
  "itemGroup",
  "itemGroupLabel",
  "list",
  "content",
  "root",
  "control"
);
var parts23 = anatomy28.build();
var collection2 = (options) => {
  return ref(new Collection(options));
};
collection2.empty = () => {
  return ref(new Collection({ items: [] }));
};
var dom23 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `select:${ctx.id}`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `select:${ctx.id}:content`;
  },
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `select:${ctx.id}:trigger`;
  },
  getClearTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.clearTrigger) ?? `select:${ctx.id}:clear-trigger`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `select:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `select:${ctx.id}:control`;
  },
  getItemId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, id)) ?? `select:${ctx.id}:option:${id}`;
  },
  getHiddenSelectId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenSelect) ?? `select:${ctx.id}:select`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `select:${ctx.id}:positioner`;
  },
  getItemGroupId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemGroup) == null ? void 0 : _b.call(_a, id)) ?? `select:${ctx.id}:optgroup:${id}`;
  },
  getItemGroupLabelId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemGroupLabel) == null ? void 0 : _b.call(_a, id)) ?? `select:${ctx.id}:optgroup-label:${id}`;
  },
  getHiddenSelectEl: (ctx) => dom23.getById(ctx, dom23.getHiddenSelectId(ctx)),
  getContentEl: (ctx) => dom23.getById(ctx, dom23.getContentId(ctx)),
  getControlEl: (ctx) => dom23.getById(ctx, dom23.getControlId(ctx)),
  getTriggerEl: (ctx) => dom23.getById(ctx, dom23.getTriggerId(ctx)),
  getClearTriggerEl: (ctx) => dom23.getById(ctx, dom23.getClearTriggerId(ctx)),
  getPositionerEl: (ctx) => dom23.getById(ctx, dom23.getPositionerId(ctx)),
  getHighlightedOptionEl(ctx) {
    if (!ctx.highlightedValue)
      return null;
    return dom23.getById(ctx, dom23.getItemId(ctx, ctx.highlightedValue));
  }
});
function connect23(state2, send, normalize) {
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const readOnly = state2.context.readOnly;
  const interactive = state2.context.isInteractive;
  const composite = state2.context.composite;
  const open = state2.hasTag("open");
  const focused = state2.matches("focused");
  const highlightedValue = state2.context.highlightedValue;
  const highlightedItem = state2.context.highlightedItem;
  const selectedItems = state2.context.selectedItems;
  const isTypingAhead = state2.context.isTypingAhead;
  const ariaActiveDescendant = highlightedValue ? dom23.getItemId(state2.context, highlightedValue) : void 0;
  function getItemState(props29) {
    const _disabled = state2.context.collection.isItemDisabled(props29.item);
    const value = state2.context.collection.itemToValue(props29.item);
    return {
      value,
      disabled: Boolean(disabled || _disabled),
      highlighted: highlightedValue === value,
      selected: state2.context.value.includes(value)
    };
  }
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    focused,
    empty: state2.context.value.length === 0,
    highlightedItem,
    highlightedValue,
    selectedItems,
    hasSelectedItems: state2.context.hasSelectedItems,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    collection: state2.context.collection,
    setCollection(collection22) {
      send({ type: "COLLECTION.SET", value: collection22 });
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    focus() {
      var _a;
      (_a = dom23.getTriggerEl(state2.context)) == null ? void 0 : _a.focus({ preventScroll: true });
    },
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    selectValue(value) {
      send({ type: "ITEM.SELECT", value });
    },
    setValue(value) {
      send({ type: "VALUE.SET", value });
    },
    highlightValue(value) {
      send({ type: "HIGHLIGHTED_VALUE.SET", value });
    },
    clearValue(value) {
      if (value) {
        send({ type: "ITEM.CLEAR", value });
      } else {
        send({ type: "VALUE.CLEAR" });
      }
    },
    getItemState,
    getRootProps() {
      return normalize.element({
        ...parts23.root.attrs,
        dir: state2.context.dir,
        id: dom23.getRootId(state2.context),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getLabelProps() {
      return normalize.label({
        dir: state2.context.dir,
        id: dom23.getLabelId(state2.context),
        ...parts23.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        htmlFor: dom23.getHiddenSelectId(state2.context),
        onClick(event) {
          var _a;
          if (event.defaultPrevented)
            return;
          if (disabled)
            return;
          (_a = dom23.getTriggerEl(state2.context)) == null ? void 0 : _a.focus({ preventScroll: true });
        }
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts23.control.attrs,
        dir: state2.context.dir,
        id: dom23.getControlId(state2.context),
        "data-state": open ? "open" : "closed",
        "data-focus": dataAttr(focused),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid)
      });
    },
    getTriggerProps() {
      return normalize.button({
        id: dom23.getTriggerId(state2.context),
        disabled,
        dir: state2.context.dir,
        type: "button",
        role: "combobox",
        "aria-controls": dom23.getContentId(state2.context),
        "aria-expanded": open,
        "aria-haspopup": "listbox",
        "data-state": open ? "open" : "closed",
        "aria-invalid": invalid,
        "aria-labelledby": dom23.getLabelId(state2.context),
        ...parts23.trigger.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-placement": state2.context.currentPlacement,
        "data-placeholder-shown": dataAttr(!state2.context.hasSelectedItems),
        onPointerDown(event) {
          if (!isLeftClick(event))
            return;
          if (!interactive)
            return;
          event.currentTarget.dataset.pointerType = event.pointerType;
          if (disabled || event.pointerType === "touch")
            return;
          send({ type: "TRIGGER.CLICK" });
        },
        onClick(event) {
          if (!interactive || event.button)
            return;
          if (event.currentTarget.dataset.pointerType === "touch") {
            send({ type: "TRIGGER.CLICK" });
          }
        },
        onFocus() {
          send("TRIGGER.FOCUS");
        },
        onBlur() {
          send("TRIGGER.BLUR");
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          const keyMap2 = {
            ArrowUp() {
              send({ type: "TRIGGER.ARROW_UP" });
            },
            ArrowDown(event2) {
              send({ type: event2.altKey ? "OPEN" : "TRIGGER.ARROW_DOWN" });
            },
            ArrowLeft() {
              send({ type: "TRIGGER.ARROW_LEFT" });
            },
            ArrowRight() {
              send({ type: "TRIGGER.ARROW_RIGHT" });
            },
            Home() {
              send({ type: "TRIGGER.HOME" });
            },
            End() {
              send({ type: "TRIGGER.END" });
            },
            Enter() {
              send({ type: "TRIGGER.ENTER" });
            },
            Space(event2) {
              if (isTypingAhead) {
                send({ type: "TRIGGER.TYPEAHEAD", key: event2.key });
              } else {
                send({ type: "TRIGGER.ENTER" });
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event, state2.context)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "TRIGGER.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getIndicatorProps() {
      return normalize.element({
        ...parts23.indicator.attrs,
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-state": open ? "open" : "closed",
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly)
      });
    },
    getItemProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        id: dom23.getItemId(state2.context, itemState.value),
        role: "option",
        ...parts23.item.attrs,
        dir: state2.context.dir,
        "data-value": itemState.value,
        "aria-selected": itemState.selected,
        "data-state": itemState.selected ? "checked" : "unchecked",
        "data-highlighted": dataAttr(itemState.highlighted),
        "data-disabled": dataAttr(itemState.disabled),
        "aria-disabled": ariaAttr(itemState.disabled),
        onPointerMove(event) {
          if (itemState.disabled || event.pointerType !== "mouse")
            return;
          if (itemState.value === state2.context.highlightedValue)
            return;
          send({ type: "ITEM.POINTER_MOVE", value: itemState.value });
        },
        onPointerUp() {
          if (itemState.disabled)
            return;
          send({ type: "ITEM.CLICK", src: "pointerup", value: itemState.value });
        },
        onPointerLeave(event) {
          if (itemState.disabled)
            return;
          if (props29.persistFocus)
            return;
          if (event.pointerType !== "mouse")
            return;
          const isArrowKey = ["CONTENT.ARROW_UP", "CONTENT.ARROW_DOWN"].includes(state2.event.type);
          if (isArrowKey)
            return;
          send({ type: "ITEM.POINTER_LEAVE" });
        },
        onTouchEnd(event) {
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getItemTextProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts23.itemText.attrs,
        "data-disabled": dataAttr(itemState.disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemIndicatorProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        "aria-hidden": true,
        ...parts23.itemIndicator.attrs,
        "data-state": itemState.selected ? "checked" : "unchecked",
        hidden: !itemState.selected
      });
    },
    getItemGroupLabelProps(props29) {
      const { htmlFor } = props29;
      return normalize.element({
        ...parts23.itemGroupLabel.attrs,
        id: dom23.getItemGroupLabelId(state2.context, htmlFor),
        role: "group",
        dir: state2.context.dir
      });
    },
    getItemGroupProps(props29) {
      const { id } = props29;
      return normalize.element({
        ...parts23.itemGroup.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom23.getItemGroupId(state2.context, id),
        "aria-labelledby": dom23.getItemGroupLabelId(state2.context, id),
        dir: state2.context.dir
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts23.clearTrigger.attrs,
        id: dom23.getClearTriggerId(state2.context),
        type: "button",
        "aria-label": "Clear value",
        disabled,
        hidden: !state2.context.hasSelectedItems,
        dir: state2.context.dir,
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("VALUE.CLEAR");
        }
      });
    },
    getHiddenSelectProps() {
      return normalize.select({
        name: state2.context.name,
        form: state2.context.form,
        disabled,
        multiple: state2.context.multiple,
        "aria-hidden": true,
        id: dom23.getHiddenSelectId(state2.context),
        defaultValue: state2.context.multiple ? state2.context.value : state2.context.value[0],
        style: visuallyHiddenStyle,
        tabIndex: -1,
        // Some browser extensions will focus the hidden select.
        // Let's forward the focus to the trigger.
        onFocus() {
          var _a;
          (_a = dom23.getTriggerEl(state2.context)) == null ? void 0 : _a.focus({ preventScroll: true });
        },
        "aria-labelledby": dom23.getLabelId(state2.context)
      });
    },
    getPositionerProps() {
      return normalize.element({
        ...parts23.positioner.attrs,
        dir: state2.context.dir,
        id: dom23.getPositionerId(state2.context),
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        hidden: !open,
        dir: state2.context.dir,
        id: dom23.getContentId(state2.context),
        role: composite ? "listbox" : "dialog",
        ...parts23.content.attrs,
        "data-state": open ? "open" : "closed",
        "data-placement": state2.context.currentPlacement,
        "data-activedescendant": ariaActiveDescendant,
        "aria-activedescendant": composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": state2.context.multiple && composite ? true : void 0,
        "aria-labelledby": dom23.getLabelId(state2.context),
        tabIndex: 0,
        onKeyDown(event) {
          if (!interactive)
            return;
          if (!isSelfTarget(event))
            return;
          if (event.key === "Tab") {
            const valid = isValidTabEvent(event);
            if (!valid) {
              event.preventDefault();
              return;
            }
          }
          const keyMap2 = {
            ArrowUp() {
              send({ type: "CONTENT.ARROW_UP" });
            },
            ArrowDown() {
              send({ type: "CONTENT.ARROW_DOWN" });
            },
            Home() {
              send({ type: "CONTENT.HOME" });
            },
            End() {
              send({ type: "CONTENT.END" });
            },
            Enter() {
              send({ type: "ITEM.CLICK", src: "keydown.enter" });
            },
            Space(event2) {
              var _a;
              if (isTypingAhead) {
                send({ type: "CONTENT.TYPEAHEAD", key: event2.key });
              } else {
                (_a = keyMap2.Enter) == null ? void 0 : _a.call(keyMap2, event2);
              }
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            return;
          }
          if (isEditableElement(event.target)) {
            return;
          }
          if (getByTypeahead.isValidEvent(event)) {
            send({ type: "CONTENT.TYPEAHEAD", key: event.key });
            event.preventDefault();
          }
        }
      });
    },
    getListProps() {
      return normalize.element({
        ...parts23.list.attrs,
        tabIndex: 0,
        role: !composite ? "listbox" : void 0,
        "aria-labelledby": dom23.getTriggerId(state2.context),
        "aria-activedescendant": !composite ? ariaActiveDescendant : void 0,
        "aria-multiselectable": !composite && state2.context.multiple ? true : void 0
      });
    }
  };
}
var { and: and9, not: not10, or: or3 } = guards;
function machine23(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "select",
      context: {
        value: [],
        highlightedValue: null,
        loopFocus: false,
        closeOnSelect: true,
        disabled: false,
        readOnly: false,
        composite: true,
        ...ctx,
        highlightedItem: null,
        selectedItems: [],
        valueAsString: "",
        collection: ctx.collection ?? collection2.empty(),
        typeahead: getByTypeahead.defaultOptions,
        fieldsetDisabled: false,
        restoreFocus: true,
        positioning: {
          placement: "bottom-start",
          gutter: 8,
          ...ctx.positioning
        }
      },
      computed: {
        hasSelectedItems: (ctx2) => ctx2.value.length > 0,
        isTypingAhead: (ctx2) => ctx2.typeahead.keysSoFar !== "",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.isDisabled || ctx2.readOnly)
      },
      initial: ctx.open ? "open" : "idle",
      created: ["syncCollection"],
      entry: ["syncSelectElement"],
      watch: {
        open: ["toggleVisibility"],
        value: ["syncSelectedItems", "syncSelectElement"],
        highlightedValue: ["syncHighlightedItem"],
        collection: ["syncCollection"]
      },
      on: {
        "HIGHLIGHTED_VALUE.SET": {
          actions: ["setHighlightedItem"]
        },
        "ITEM.SELECT": {
          actions: ["selectItem"]
        },
        "ITEM.CLEAR": {
          actions: ["clearItem"]
        },
        "VALUE.SET": {
          actions: ["setSelectedItems"]
        },
        "VALUE.CLEAR": {
          actions: ["clearSelectedItems"]
        },
        "COLLECTION.SET": {
          actions: ["setCollection"]
        }
      },
      activities: ["trackFormControlState"],
      states: {
        idle: {
          tags: ["closed"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["highlightFirstSelectedItem"]
              },
              {
                target: "open"
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.FOCUS": {
              target: "focused"
            },
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ]
          }
        },
        focused: {
          tags: ["closed"],
          entry: ["setFinalFocus"],
          on: {
            "CONTROLLED.OPEN": [
              {
                guard: "isTriggerClickEvent",
                target: "open",
                actions: ["highlightFirstSelectedItem"]
              },
              {
                guard: "isTriggerArrowUpEvent",
                target: "open",
                actions: ["highlightComputedLastItem"]
              },
              {
                guard: or3("isTriggerArrowDownEvent", "isTriggerEnterEvent"),
                target: "open",
                actions: ["highlightComputedFirstItem"]
              },
              {
                target: "open"
              }
            ],
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            "TRIGGER.BLUR": {
              target: "idle"
            },
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "highlightFirstSelectedItem"]
              }
            ],
            "TRIGGER.ENTER": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_UP": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "highlightComputedLastItem"]
              }
            ],
            "TRIGGER.ARROW_DOWN": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen", "highlightComputedFirstItem"]
              }
            ],
            "TRIGGER.ARROW_LEFT": [
              {
                guard: and9(not10("multiple"), "hasSelectedItems"),
                actions: ["selectPreviousItem"]
              },
              {
                guard: not10("multiple"),
                actions: ["selectLastItem"]
              }
            ],
            "TRIGGER.ARROW_RIGHT": [
              {
                guard: and9(not10("multiple"), "hasSelectedItems"),
                actions: ["selectNextItem"]
              },
              {
                guard: not10("multiple"),
                actions: ["selectFirstItem"]
              }
            ],
            "TRIGGER.HOME": {
              guard: not10("multiple"),
              actions: ["selectFirstItem"]
            },
            "TRIGGER.END": {
              guard: not10("multiple"),
              actions: ["selectLastItem"]
            },
            "TRIGGER.TYPEAHEAD": {
              guard: not10("multiple"),
              actions: ["selectMatchingItem"]
            }
          }
        },
        open: {
          tags: ["open"],
          entry: ["setInitialFocus"],
          exit: ["scrollContentToTop"],
          activities: ["trackDismissableElement", "computePlacement", "scrollToHighlightedItem"],
          on: {
            "CONTROLLED.CLOSE": [
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["clearHighlightedItem"]
              },
              {
                target: "idle",
                actions: ["clearHighlightedItem"]
              }
            ],
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "TRIGGER.CLICK": [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and9("closeOnSelect", "isOpenControlled"),
                actions: ["selectHighlightedItem", "invokeOnClose"]
              },
              {
                guard: "closeOnSelect",
                target: "focused",
                actions: ["selectHighlightedItem", "invokeOnClose", "clearHighlightedItem"]
              },
              {
                actions: ["selectHighlightedItem"]
              }
            ],
            "CONTENT.INTERACT_OUTSIDE": [
              // == group 1 ==
              {
                guard: and9("shouldRestoreFocus", "isOpenControlled"),
                actions: ["invokeOnClose"]
              },
              {
                guard: "shouldRestoreFocus",
                target: "focused",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              },
              // == group 2 ==
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "idle",
                actions: ["invokeOnClose", "clearHighlightedItem"]
              }
            ],
            "CONTENT.HOME": {
              actions: ["highlightFirstItem"]
            },
            "CONTENT.END": {
              actions: ["highlightLastItem"]
            },
            "CONTENT.ARROW_DOWN": [
              {
                guard: and9("hasHighlightedItem", "loop", "isLastItemHighlighted"),
                actions: ["highlightFirstItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightNextItem"]
              },
              {
                actions: ["highlightFirstItem"]
              }
            ],
            "CONTENT.ARROW_UP": [
              {
                guard: and9("hasHighlightedItem", "loop", "isFirstItemHighlighted"),
                actions: ["highlightLastItem"]
              },
              {
                guard: "hasHighlightedItem",
                actions: ["highlightPreviousItem"]
              },
              {
                actions: ["highlightLastItem"]
              }
            ],
            "CONTENT.TYPEAHEAD": {
              actions: ["highlightMatchingItem"]
            },
            "ITEM.POINTER_MOVE": {
              actions: ["highlightItem"]
            },
            "ITEM.POINTER_LEAVE": {
              actions: ["clearHighlightedItem"]
            },
            "POSITIONING.SET": {
              actions: ["reposition"]
            }
          }
        }
      }
    },
    {
      guards: {
        loop: (ctx2) => !!ctx2.loopFocus,
        multiple: (ctx2) => !!ctx2.multiple,
        hasSelectedItems: (ctx2) => !!ctx2.hasSelectedItems,
        hasHighlightedItem: (ctx2) => ctx2.highlightedValue != null,
        isFirstItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.first(),
        isLastItemHighlighted: (ctx2) => ctx2.highlightedValue === ctx2.collection.last(),
        closeOnSelect: (ctx2, evt) => {
          if (ctx2.multiple)
            return false;
          return !!(evt.closeOnSelect ?? ctx2.closeOnSelect);
        },
        shouldRestoreFocus: (ctx2) => !!ctx2.restoreFocus,
        // guard assertions (for controlled mode)
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"],
        isTriggerClickEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "TRIGGER.CLICK";
        },
        isTriggerEnterEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "TRIGGER.ENTER";
        },
        isTriggerArrowUpEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "TRIGGER.ARROW_UP";
        },
        isTriggerArrowDownEvent: (_ctx, evt) => {
          var _a;
          return ((_a = evt.previousEvent) == null ? void 0 : _a.type) === "TRIGGER.ARROW_DOWN";
        }
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom23.getHiddenSelectEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set17.selectedItems(ctx2, initialContext.value);
            }
          });
        },
        trackDismissableElement(ctx2, _evt, { send }) {
          const contentEl = () => dom23.getContentEl(ctx2);
          return trackDismissableElement(contentEl, {
            defer: true,
            exclude: [dom23.getTriggerEl(ctx2), dom23.getClearTriggerEl(ctx2)],
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              ctx2.restoreFocus = !event.detail.focusable;
            },
            onDismiss() {
              send({ type: "CONTENT.INTERACT_OUTSIDE" });
            }
          });
        },
        computePlacement(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const triggerEl = () => dom23.getTriggerEl(ctx2);
          const positionerEl = () => dom23.getPositionerEl(ctx2);
          return getPlacement(triggerEl, positionerEl, {
            defer: true,
            ...ctx2.positioning,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        scrollToHighlightedItem(ctx2, _evt, { getState }) {
          const exec2 = (immediate) => {
            const state2 = getState();
            if (state2.event.type.includes("POINTER"))
              return;
            const optionEl = dom23.getHighlightedOptionEl(ctx2);
            const contentEl2 = dom23.getContentEl(ctx2);
            if (ctx2.scrollToIndexFn) {
              const highlightedIndex = ctx2.collection.indexOf(ctx2.highlightedValue);
              ctx2.scrollToIndexFn({ index: highlightedIndex, immediate });
              return;
            }
            scrollIntoView(optionEl, { rootEl: contentEl2, block: "nearest" });
          };
          raf(() => exec2(true));
          const contentEl = () => dom23.getContentEl(ctx2);
          return observeAttributes(contentEl, {
            defer: true,
            attributes: ["data-activedescendant"],
            callback() {
              exec2(false);
            }
          });
        }
      },
      actions: {
        reposition(ctx2, evt) {
          const positionerEl = () => dom23.getPositionerEl(ctx2);
          getPlacement(dom23.getTriggerEl(ctx2), positionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        highlightPreviousItem(ctx2) {
          if (ctx2.highlightedValue == null)
            return;
          const value = ctx2.collection.prev(ctx2.highlightedValue);
          set17.highlightedItem(ctx2, value);
        },
        highlightNextItem(ctx2) {
          if (ctx2.highlightedValue == null)
            return;
          const value = ctx2.collection.next(ctx2.highlightedValue);
          set17.highlightedItem(ctx2, value);
        },
        highlightFirstItem(ctx2) {
          const value = ctx2.collection.first();
          set17.highlightedItem(ctx2, value);
        },
        highlightLastItem(ctx2) {
          const value = ctx2.collection.last();
          set17.highlightedItem(ctx2, value);
        },
        setInitialFocus(ctx2) {
          raf(() => {
            const element = getInitialFocus({
              root: dom23.getContentEl(ctx2)
            });
            element == null ? void 0 : element.focus({ preventScroll: true });
          });
        },
        setFinalFocus(ctx2) {
          raf(() => {
            var _a;
            (_a = dom23.getTriggerEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        selectHighlightedItem(ctx2, evt) {
          const value = evt.value ?? ctx2.highlightedValue;
          if (value == null)
            return;
          set17.selectedItem(ctx2, value);
        },
        highlightComputedFirstItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.first();
          set17.highlightedItem(ctx2, value);
        },
        highlightComputedLastItem(ctx2) {
          const value = ctx2.hasSelectedItems ? ctx2.collection.sort(ctx2.value)[0] : ctx2.collection.last();
          set17.highlightedItem(ctx2, value);
        },
        highlightFirstSelectedItem(ctx2) {
          if (!ctx2.hasSelectedItems)
            return;
          const [value] = ctx2.collection.sort(ctx2.value);
          set17.highlightedItem(ctx2, value);
        },
        highlightItem(ctx2, evt) {
          set17.highlightedItem(ctx2, evt.value);
        },
        highlightMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.highlightedValue
          });
          if (value == null)
            return;
          set17.highlightedItem(ctx2, value);
        },
        setHighlightedItem(ctx2, evt) {
          set17.highlightedItem(ctx2, evt.value);
        },
        clearHighlightedItem(ctx2) {
          set17.highlightedItem(ctx2, null, true);
        },
        selectItem(ctx2, evt) {
          set17.selectedItem(ctx2, evt.value);
        },
        clearItem(ctx2, evt) {
          const value = ctx2.value.filter((v) => v !== evt.value);
          set17.selectedItems(ctx2, value);
        },
        setSelectedItems(ctx2, evt) {
          set17.selectedItems(ctx2, evt.value);
        },
        clearSelectedItems(ctx2) {
          set17.selectedItems(ctx2, []);
        },
        selectPreviousItem(ctx2) {
          const value = ctx2.collection.prev(ctx2.value[0]);
          set17.selectedItem(ctx2, value);
        },
        selectNextItem(ctx2) {
          const value = ctx2.collection.next(ctx2.value[0]);
          set17.selectedItem(ctx2, value);
        },
        selectFirstItem(ctx2) {
          const value = ctx2.collection.first();
          set17.selectedItem(ctx2, value);
        },
        selectLastItem(ctx2) {
          const value = ctx2.collection.last();
          set17.selectedItem(ctx2, value);
        },
        selectMatchingItem(ctx2, evt) {
          const value = ctx2.collection.search(evt.key, {
            state: ctx2.typeahead,
            currentValue: ctx2.value[0]
          });
          if (value == null)
            return;
          set17.selectedItem(ctx2, value);
        },
        scrollContentToTop(ctx2) {
          var _a;
          if (ctx2.scrollToIndexFn) {
            ctx2.scrollToIndexFn({ index: 0, immediate: true });
          } else {
            (_a = dom23.getContentEl(ctx2)) == null ? void 0 : _a.scrollTo(0, 0);
          }
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        syncSelectElement(ctx2) {
          const selectEl = dom23.getHiddenSelectEl(ctx2);
          if (!selectEl)
            return;
          if (ctx2.value.length === 0 && !ctx2.multiple) {
            selectEl.selectedIndex = -1;
            return;
          }
          for (const option of selectEl.options) {
            option.selected = ctx2.value.includes(option.value);
          }
        },
        setCollection(ctx2, evt) {
          ctx2.collection = evt.value;
        },
        syncCollection(ctx2) {
          const selectedItems = ctx2.collection.items(ctx2.value);
          const valueAsString = ctx2.collection.itemsToString(selectedItems);
          ctx2.highlightedItem = ctx2.collection.item(ctx2.highlightedValue);
          ctx2.selectedItems = selectedItems;
          ctx2.valueAsString = valueAsString;
        },
        syncSelectedItems(ctx2) {
          sync5.valueChange(ctx2);
        },
        syncHighlightedItem(ctx2) {
          sync5.highlightChange(ctx2);
        }
      }
    }
  );
}
function dispatchChangeEvent(ctx) {
  raf(() => {
    const node = dom23.getHiddenSelectEl(ctx);
    if (!node)
      return;
    const win = dom23.getWin(ctx);
    const changeEvent = new win.Event("change", { bubbles: true, composed: true });
    node.dispatchEvent(changeEvent);
  });
}
var sync5 = {
  valueChange: (ctx) => {
    const prevSelectedItems = ctx.selectedItems;
    ctx.selectedItems = ctx.value.map((v) => {
      const foundItem = prevSelectedItems.find((item) => ctx.collection.itemToValue(item) === v);
      if (foundItem)
        return foundItem;
      return ctx.collection.item(v);
    });
    ctx.valueAsString = ctx.collection.itemsToString(ctx.selectedItems);
  },
  highlightChange: (ctx) => {
    ctx.highlightedItem = ctx.collection.item(ctx.highlightedValue);
  }
};
var invoke13 = {
  valueChange: (ctx) => {
    var _a;
    sync5.valueChange(ctx);
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value: Array.from(ctx.value),
      items: Array.from(ctx.selectedItems)
    });
    dispatchChangeEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a;
    sync5.highlightChange(ctx);
    (_a = ctx.onHighlightChange) == null ? void 0 : _a.call(ctx, {
      highlightedValue: ctx.highlightedValue,
      highlightedItem: ctx.highlightedItem,
      highlightedIndex: ctx.collection.indexOf(ctx.highlightedValue)
    });
  }
};
var set17 = {
  selectedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.value, value))
      return;
    if (value == null && !force)
      return;
    if (value == null && force) {
      ctx.value = [];
      invoke13.valueChange(ctx);
      return;
    }
    ctx.value = ctx.multiple ? addOrRemove(ctx.value, value) : [value];
    invoke13.valueChange(ctx);
  },
  selectedItems: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke13.valueChange(ctx);
  },
  highlightedItem: (ctx, value, force = false) => {
    if (isEqual(ctx.highlightedValue, value))
      return;
    if (value == null && !force)
      return;
    ctx.highlightedValue = value ?? null;
    invoke13.highlightChange(ctx);
  }
};
var props19 = createProps()([
  "closeOnSelect",
  "collection",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "highlightedValue",
  "id",
  "ids",
  "invalid",
  "loopFocus",
  "multiple",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInteractOutside",
  "onOpenChange",
  "onPointerDownOutside",
  "onValueChange",
  "open.controlled",
  "open",
  "composite",
  "positioning",
  "readOnly",
  "scrollToIndexFn",
  "value"
]);
var splitProps19 = createSplitProps(props19);
var itemProps7 = createProps()(["item", "persistFocus"]);
var splitItemProps7 = createSplitProps(itemProps7);
var itemGroupProps2 = createProps()(["id"]);
var splitItemGroupProps2 = createSplitProps(itemGroupProps2);
var itemGroupLabelProps2 = createProps()(["htmlFor"]);
var splitItemGroupLabelProps2 = createSplitProps(itemGroupLabelProps2);

// node_modules/@ark-ui/anatomy/dist/select/index.js
var anatomy29 = anatomy28.extendWith("valueText");

// node_modules/perfect-freehand/dist/esm/index.mjs
function $(e, t, u, x = (h) => h) {
  return e * x(0.5 - t * (0.5 - u));
}
function se(e) {
  return [-e[0], -e[1]];
}
function l(e, t) {
  return [e[0] + t[0], e[1] + t[1]];
}
function a(e, t) {
  return [e[0] - t[0], e[1] - t[1]];
}
function b(e, t) {
  return [e[0] * t, e[1] * t];
}
function he(e, t) {
  return [e[0] / t, e[1] / t];
}
function R(e) {
  return [e[1], -e[0]];
}
function B(e, t) {
  return e[0] * t[0] + e[1] * t[1];
}
function ue(e, t) {
  return e[0] === t[0] && e[1] === t[1];
}
function ge(e) {
  return Math.hypot(e[0], e[1]);
}
function de(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function A(e, t) {
  return de(a(e, t));
}
function G(e) {
  return he(e, ge(e));
}
function ie(e, t) {
  return Math.hypot(e[1] - t[1], e[0] - t[0]);
}
function L(e, t, u) {
  let x = Math.sin(u), h = Math.cos(u), y = e[0] - t[0], n = e[1] - t[1], f = y * h - n * x, d = y * x + n * h;
  return [f + t[0], d + t[1]];
}
function K(e, t, u) {
  return l(e, b(a(t, e), u));
}
function ee(e, t, u) {
  return l(e, b(t, u));
}
var { min: C, PI: xe } = Math;
var pe = 0.275;
var V = xe + 1e-4;
function ce(e, t = {}) {
  let { size: u = 16, smoothing: x = 0.5, thinning: h = 0.5, simulatePressure: y = true, easing: n = (r) => r, start: f = {}, end: d = {}, last: D = false } = t, { cap: S = true, easing: j = (r) => r * (2 - r) } = f, { cap: q = true, easing: c = (r) => --r * r * r + 1 } = d;
  if (e.length === 0 || u <= 0)
    return [];
  let p = e[e.length - 1].runningLength, g = f.taper === false ? 0 : f.taper === true ? Math.max(u, p) : f.taper, T = d.taper === false ? 0 : d.taper === true ? Math.max(u, p) : d.taper, te = Math.pow(u * x, 2), _ = [], M = [], H = e.slice(0, 10).reduce((r, i) => {
    let o = i.pressure;
    if (y) {
      let s = C(1, i.distance / u), W = C(1, 1 - s);
      o = C(1, r + (W - r) * (s * pe));
    }
    return (r + o) / 2;
  }, e[0].pressure), m = $(u, h, e[e.length - 1].pressure, n), U, X = e[0].vector, z = e[0].point, F = z, O = z, E = F, J = false;
  for (let r = 0; r < e.length; r++) {
    let { pressure: i } = e[r], { point: o, vector: s, distance: W, runningLength: I } = e[r];
    if (r < e.length - 1 && p - I < 3)
      continue;
    if (h) {
      if (y) {
        let v = C(1, W / u), Z = C(1, 1 - v);
        i = C(1, H + (Z - H) * (v * pe));
      }
      m = $(u, h, i, n);
    } else
      m = u / 2;
    U === void 0 && (U = m);
    let le = I < g ? j(I / g) : 1, fe = p - I < T ? c((p - I) / T) : 1;
    m = Math.max(0.01, m * Math.min(le, fe));
    let re = (r < e.length - 1 ? e[r + 1] : e[r]).vector, Y = r < e.length - 1 ? B(s, re) : 1, be = B(s, X) < 0 && !J, ne = Y !== null && Y < 0;
    if (be || ne) {
      let v = b(R(X), m);
      for (let Z = 1 / 13, w = 0; w <= 1; w += Z)
        O = L(a(o, v), o, V * w), _.push(O), E = L(l(o, v), o, V * -w), M.push(E);
      z = O, F = E, ne && (J = true);
      continue;
    }
    if (J = false, r === e.length - 1) {
      let v = b(R(s), m);
      _.push(a(o, v)), M.push(l(o, v));
      continue;
    }
    let oe = b(R(K(re, s, Y)), m);
    O = a(o, oe), (r <= 1 || A(z, O) > te) && (_.push(O), z = O), E = l(o, oe), (r <= 1 || A(F, E) > te) && (M.push(E), F = E), H = i, X = s;
  }
  let P = e[0].point.slice(0, 2), k = e.length > 1 ? e[e.length - 1].point.slice(0, 2) : l(e[0].point, [1, 1]), Q = [], N = [];
  if (e.length === 1) {
    if (!(g || T) || D) {
      let r = ee(P, G(R(a(P, k))), -(U || m)), i = [];
      for (let o = 1 / 13, s = o; s <= 1; s += o)
        i.push(L(r, P, V * 2 * s));
      return i;
    }
  } else {
    if (!(g || T && e.length === 1))
      if (S)
        for (let i = 1 / 13, o = i; o <= 1; o += i) {
          let s = L(M[0], P, V * o);
          Q.push(s);
        }
      else {
        let i = a(_[0], M[0]), o = b(i, 0.5), s = b(i, 0.51);
        Q.push(a(P, o), a(P, s), l(P, s), l(P, o));
      }
    let r = R(se(e[e.length - 1].vector));
    if (T || g && e.length === 1)
      N.push(k);
    else if (q) {
      let i = ee(k, r, m);
      for (let o = 1 / 29, s = o; s < 1; s += o)
        N.push(L(i, k, V * 3 * s));
    } else
      N.push(l(k, b(r, m)), l(k, b(r, m * 0.99)), a(k, b(r, m * 0.99)), a(k, b(r, m)));
  }
  return _.concat(N, M.reverse(), Q);
}
function me(e, t = {}) {
  var q;
  let { streamline: u = 0.5, size: x = 16, last: h = false } = t;
  if (e.length === 0)
    return [];
  let y = 0.15 + (1 - u) * 0.85, n = Array.isArray(e[0]) ? e : e.map(({ x: c, y: p, pressure: g = 0.5 }) => [c, p, g]);
  if (n.length === 2) {
    let c = n[1];
    n = n.slice(0, -1);
    for (let p = 1; p < 5; p++)
      n.push(K(n[0], c, p / 4));
  }
  n.length === 1 && (n = [...n, [...l(n[0], [1, 1]), ...n[0].slice(2)]]);
  let f = [{ point: [n[0][0], n[0][1]], pressure: n[0][2] >= 0 ? n[0][2] : 0.25, vector: [1, 1], distance: 0, runningLength: 0 }], d = false, D = 0, S = f[0], j = n.length - 1;
  for (let c = 1; c < n.length; c++) {
    let p = h && c === j ? n[c].slice(0, 2) : K(S.point, n[c], y);
    if (ue(S.point, p))
      continue;
    let g = ie(p, S.point);
    if (D += g, c < j && !d) {
      if (D < x)
        continue;
      d = true;
    }
    S = { point: p, pressure: n[c][2] >= 0 ? n[c][2] : 0.5, vector: G(a(S.point, p)), distance: g, runningLength: D }, f.push(S);
  }
  return f[0].vector = ((q = f[1]) == null ? void 0 : q.vector) || [0, 0], f;
}
function ae(e, t = {}) {
  return ce(me(e, t), t);
}
var _e = ae;

// node_modules/@zag-js/signature-pad/dist/index.mjs
var anatomy30 = createAnatomy("signature-pad").parts(
  "root",
  "control",
  "segment",
  "segmentPath",
  "guide",
  "clearTrigger",
  "label"
);
var parts24 = anatomy30.build();
var dom24 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `signature-${ctx.id}`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `signature-control-${ctx.id}`;
  },
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.hiddenInput) ?? `signature-input-${ctx.id}`;
  },
  getControlEl: (ctx) => dom24.getById(ctx, dom24.getControlId(ctx)),
  getSegmentEl: (ctx) => query(dom24.getControlEl(ctx), "[data-part=segment]"),
  getHiddenInputEl: (ctx) => dom24.getById(ctx, dom24.getHiddenInputId(ctx)),
  getDataUrl: (ctx, options) => {
    if (ctx.isEmpty)
      return Promise.resolve("");
    return getDataUrl(dom24.getSegmentEl(ctx), options);
  }
});
function connect24(state2, send, normalize) {
  const drawing = state2.matches("drawing");
  const empty = state2.context.isEmpty;
  const interactive = state2.context.isInteractive;
  const disabled = !!state2.context.disabled;
  return {
    empty,
    drawing,
    currentPath: state2.context.currentPath,
    paths: state2.context.paths,
    clear() {
      send({ type: "CLEAR" });
    },
    getDataUrl(type, quality) {
      return dom24.getDataUrl(state2.context, { type, quality });
    },
    getLabelProps() {
      return normalize.element({
        ...parts24.label.attrs,
        "data-disabled": dataAttr(disabled),
        htmlFor: dom24.getControlId(state2.context)
      });
    },
    getRootProps() {
      return normalize.element({
        ...parts24.root.attrs,
        "data-disabled": dataAttr(disabled),
        id: dom24.getRootId(state2.context)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts24.control.attrs,
        tabIndex: disabled ? void 0 : 0,
        id: dom24.getControlId(state2.context),
        "aria-label": "Signature Pad",
        "aria-roledescription": "signature pad",
        "aria-disabled": disabled,
        "data-disabled": dataAttr(disabled),
        onPointerDown(event) {
          if (!isLeftClick(event))
            return;
          if (isModifierKey(event))
            return;
          if (!interactive)
            return;
          const target = getEventTarget(event);
          if (target == null ? void 0 : target.closest("[data-part=clear-trigger]"))
            return;
          event.currentTarget.setPointerCapture(event.pointerId);
          const point = { x: event.clientX, y: event.clientY };
          const { offset: offset3 } = getRelativePoint(point, dom24.getControlEl(state2.context));
          send({ type: "POINTER_DOWN", point: offset3, pressure: event.pressure });
        },
        onPointerUp(event) {
          if (!interactive)
            return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        style: {
          position: "relative",
          touchAction: "none",
          userSelect: "none"
        }
      });
    },
    getSegmentProps() {
      return normalize.svg({
        ...parts24.segment.attrs,
        style: {
          position: "absolute",
          top: 0,
          left: 0,
          width: "100%",
          height: "100%",
          pointerEvents: "none",
          fill: state2.context.drawing.fill
        }
      });
    },
    getSegmentPathProps(props29) {
      return normalize.path({
        ...parts24.segmentPath.attrs,
        d: props29.path
      });
    },
    getGuideProps() {
      return normalize.element({
        ...parts24.guide.attrs,
        "data-disabled": dataAttr(disabled)
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts24.clearTrigger.attrs,
        type: "button",
        "aria-label": "Clear Signature",
        hidden: !state2.context.paths.length || drawing,
        disabled,
        onClick() {
          send({ type: "CLEAR" });
        }
      });
    },
    getHiddenInputProps(props29) {
      return normalize.input({
        type: "text",
        hidden: true,
        disabled,
        name: state2.context.name,
        value: props29.value
      });
    }
  };
}
var average = (a2, b2) => (a2 + b2) / 2;
function getSvgPathFromStroke(points, closed = true) {
  const len = points.length;
  if (len < 4) {
    return "";
  }
  let a2 = points[0];
  let b2 = points[1];
  const c = points[2];
  let result = `M${a2[0].toFixed(2)},${a2[1].toFixed(2)} Q${b2[0].toFixed(2)},${b2[1].toFixed(2)} ${average(b2[0], c[0]).toFixed(2)},${average(
    b2[1],
    c[1]
  ).toFixed(2)} T`;
  for (let i = 2, max3 = len - 1; i < max3; i++) {
    a2 = points[i];
    b2 = points[i + 1];
    result += `${average(a2[0], b2[0]).toFixed(2)},${average(a2[1], b2[1]).toFixed(2)} `;
  }
  if (closed) {
    result += "Z";
  }
  return result;
}
function machine24(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "signature-pad",
      initial: "idle",
      context: {
        readOnly: false,
        disabled: false,
        ...ctx,
        paths: [],
        currentPoints: [],
        currentPath: null,
        drawing: {
          size: 2,
          simulatePressure: false,
          thinning: 0.7,
          smoothing: 0.4,
          streamline: 0.6,
          ...ctx.drawing
        }
      },
      computed: {
        isInteractive: (ctx2) => !(ctx2.disabled || ctx2.readOnly),
        isEmpty: (ctx2) => ctx2.paths.length === 0
      },
      on: {
        CLEAR: {
          actions: ["clearPoints", "invokeOnDrawEnd", "focusCanvasEl"]
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "drawing",
              actions: ["addPoint"]
            }
          }
        },
        drawing: {
          activities: ["trackPointerMove"],
          on: {
            POINTER_MOVE: {
              actions: ["addPoint", "invokeOnDraw"]
            },
            POINTER_UP: {
              target: "idle",
              actions: ["endStroke", "invokeOnDrawEnd"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackPointerMove(ctx2, _evt, { send }) {
          const doc = dom24.getDoc(ctx2);
          return trackPointerMove(doc, {
            onPointerMove({ event, point }) {
              const { offset: offset3 } = getRelativePoint(point, dom24.getControlEl(ctx2));
              send({ type: "POINTER_MOVE", point: offset3, pressure: event.pressure });
            },
            onPointerUp() {
              send({ type: "POINTER_UP" });
            }
          });
        }
      },
      actions: {
        addPoint(ctx2, evt) {
          ctx2.currentPoints.push(evt.point);
          const stroke = _e(ctx2.currentPoints, ctx2.drawing);
          ctx2.currentPath = getSvgPathFromStroke(stroke);
        },
        endStroke(ctx2) {
          ctx2.paths.push(ctx2.currentPath);
          ctx2.currentPoints = [];
          ctx2.currentPath = null;
        },
        clearPoints(ctx2) {
          ctx2.currentPoints = [];
          ctx2.paths = [];
        },
        focusCanvasEl(ctx2) {
          queueMicrotask(() => {
            var _a;
            (_a = dom24.getControlEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        invokeOnDraw(ctx2) {
          var _a;
          (_a = ctx2.onDraw) == null ? void 0 : _a.call(ctx2, {
            paths: [...ctx2.paths, ctx2.currentPath]
          });
        },
        invokeOnDrawEnd(ctx2) {
          var _a;
          (_a = ctx2.onDrawEnd) == null ? void 0 : _a.call(ctx2, {
            paths: [...ctx2.paths],
            getDataUrl(type, quality = 0.92) {
              return dom24.getDataUrl(ctx2, { type, quality });
            }
          });
        }
      }
    }
  );
}
var props20 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "onDraw",
  "onDrawEnd",
  "readOnly",
  "drawing",
  "name"
]);
var splitProps20 = createSplitProps(props20);

// node_modules/@zag-js/element-size/dist/index.mjs
function trackElementSize(element, callback) {
  if (!element) {
    callback(void 0);
    return;
  }
  callback({ width: element.offsetWidth, height: element.offsetHeight });
  const win = element.ownerDocument.defaultView ?? window;
  const observer = new win.ResizeObserver((entries) => {
    if (!Array.isArray(entries) || !entries.length)
      return;
    const [entry] = entries;
    let width;
    let height;
    if ("borderBoxSize" in entry) {
      const borderSizeEntry = entry["borderBoxSize"];
      const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
      width = borderSize["inlineSize"];
      height = borderSize["blockSize"];
    } else {
      width = element.offsetWidth;
      height = element.offsetHeight;
    }
    callback({ width, height });
  });
  observer.observe(element, { box: "border-box" });
  return () => observer.unobserve(element);
}
function trackElementsSize(options) {
  const { getNodes, observeMutation = true, callback } = options;
  const cleanups2 = [];
  let firstNode = null;
  function trigger() {
    const elements = getNodes();
    firstNode = elements[0];
    const fns = elements.map(
      (element, index) => trackElementSize(element, (size3) => {
        callback(size3, index);
      })
    );
    cleanups2.push(...fns);
  }
  trigger();
  if (observeMutation) {
    const fn = trackMutation(firstNode, trigger);
    cleanups2.push(fn);
  }
  return () => {
    cleanups2.forEach((cleanup) => {
      cleanup == null ? void 0 : cleanup();
    });
  };
}
function trackMutation(el, cb) {
  var _a;
  if (!el || !el.parentElement)
    return;
  const win = ((_a = el.ownerDocument) == null ? void 0 : _a.defaultView) ?? window;
  const observer = new win.MutationObserver(() => {
    cb();
  });
  observer.observe(el.parentElement, { childList: true });
  return () => {
    observer.disconnect();
  };
}

// node_modules/@zag-js/slider/dist/index.mjs
var anatomy31 = createAnatomy("slider").parts(
  "root",
  "label",
  "thumb",
  "valueText",
  "track",
  "range",
  "control",
  "markerGroup",
  "marker"
);
var parts25 = anatomy31.build();
function getBounds(value) {
  const firstValue = value[0];
  const lastThumb = value[value.length - 1];
  return [firstValue, lastThumb];
}
function getRangeOffsets(ctx) {
  const [firstPercent, lastPercent] = getBounds(ctx.valuePercent);
  if (ctx.valuePercent.length === 1) {
    if (ctx.origin === "center") {
      const isNegative = ctx.valuePercent[0] < 50;
      const start = isNegative ? `${ctx.valuePercent[0]}%` : "50%";
      const end = isNegative ? "50%" : `${100 - ctx.valuePercent[0]}%`;
      return { start, end };
    }
    return { start: "0%", end: `${100 - lastPercent}%` };
  }
  return { start: `${firstPercent}%`, end: `${100 - lastPercent}%` };
}
function getRangeStyle(ctx) {
  if (ctx.isVertical) {
    return {
      position: "absolute",
      bottom: "var(--slider-range-start)",
      top: "var(--slider-range-end)"
    };
  }
  return {
    position: "absolute",
    [ctx.isRtl ? "right" : "left"]: "var(--slider-range-start)",
    [ctx.isRtl ? "left" : "right"]: "var(--slider-range-end)"
  };
}
function getVerticalThumbOffset(ctx) {
  const { height = 0 } = ctx.thumbSize ?? {};
  const getValue = getValueTransformer([ctx.min, ctx.max], [-height / 2, height / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getHorizontalThumbOffset(ctx) {
  const { width = 0 } = ctx.thumbSize ?? {};
  if (ctx.isRtl) {
    const getValue2 = getValueTransformer([ctx.max, ctx.min], [-width / 2, width / 2]);
    return -1 * parseFloat(getValue2(ctx.value).toFixed(2));
  }
  const getValue = getValueTransformer([ctx.min, ctx.max], [-width / 2, width / 2]);
  return parseFloat(getValue(ctx.value).toFixed(2));
}
function getOffset(ctx, percent) {
  if (ctx.thumbAlignment === "center")
    return `${percent}%`;
  const offset3 = ctx.isVertical ? getVerticalThumbOffset(ctx) : getHorizontalThumbOffset(ctx);
  return `calc(${percent}% - ${offset3}px)`;
}
function getThumbOffset(ctx) {
  let percent = getValuePercent(ctx.value, ctx.min, ctx.max) * 100;
  return getOffset(ctx, percent);
}
function getVisibility(ctx) {
  let visibility = "visible";
  if (ctx.thumbAlignment === "contain" && !ctx.hasMeasuredThumbSize) {
    visibility = "hidden";
  }
  return visibility;
}
function getThumbStyle(ctx, index) {
  const placementProp = ctx.isVertical ? "bottom" : "insetInlineStart";
  return {
    visibility: getVisibility(ctx),
    position: "absolute",
    transform: "var(--slider-thumb-transform)",
    [placementProp]: `var(--slider-thumb-offset-${index})`
  };
}
function getControlStyle() {
  return {
    touchAction: "none",
    userSelect: "none",
    position: "relative"
  };
}
function getRootStyle(ctx) {
  const range2 = getRangeOffsets(ctx);
  const offsetStyles = ctx.value.reduce((styles, value, index) => {
    const offset3 = getThumbOffset({ ...ctx, value });
    return { ...styles, [`--slider-thumb-offset-${index}`]: offset3 };
  }, {});
  return {
    ...offsetStyles,
    "--slider-thumb-transform": ctx.isVertical ? "translateY(50%)" : ctx.isRtl ? "translateX(50%)" : "translateX(-50%)",
    "--slider-range-start": range2.start,
    "--slider-range-end": range2.end
  };
}
function getMarkerStyle(ctx, value) {
  return {
    // @ts-expect-error
    visibility: getVisibility(ctx),
    position: "absolute",
    pointerEvents: "none",
    // @ts-expect-error
    [ctx.isHorizontal ? "insetInlineStart" : "bottom"]: getThumbOffset({ ...ctx, value }),
    translate: "var(--tx) var(--ty)",
    "--tx": ctx.isHorizontal ? ctx.isRtl ? "50%" : "-50%" : "0%",
    "--ty": !ctx.isHorizontal ? "50%" : "0%"
  };
}
function getMarkerGroupStyle() {
  return {
    userSelect: "none",
    pointerEvents: "none",
    position: "relative"
  };
}
var styleGetterFns = {
  getRootStyle,
  getControlStyle,
  getThumbStyle,
  getRangeStyle,
  getMarkerStyle,
  getMarkerGroupStyle
};
var dom25 = createScope({
  ...styleGetterFns,
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `slider:${ctx.id}`;
  },
  getThumbId: (ctx, index) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.thumb) == null ? void 0 : _b.call(_a, index)) ?? `slider:${ctx.id}:thumb:${index}`;
  },
  getHiddenInputId: (ctx, index) => `slider:${ctx.id}:input:${index}`,
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `slider:${ctx.id}:control`;
  },
  getTrackId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.track) ?? `slider:${ctx.id}:track`;
  },
  getRangeId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.range) ?? `slider:${ctx.id}:range`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `slider:${ctx.id}:label`;
  },
  getValueTextId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.valueText) ?? `slider:${ctx.id}:valueText`;
  },
  getMarkerId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.marker) == null ? void 0 : _b.call(_a, value)) ?? `slider:${ctx.id}:marker:${value}`;
  },
  getRootEl: (ctx) => dom25.getById(ctx, dom25.getRootId(ctx)),
  getThumbEl: (ctx, index) => dom25.getById(ctx, dom25.getThumbId(ctx, index)),
  getHiddenInputEl: (ctx, index) => dom25.getById(ctx, dom25.getHiddenInputId(ctx, index)),
  getControlEl: (ctx) => dom25.getById(ctx, dom25.getControlId(ctx)),
  getElements: (ctx) => queryAll(dom25.getControlEl(ctx), "[role=slider]"),
  getFirstEl: (ctx) => dom25.getElements(ctx)[0],
  getRangeEl: (ctx) => dom25.getById(ctx, dom25.getRangeId(ctx)),
  getValueFromPoint(ctx, point) {
    const controlEl = dom25.getControlEl(ctx);
    if (!controlEl)
      return;
    const relativePoint = getRelativePoint(point, controlEl);
    const percent = relativePoint.getPercentValue({
      orientation: ctx.orientation,
      dir: ctx.dir,
      inverted: { y: true }
    });
    return getPercentValue(percent, ctx.min, ctx.max, ctx.step);
  },
  dispatchChangeEvent(ctx) {
    const valueArray = Array.from(ctx.value);
    valueArray.forEach((value, index) => {
      const inputEl = dom25.getHiddenInputEl(ctx, index);
      if (!inputEl)
        return;
      dispatchInputValueEvent(inputEl, { value });
    });
  }
});
function normalizeValues(ctx, nextValues) {
  return nextValues.map((value, index, values) => {
    return constrainValue2({ ...ctx, value: values }, value, index);
  });
}
function getRangeAtIndex(ctx, index) {
  return getValueRanges(ctx.value, ctx.min, ctx.max, ctx.minStepsBetweenThumbs)[index];
}
function constrainValue2(ctx, value, index) {
  const range2 = getRangeAtIndex(ctx, index);
  const snapValue = snapValueToStep(value, ctx.min, ctx.max, ctx.step);
  return clampValue(snapValue, range2.min, range2.max);
}
function decrement2(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getPreviousStepValue(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function increment2(ctx, index, step) {
  const idx = index ?? ctx.focusedIndex;
  const range2 = getRangeAtIndex(ctx, idx);
  const nextValues = getNextStepValue(idx, {
    ...range2,
    step: step ?? ctx.step,
    values: ctx.value
  });
  nextValues[idx] = clampValue(nextValues[idx], range2.min, range2.max);
  return nextValues;
}
function getClosestIndex(ctx, pointValue) {
  return getClosestValueIndex(ctx.value, pointValue);
}
function assignArray(current, next) {
  for (let i = 0; i < next.length; i++) {
    const value = next[i];
    current[i] = value;
  }
}
function connect25(state2, send, normalize) {
  const ariaLabel = state2.context["aria-label"];
  const ariaLabelledBy = state2.context["aria-labelledby"];
  const sliderValue = state2.context.value;
  const focused = state2.matches("focus");
  const dragging = state2.matches("dragging");
  const disabled = state2.context.isDisabled;
  const invalid = state2.context.invalid;
  const interactive = state2.context.isInteractive;
  const isHorizontal = state2.context.orientation === "horizontal";
  const isVertical = state2.context.orientation === "vertical";
  function getValuePercentFn(value) {
    return getValuePercent(value, state2.context.min, state2.context.max);
  }
  function getPercentValueFn(percent) {
    return getPercentValue(percent, state2.context.min, state2.context.max, state2.context.step);
  }
  return {
    value: state2.context.value,
    dragging,
    focused,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    getThumbValue(index) {
      return sliderValue[index];
    },
    setThumbValue(index, value) {
      send({ type: "SET_VALUE", index, value });
    },
    getValuePercent: getValuePercentFn,
    getPercentValue: getPercentValueFn,
    getThumbPercent(index) {
      return getValuePercentFn(sliderValue[index]);
    },
    setThumbPercent(index, percent) {
      const value = getPercentValueFn(percent);
      send({ type: "SET_VALUE", index, value });
    },
    getThumbMin(index) {
      return getRangeAtIndex(state2.context, index).min;
    },
    getThumbMax(index) {
      return getRangeAtIndex(state2.context, index).max;
    },
    increment(index) {
      send({ type: "INCREMENT", index });
    },
    decrement(index) {
      send({ type: "DECREMENT", index });
    },
    focus() {
      if (!interactive)
        return;
      send({ type: "FOCUS", index: 0 });
    },
    getLabelProps() {
      return normalize.label({
        ...parts25.label.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom25.getLabelId(state2.context),
        htmlFor: dom25.getHiddenInputId(state2.context, 0),
        onClick(event) {
          var _a;
          if (!interactive)
            return;
          event.preventDefault();
          (_a = dom25.getFirstEl(state2.context)) == null ? void 0 : _a.focus();
        },
        style: {
          userSelect: "none"
        }
      });
    },
    getRootProps() {
      return normalize.element({
        ...parts25.root.attrs,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom25.getRootId(state2.context),
        dir: state2.context.dir,
        style: dom25.getRootStyle(state2.context)
      });
    },
    getValueTextProps() {
      return normalize.element({
        ...parts25.valueText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        id: dom25.getValueTextId(state2.context)
      });
    },
    getTrackProps() {
      return normalize.element({
        ...parts25.track.attrs,
        dir: state2.context.dir,
        id: dom25.getTrackId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        style: { position: "relative" }
      });
    },
    getThumbProps(props29) {
      var _a, _b;
      const { index = 0, name } = props29;
      const value = sliderValue[index];
      const range2 = getRangeAtIndex(state2.context, index);
      const valueText = (_b = (_a = state2.context).getAriaValueText) == null ? void 0 : _b.call(_a, { value, index });
      const _ariaLabel = Array.isArray(ariaLabel) ? ariaLabel[index] : ariaLabel;
      const _ariaLabelledBy = Array.isArray(ariaLabelledBy) ? ariaLabelledBy[index] : ariaLabelledBy;
      return normalize.element({
        ...parts25.thumb.attrs,
        dir: state2.context.dir,
        "data-index": index,
        "data-name": name,
        id: dom25.getThumbId(state2.context, index),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused && state2.context.focusedIndex === index),
        draggable: false,
        "aria-disabled": ariaAttr(disabled),
        "aria-label": _ariaLabel,
        "aria-labelledby": _ariaLabelledBy ?? dom25.getLabelId(state2.context),
        "aria-orientation": state2.context.orientation,
        "aria-valuemax": range2.max,
        "aria-valuemin": range2.min,
        "aria-valuenow": sliderValue[index],
        "aria-valuetext": valueText,
        role: "slider",
        tabIndex: disabled ? void 0 : 0,
        style: dom25.getThumbStyle(state2.context, index),
        onPointerDown(event) {
          if (!interactive)
            return;
          send({ type: "THUMB_POINTER_DOWN", index });
          event.stopPropagation();
        },
        onBlur() {
          if (!interactive)
            return;
          send("BLUR");
        },
        onFocus() {
          if (!interactive)
            return;
          send({ type: "FOCUS", index });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!interactive)
            return;
          const step = getEventStep(event) * state2.context.step;
          const keyMap2 = {
            ArrowUp() {
              if (isHorizontal)
                return;
              send({ type: "ARROW_INC", step, src: "ArrowUp" });
            },
            ArrowDown() {
              if (isHorizontal)
                return;
              send({ type: "ARROW_DEC", step, src: "ArrowDown" });
            },
            ArrowLeft() {
              if (isVertical)
                return;
              send({ type: "ARROW_DEC", step, src: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical)
                return;
              send({ type: "ARROW_INC", step, src: "ArrowRight" });
            },
            PageUp() {
              send({ type: "ARROW_INC", step, src: "PageUp" });
            },
            PageDown() {
              send({ type: "ARROW_DEC", step, src: "PageDown" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
            event.stopPropagation();
          }
        }
      });
    },
    getHiddenInputProps(props29) {
      const { index = 0, name } = props29;
      return normalize.input({
        name: name ?? (state2.context.name ? state2.context.name + (state2.context.value.length > 1 ? "[]" : "") : void 0),
        form: state2.context.form,
        type: "text",
        hidden: true,
        defaultValue: state2.context.value[index],
        id: dom25.getHiddenInputId(state2.context, index)
      });
    },
    getRangeProps() {
      return normalize.element({
        id: dom25.getRangeId(state2.context),
        ...parts25.range.attrs,
        dir: state2.context.dir,
        "data-focus": dataAttr(focused),
        "data-invalid": dataAttr(invalid),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        style: dom25.getRangeStyle(state2.context)
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts25.control.attrs,
        dir: state2.context.dir,
        id: dom25.getControlId(state2.context),
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused),
        style: dom25.getControlStyle(),
        onPointerDown(event) {
          if (!interactive)
            return;
          if (!isLeftClick(event))
            return;
          if (isModifierKey(event))
            return;
          const point = getEventPoint(event);
          send({ type: "POINTER_DOWN", point });
          event.preventDefault();
          event.stopPropagation();
        }
      });
    },
    getMarkerGroupProps() {
      return normalize.element({
        ...parts25.markerGroup.attrs,
        role: "presentation",
        dir: state2.context.dir,
        "aria-hidden": true,
        "data-orientation": state2.context.orientation,
        style: dom25.getMarkerGroupStyle()
      });
    },
    getMarkerProps(props29) {
      const style = dom25.getMarkerStyle(state2.context, props29.value);
      let markerState;
      const first2 = state2.context.value[0];
      const last2 = state2.context.value[state2.context.value.length - 1];
      if (props29.value < first2) {
        markerState = "under-value";
      } else if (props29.value > last2) {
        markerState = "over-value";
      } else {
        markerState = "at-value";
      }
      return normalize.element({
        ...parts25.marker.attrs,
        id: dom25.getMarkerId(state2.context, props29.value),
        role: "presentation",
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-value": props29.value,
        "data-disabled": dataAttr(disabled),
        "data-state": markerState,
        style
      });
    }
  };
}
var isEqualSize2 = (a2, b2) => {
  return (a2 == null ? void 0 : a2.width) === (b2 == null ? void 0 : b2.width) && (a2 == null ? void 0 : a2.height) === (b2 == null ? void 0 : b2.height);
};
function machine25(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "slider",
      initial: "idle",
      context: {
        thumbSize: null,
        thumbAlignment: "contain",
        min: 0,
        max: 100,
        step: 1,
        value: [0],
        origin: "start",
        orientation: "horizontal",
        dir: "ltr",
        minStepsBetweenThumbs: 0,
        disabled: false,
        readOnly: false,
        ...ctx,
        focusedIndex: -1,
        fieldsetDisabled: false
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        isVertical: (ctx2) => ctx2.orientation === "vertical",
        isRtl: (ctx2) => ctx2.orientation === "horizontal" && ctx2.dir === "rtl",
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        hasMeasuredThumbSize: (ctx2) => ctx2.thumbSize != null,
        valuePercent(ctx2) {
          return ctx2.value.map((value) => 100 * getValuePercent(value, ctx2.min, ctx2.max));
        }
      },
      watch: {
        value: ["syncInputElements"]
      },
      entry: ["coarseValue"],
      activities: ["trackFormControlState", "trackThumbsSize"],
      on: {
        SET_VALUE: [
          {
            guard: "hasIndex",
            actions: "setValueAtIndex"
          },
          { actions: "setValue" }
        ],
        INCREMENT: {
          actions: "incrementThumbAtIndex"
        },
        DECREMENT: {
          actions: "decrementThumbAtIndex"
        }
      },
      states: {
        idle: {
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            FOCUS: {
              target: "focus",
              actions: "setFocusedIndex"
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            }
          }
        },
        focus: {
          entry: "focusActiveThumb",
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setClosestThumbIndex", "setPointerValue", "focusActiveThumb"]
            },
            THUMB_POINTER_DOWN: {
              target: "dragging",
              actions: ["setFocusedIndex", "focusActiveThumb"]
            },
            ARROW_DEC: {
              actions: ["decrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            ARROW_INC: {
              actions: ["incrementThumbAtIndex", "invokeOnChangeEnd"]
            },
            HOME: {
              actions: ["setFocusedThumbToMin", "invokeOnChangeEnd"]
            },
            END: {
              actions: ["setFocusedThumbToMax", "invokeOnChangeEnd"]
            },
            BLUR: {
              target: "idle",
              actions: "clearFocusedIndex"
            }
          }
        },
        dragging: {
          entry: "focusActiveThumb",
          activities: "trackPointerMove",
          on: {
            POINTER_UP: {
              target: "focus",
              actions: "invokeOnChangeEnd"
            },
            POINTER_MOVE: {
              actions: "setPointerValue"
            }
          }
        }
      }
    },
    {
      guards: {
        hasIndex: (_ctx, evt) => evt.index != null
      },
      activities: {
        trackFormControlState(ctx2, _evt, { initialContext }) {
          return trackFormControl(dom25.getRootEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              set18.value(ctx2, initialContext.value);
            }
          });
        },
        trackPointerMove(ctx2, _evt, { send }) {
          return trackPointerMove(dom25.getDoc(ctx2), {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        },
        trackThumbsSize(ctx2) {
          if (ctx2.thumbAlignment !== "contain" || ctx2.thumbSize)
            return;
          return trackElementsSize({
            getNodes: () => dom25.getElements(ctx2),
            observeMutation: true,
            callback(size3) {
              if (!size3 || isEqualSize2(ctx2.thumbSize, size3))
                return;
              ctx2.thumbSize = size3;
            }
          });
        }
      },
      actions: {
        syncInputElements(ctx2) {
          ctx2.value.forEach((value, index) => {
            const inputEl = dom25.getHiddenInputEl(ctx2, index);
            dom25.setValue(inputEl, value);
          });
        },
        invokeOnChangeEnd(ctx2) {
          var _a;
          (_a = ctx2.onValueChangeEnd) == null ? void 0 : _a.call(ctx2, { value: ctx2.value });
        },
        setClosestThumbIndex(ctx2, evt) {
          const pointValue = dom25.getValueFromPoint(ctx2, evt.point);
          if (pointValue == null)
            return;
          const focusedIndex = getClosestIndex(ctx2, pointValue);
          set18.focusedIndex(ctx2, focusedIndex);
        },
        setFocusedIndex(ctx2, evt) {
          set18.focusedIndex(ctx2, evt.index);
        },
        clearFocusedIndex(ctx2) {
          set18.focusedIndex(ctx2, -1);
        },
        setPointerValue(ctx2, evt) {
          const pointerValue = dom25.getValueFromPoint(ctx2, evt.point);
          if (pointerValue == null)
            return;
          const value = constrainValue2(ctx2, pointerValue, ctx2.focusedIndex);
          set18.valueAtIndex(ctx2, ctx2.focusedIndex, value);
        },
        focusActiveThumb(ctx2) {
          raf(() => {
            const thumbEl = dom25.getThumbEl(ctx2, ctx2.focusedIndex);
            thumbEl == null ? void 0 : thumbEl.focus({ preventScroll: true });
          });
        },
        decrementThumbAtIndex(ctx2, evt) {
          const value = decrement2(ctx2, evt.index, evt.step);
          set18.value(ctx2, value);
        },
        incrementThumbAtIndex(ctx2, evt) {
          const value = increment2(ctx2, evt.index, evt.step);
          set18.value(ctx2, value);
        },
        setFocusedThumbToMin(ctx2) {
          const { min: min3 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set18.valueAtIndex(ctx2, ctx2.focusedIndex, min3);
        },
        setFocusedThumbToMax(ctx2) {
          const { max: max3 } = getRangeAtIndex(ctx2, ctx2.focusedIndex);
          set18.valueAtIndex(ctx2, ctx2.focusedIndex, max3);
        },
        coarseValue(ctx2) {
          const value = normalizeValues(ctx2, ctx2.value);
          set18.value(ctx2, value);
        },
        setValueAtIndex(ctx2, evt) {
          const value = constrainValue2(ctx2, evt.value, evt.index);
          set18.valueAtIndex(ctx2, evt.index, value);
        },
        setValue(ctx2, evt) {
          const value = normalizeValues(ctx2, evt.value);
          set18.value(ctx2, value);
        }
      }
    }
  );
}
var invoke14 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, {
      value: Array.from(ctx.value)
    });
    dom25.dispatchChangeEvent(ctx);
  },
  focusChange: (ctx) => {
    var _a;
    (_a = ctx.onFocusChange) == null ? void 0 : _a.call(ctx, {
      value: Array.from(ctx.value),
      focusedIndex: ctx.focusedIndex
    });
  }
};
var set18 = {
  valueAtIndex: (ctx, index, value) => {
    if (isEqual(ctx.value[index], value))
      return;
    ctx.value[index] = value;
    invoke14.change(ctx);
  },
  value: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    assignArray(ctx.value, value);
    invoke14.change(ctx);
  },
  focusedIndex: (ctx, index) => {
    if (isEqual(ctx.focusedIndex, index))
      return;
    ctx.focusedIndex = index;
    invoke14.focusChange(ctx);
  }
};
var props21 = createProps()([
  "aria-label",
  "aria-labelledby",
  "dir",
  "disabled",
  "form",
  "getAriaValueText",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "max",
  "min",
  "minStepsBetweenThumbs",
  "name",
  "onFocusChange",
  "onValueChange",
  "onValueChangeEnd",
  "orientation",
  "origin",
  "readOnly",
  "step",
  "thumbAlignment",
  "thumbAlignment",
  "thumbSize",
  "value"
]);
var splitProps21 = createSplitProps(props21);
var thumbProps = createProps()(["index", "name"]);
var splitThumbProps = createSplitProps(thumbProps);

// node_modules/@zag-js/splitter/dist/index.mjs
var anatomy32 = createAnatomy("splitter").parts("root", "panel", "resizeTrigger");
var parts26 = anatomy32.build();
var dom26 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `splitter:${ctx.id}`;
  },
  getResizeTriggerId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.resizeTrigger) == null ? void 0 : _b.call(_a, id)) ?? `splitter:${ctx.id}:splitter:${id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `splitter:${ctx.id}:label`;
  },
  getPanelId: (ctx, id) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.panel) == null ? void 0 : _b.call(_a, id)) ?? `splitter:${ctx.id}:panel:${id}`;
  },
  globalCursorId: (ctx) => `splitter:${ctx.id}:global-cursor`,
  getRootEl: (ctx) => dom26.getById(ctx, dom26.getRootId(ctx)),
  getResizeTriggerEl: (ctx, id) => dom26.getById(ctx, dom26.getResizeTriggerId(ctx, id)),
  getPanelEl: (ctx, id) => dom26.getById(ctx, dom26.getPanelId(ctx, id)),
  getCursor(ctx) {
    const x = ctx.isHorizontal;
    let cursor = x ? "col-resize" : "row-resize";
    if (ctx.activeResizeState.isAtMin)
      cursor = x ? "e-resize" : "s-resize";
    if (ctx.activeResizeState.isAtMax)
      cursor = x ? "w-resize" : "n-resize";
    return cursor;
  },
  getPanelStyle(ctx, id) {
    var _a;
    const flexGrow = ((_a = ctx.panels.find((panel) => panel.id === id)) == null ? void 0 : _a.size) ?? "0";
    return {
      flexBasis: 0,
      flexGrow,
      flexShrink: 1,
      overflow: "hidden"
    };
  },
  getActiveHandleEl(ctx) {
    const activeId = ctx.activeResizeId;
    if (activeId == null)
      return;
    return dom26.getById(ctx, dom26.getResizeTriggerId(ctx, activeId));
  },
  getResizeTriggerEls(ctx) {
    const ownerId = CSS.escape(dom26.getRootId(ctx));
    return queryAll(dom26.getRootEl(ctx), `[role=separator][data-ownedby='${ownerId}']`);
  },
  setupGlobalCursor(ctx) {
    const styleEl = dom26.getById(ctx, dom26.globalCursorId(ctx));
    const textContent = `* { cursor: ${dom26.getCursor(ctx)} !important; }`;
    if (styleEl) {
      styleEl.textContent = textContent;
    } else {
      const style = dom26.getDoc(ctx).createElement("style");
      style.id = dom26.globalCursorId(ctx);
      style.textContent = textContent;
      dom26.getDoc(ctx).head.appendChild(style);
    }
  },
  removeGlobalCursor(ctx) {
    var _a;
    (_a = dom26.getById(ctx, dom26.globalCursorId(ctx))) == null ? void 0 : _a.remove();
  }
});
function validateSize(key, size3) {
  if (Math.floor(size3) > 100) {
    throw new Error(`Total ${key} of panels cannot be greater than 100`);
  }
}
function getNormalizedPanels(ctx) {
  let numOfPanelsWithoutSize = 0;
  let totalSize = 0;
  let totalMinSize = 0;
  const panels = ctx.size.map((panel) => {
    const minSize = panel.minSize ?? 0;
    const maxSize = panel.maxSize ?? 100;
    totalMinSize += minSize;
    if (panel.size == null) {
      numOfPanelsWithoutSize++;
    } else {
      totalSize += panel.size;
    }
    return {
      ...panel,
      minSize,
      maxSize
    };
  });
  validateSize("minSize", totalMinSize);
  validateSize("size", totalSize);
  let end = 0;
  let remainingSize = 0;
  const result = panels.map((panel) => {
    let start = end;
    if (panel.size != null) {
      end += panel.size;
      remainingSize = panel.size - panel.minSize;
      return {
        ...panel,
        start,
        end,
        remainingSize
      };
    }
    const size3 = (100 - totalSize) / numOfPanelsWithoutSize;
    end += size3;
    remainingSize = size3 - panel.minSize;
    return { ...panel, size: size3, start, end, remainingSize };
  });
  return result;
}
function getHandlePanels(ctx, id = ctx.activeResizeId) {
  const [beforeId, afterId] = (id == null ? void 0 : id.split(":")) ?? [];
  if (!beforeId || !afterId)
    return;
  const beforeIndex = ctx.previousPanels.findIndex((panel) => panel.id === beforeId);
  const afterIndex = ctx.previousPanels.findIndex((panel) => panel.id === afterId);
  if (beforeIndex === -1 || afterIndex === -1)
    return;
  const before = ctx.previousPanels[beforeIndex];
  const after = ctx.previousPanels[afterIndex];
  return {
    before: {
      ...before,
      index: beforeIndex
    },
    after: {
      ...after,
      index: afterIndex
    }
  };
}
function getHandleBounds(ctx, id = ctx.activeResizeId) {
  const panels = getHandlePanels(ctx, id);
  if (!panels)
    return;
  const { before, after } = panels;
  return {
    min: Math.max(before.start + before.minSize, after.end - after.maxSize),
    max: Math.min(after.end - after.minSize, before.maxSize + before.start)
  };
}
function getPanelBounds(ctx, id) {
  const bounds = getHandleBounds(ctx, id);
  const panels = getHandlePanels(ctx, id);
  if (!bounds || !panels)
    return;
  const { before, after } = panels;
  const beforeMin = Math.abs(before.start - bounds.min);
  const afterMin = after.size + (before.size - beforeMin);
  const beforeMax = Math.abs(before.start - bounds.max);
  const afterMax = after.size - (beforeMax - before.size);
  return {
    before: {
      index: before.index,
      min: beforeMin,
      max: beforeMax,
      isAtMin: beforeMin === before.size,
      isAtMax: beforeMax === before.size,
      up(step) {
        return Math.min(before.size + step, beforeMax);
      },
      down(step) {
        return Math.max(before.size - step, beforeMin);
      }
    },
    after: {
      index: after.index,
      min: afterMin,
      max: afterMax,
      isAtMin: afterMin === after.size,
      isAtMax: afterMax === after.size,
      up(step) {
        return Math.min(after.size + step, afterMin);
      },
      down(step) {
        return Math.max(after.size - step, afterMax);
      }
    }
  };
}
function clamp4(value, min3, max3) {
  return Math.min(Math.max(value, min3), max3);
}
function connect26(state2, send, normalize) {
  const horizontal = state2.context.isHorizontal;
  const focused = state2.hasTag("focus");
  const dragging = state2.matches("dragging");
  const panels = state2.context.panels;
  function getResizeTriggerState(props29) {
    const { id, disabled } = props29;
    const ids = id.split(":");
    const panelIds = ids.map((id2) => dom26.getPanelId(state2.context, id2));
    const panels2 = getHandleBounds(state2.context, id);
    return {
      disabled: !!disabled,
      focused: state2.context.activeResizeId === id && focused,
      panelIds,
      min: panels2 == null ? void 0 : panels2.min,
      max: panels2 == null ? void 0 : panels2.max,
      value: 0
    };
  }
  return {
    focused,
    dragging,
    getResizeTriggerState,
    bounds: getHandleBounds(state2.context),
    setToMinSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      send({ type: "SET_PANEL_SIZE", id, size: panel == null ? void 0 : panel.minSize, src: "setToMinSize" });
    },
    setToMaxSize(id) {
      const panel = panels.find((panel2) => panel2.id === id);
      send({ type: "SET_PANEL_SIZE", id, size: panel == null ? void 0 : panel.maxSize, src: "setToMaxSize" });
    },
    setSize(id, size3) {
      send({ type: "SET_PANEL_SIZE", id, size: size3 });
    },
    getRootProps() {
      return normalize.element({
        ...parts26.root.attrs,
        "data-orientation": state2.context.orientation,
        id: dom26.getRootId(state2.context),
        dir: state2.context.dir,
        style: {
          display: "flex",
          flexDirection: horizontal ? "row" : "column",
          height: "100%",
          width: "100%",
          overflow: "hidden"
        }
      });
    },
    getPanelProps(props29) {
      const { id } = props29;
      return normalize.element({
        ...parts26.panel.attrs,
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        id: dom26.getPanelId(state2.context, id),
        "data-ownedby": dom26.getRootId(state2.context),
        style: dom26.getPanelStyle(state2.context, id)
      });
    },
    getResizeTriggerProps(props29) {
      const { id, disabled, step = 1 } = props29;
      const triggerState = getResizeTriggerState(props29);
      return normalize.element({
        ...parts26.resizeTrigger.attrs,
        dir: state2.context.dir,
        id: dom26.getResizeTriggerId(state2.context, id),
        role: "separator",
        "data-ownedby": dom26.getRootId(state2.context),
        tabIndex: disabled ? void 0 : 0,
        "aria-valuenow": triggerState.value,
        "aria-valuemin": triggerState.min,
        "aria-valuemax": triggerState.max,
        "data-orientation": state2.context.orientation,
        "aria-orientation": state2.context.orientation,
        "aria-controls": triggerState.panelIds.join(" "),
        "data-focus": dataAttr(triggerState.focused),
        "data-disabled": dataAttr(disabled),
        style: {
          touchAction: "none",
          userSelect: "none",
          flex: "0 0 auto",
          pointerEvents: dragging && !triggerState.focused ? "none" : void 0,
          cursor: horizontal ? "col-resize" : "row-resize",
          [horizontal ? "minHeight" : "minWidth"]: "0"
        },
        onPointerDown(event) {
          if (disabled) {
            event.preventDefault();
            return;
          }
          send({ type: "POINTER_DOWN", id });
          event.currentTarget.setPointerCapture(event.pointerId);
          event.preventDefault();
          event.stopPropagation();
        },
        onPointerUp(event) {
          if (disabled)
            return;
          if (event.currentTarget.hasPointerCapture(event.pointerId)) {
            event.currentTarget.releasePointerCapture(event.pointerId);
          }
        },
        onPointerOver() {
          if (disabled)
            return;
          send({ type: "POINTER_OVER", id });
        },
        onPointerLeave() {
          if (disabled)
            return;
          send({ type: "POINTER_LEAVE", id });
        },
        onBlur() {
          send("BLUR");
        },
        onFocus() {
          send({ type: "FOCUS", id });
        },
        onDoubleClick() {
          if (disabled)
            return;
          send({ type: "DOUBLE_CLICK", id });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (disabled)
            return;
          const moveStep = getEventStep(event) * step;
          const keyMap2 = {
            Enter() {
              send("ENTER");
            },
            ArrowUp() {
              send({ type: "ARROW_UP", step: moveStep });
            },
            ArrowDown() {
              send({ type: "ARROW_DOWN", step: moveStep });
            },
            ArrowLeft() {
              send({ type: "ARROW_LEFT", step: moveStep });
            },
            ArrowRight() {
              send({ type: "ARROW_RIGHT", step: moveStep });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            event.preventDefault();
          }
        }
      });
    }
  };
}
function machine26(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "splitter",
      initial: "idle",
      context: {
        orientation: "horizontal",
        activeResizeId: null,
        previousPanels: [],
        size: [],
        initialSize: [],
        activeResizeState: {
          isAtMin: false,
          isAtMax: false
        },
        ...ctx
      },
      created: ["setPreviousPanels", "setInitialSize"],
      watch: {
        size: ["setActiveResizeState"]
      },
      computed: {
        isHorizontal: (ctx2) => ctx2.orientation === "horizontal",
        panels: (ctx2) => getNormalizedPanels(ctx2)
      },
      on: {
        SET_PANEL_SIZE: {
          actions: "setPanelSize"
        }
      },
      states: {
        idle: {
          entry: ["clearActiveHandleId"],
          on: {
            POINTER_OVER: {
              target: "hover:temp",
              actions: ["setActiveHandleId"]
            },
            FOCUS: {
              target: "focused",
              actions: ["setActiveHandleId"]
            },
            DOUBLE_CLICK: {
              actions: ["resetStartPanel", "setPreviousPanels"]
            }
          }
        },
        "hover:temp": {
          after: {
            HOVER_DELAY: "hover"
          },
          on: {
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setActiveHandleId"]
            },
            POINTER_LEAVE: "idle"
          }
        },
        hover: {
          tags: ["focus"],
          on: {
            POINTER_DOWN: "dragging",
            POINTER_LEAVE: "idle"
          }
        },
        focused: {
          tags: ["focus"],
          on: {
            BLUR: "idle",
            POINTER_DOWN: {
              target: "dragging",
              actions: ["setActiveHandleId"]
            },
            ARROW_LEFT: {
              guard: "isHorizontal",
              actions: ["shrinkStartPanel", "setPreviousPanels"]
            },
            ARROW_RIGHT: {
              guard: "isHorizontal",
              actions: ["expandStartPanel", "setPreviousPanels"]
            },
            ARROW_UP: {
              guard: "isVertical",
              actions: ["shrinkStartPanel", "setPreviousPanels"]
            },
            ARROW_DOWN: {
              guard: "isVertical",
              actions: ["expandStartPanel", "setPreviousPanels"]
            },
            ENTER: [
              {
                guard: "isStartPanelAtMax",
                actions: ["setStartPanelToMin", "setPreviousPanels"]
              },
              { actions: ["setStartPanelToMax", "setPreviousPanels"] }
            ],
            HOME: {
              actions: ["setStartPanelToMin", "setPreviousPanels"]
            },
            END: {
              actions: ["setStartPanelToMax", "setPreviousPanels"]
            }
          }
        },
        dragging: {
          tags: ["focus"],
          entry: "focusResizeHandle",
          activities: ["trackPointerMove"],
          on: {
            POINTER_MOVE: {
              actions: ["setPointerValue", "setGlobalCursor", "invokeOnResize"]
            },
            POINTER_UP: {
              target: "focused",
              actions: ["setPreviousPanels", "clearGlobalCursor", "blurResizeHandle", "invokeOnResizeEnd"]
            }
          }
        }
      }
    },
    {
      activities: {
        trackPointerMove: (ctx2, _evt, { send }) => {
          const doc = dom26.getDoc(ctx2);
          return trackPointerMove(doc, {
            onPointerMove(info) {
              send({ type: "POINTER_MOVE", point: info.point });
            },
            onPointerUp() {
              send("POINTER_UP");
            }
          });
        }
      },
      guards: {
        isStartPanelAtMin: (ctx2) => ctx2.activeResizeState.isAtMin,
        isStartPanelAtMax: (ctx2) => ctx2.activeResizeState.isAtMax,
        isHorizontal: (ctx2) => ctx2.isHorizontal,
        isVertical: (ctx2) => !ctx2.isHorizontal
      },
      delays: {
        HOVER_DELAY: 250
      },
      actions: {
        setGlobalCursor(ctx2) {
          dom26.setupGlobalCursor(ctx2);
        },
        clearGlobalCursor(ctx2) {
          dom26.removeGlobalCursor(ctx2);
        },
        invokeOnResize(ctx2) {
          var _a;
          (_a = ctx2.onSizeChange) == null ? void 0 : _a.call(ctx2, { size: Array.from(ctx2.size), activeHandleId: ctx2.activeResizeId });
        },
        invokeOnResizeEnd(ctx2) {
          var _a;
          (_a = ctx2.onSizeChangeEnd) == null ? void 0 : _a.call(ctx2, { size: Array.from(ctx2.size), activeHandleId: ctx2.activeResizeId });
        },
        setActiveHandleId(ctx2, evt) {
          ctx2.activeResizeId = evt.id;
        },
        clearActiveHandleId(ctx2) {
          ctx2.activeResizeId = null;
        },
        setInitialSize(ctx2) {
          ctx2.initialSize = ctx2.panels.slice().map((panel) => ({
            id: panel.id,
            size: panel.size
          }));
        },
        setPanelSize(ctx2, evt) {
          const { id, size: size3 } = evt;
          ctx2.size = ctx2.size.map((panel) => {
            const panelSize = clamp4(size3, panel.minSize ?? 0, panel.maxSize ?? 100);
            return panel.id === id ? { ...panel, size: panelSize } : panel;
          });
        },
        setStartPanelToMin(ctx2) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds)
            return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.min;
          ctx2.size[after.index].size = after.min;
        },
        setStartPanelToMax(ctx2) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds)
            return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.max;
          ctx2.size[after.index].size = after.max;
        },
        expandStartPanel(ctx2, evt) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds)
            return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.up(evt.step);
          ctx2.size[after.index].size = after.down(evt.step);
        },
        shrinkStartPanel(ctx2, evt) {
          const bounds = getPanelBounds(ctx2);
          if (!bounds)
            return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = before.down(evt.step);
          ctx2.size[after.index].size = after.up(evt.step);
        },
        resetStartPanel(ctx2, evt) {
          const bounds = getPanelBounds(ctx2, evt.id);
          if (!bounds)
            return;
          const { before, after } = bounds;
          ctx2.size[before.index].size = ctx2.initialSize[before.index].size;
          ctx2.size[after.index].size = ctx2.initialSize[after.index].size;
        },
        focusResizeHandle(ctx2) {
          raf(() => {
            var _a;
            (_a = dom26.getActiveHandleEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        blurResizeHandle(ctx2) {
          raf(() => {
            var _a;
            (_a = dom26.getActiveHandleEl(ctx2)) == null ? void 0 : _a.blur();
          });
        },
        setPreviousPanels(ctx2) {
          ctx2.previousPanels = ctx2.panels.slice();
        },
        setActiveResizeState(ctx2) {
          const panels = getPanelBounds(ctx2);
          if (!panels)
            return;
          const { before } = panels;
          ctx2.activeResizeState = {
            isAtMin: before.isAtMin,
            isAtMax: before.isAtMax
          };
        },
        setPointerValue(ctx2, evt) {
          const panels = getHandlePanels(ctx2);
          const bounds = getHandleBounds(ctx2);
          if (!panels || !bounds)
            return;
          const rootEl = dom26.getRootEl(ctx2);
          if (!rootEl)
            return;
          const relativePoint = getRelativePoint(evt.point, rootEl);
          const percentValue = relativePoint.getPercentValue({
            dir: ctx2.dir,
            orientation: ctx2.orientation
          });
          let pointValue = percentValue * 100;
          ctx2.activeResizeState = {
            isAtMin: pointValue < bounds.min,
            isAtMax: pointValue > bounds.max
          };
          pointValue = clamp4(pointValue, bounds.min, bounds.max);
          const { before, after } = panels;
          const offset3 = pointValue - before.end;
          ctx2.size[before.index].size = before.size + offset3;
          ctx2.size[after.index].size = after.size - offset3;
        }
      }
    }
  );
}
var props22 = createProps()([
  "dir",
  "getRootNode",
  "id",
  "ids",
  "onSizeChange",
  "onSizeChangeEnd",
  "orientation",
  "size"
]);
var splitProps22 = createSplitProps(props22);
var panelProps = createProps()(["id", "snapSize"]);
var splitPanelProps = createSplitProps(panelProps);
var resizeTriggerProps = createProps()(["disabled", "id", "step"]);
var splitResizeTriggerProps = createSplitProps(resizeTriggerProps);

// node_modules/@zag-js/switch/dist/index.mjs
var anatomy33 = createAnatomy("switch").parts("root", "label", "control", "thumb");
var parts27 = anatomy33.build();
var dom27 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `switch:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `switch:${ctx.id}:label`;
  },
  getThumbId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.thumb) ?? `switch:${ctx.id}:thumb`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `switch:${ctx.id}:control`;
  },
  getRootEl: (ctx) => dom27.getById(ctx, dom27.getRootId(ctx)),
  getHiddenInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `switch:${ctx.id}:input`;
  },
  getHiddenInputEl: (ctx) => dom27.getById(ctx, dom27.getHiddenInputId(ctx))
});
function connect27(state2, send, normalize) {
  const disabled = state2.context.isDisabled;
  const focused = !disabled && state2.context.focused;
  const checked = state2.context.checked;
  const readOnly = state2.context.readOnly;
  const dataAttrs = {
    "data-active": dataAttr(state2.context.active),
    "data-focus": dataAttr(focused),
    "data-readonly": dataAttr(readOnly),
    "data-hover": dataAttr(state2.context.hovered),
    "data-disabled": dataAttr(disabled),
    "data-state": state2.context.checked ? "checked" : "unchecked",
    "data-invalid": dataAttr(state2.context.invalid)
  };
  return {
    checked,
    disabled,
    focused,
    setChecked(checked2) {
      send({ type: "CHECKED.SET", checked: checked2, isTrusted: false });
    },
    toggleChecked() {
      send({ type: "CHECKED.TOGGLE", checked, isTrusted: false });
    },
    getRootProps() {
      return normalize.label({
        ...parts27.root.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom27.getRootId(state2.context),
        htmlFor: dom27.getHiddenInputId(state2.context),
        onPointerMove() {
          if (disabled)
            return;
          send({ type: "CONTEXT.SET", context: { hovered: true } });
        },
        onPointerLeave() {
          if (disabled)
            return;
          send({ type: "CONTEXT.SET", context: { hovered: false } });
        },
        onClick(event) {
          if (event.target === dom27.getHiddenInputEl(state2.context)) {
            event.stopPropagation();
          }
        }
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts27.label.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom27.getLabelId(state2.context)
      });
    },
    getThumbProps() {
      return normalize.element({
        ...parts27.thumb.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom27.getThumbId(state2.context),
        "aria-hidden": true
      });
    },
    getControlProps() {
      return normalize.element({
        ...parts27.control.attrs,
        ...dataAttrs,
        dir: state2.context.dir,
        id: dom27.getControlId(state2.context),
        "aria-hidden": true
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        id: dom27.getHiddenInputId(state2.context),
        type: "checkbox",
        required: state2.context.required,
        defaultChecked: checked,
        disabled,
        "aria-labelledby": dom27.getLabelId(state2.context),
        "aria-invalid": state2.context.invalid,
        name: state2.context.name,
        form: state2.context.form,
        value: state2.context.value,
        style: visuallyHiddenStyle,
        onChange(event) {
          if (readOnly) {
            event.preventDefault();
            return;
          }
          const checked2 = event.currentTarget.checked;
          send({ type: "CHECKED.SET", checked: checked2, isTrusted: true });
        }
      });
    }
  };
}
var { not: not11 } = guards;
function machine27(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "switch",
      initial: "ready",
      context: {
        checked: false,
        label: "switch",
        value: "on",
        disabled: false,
        ...ctx,
        fieldsetDisabled: false
      },
      computed: {
        isDisabled: (ctx2) => ctx2.disabled || ctx2.fieldsetDisabled
      },
      watch: {
        disabled: "removeFocusIfNeeded",
        checked: "syncInputElement"
      },
      activities: ["trackFormControlState", "trackPressEvent", "trackFocusVisible"],
      on: {
        "CHECKED.TOGGLE": [
          {
            guard: not11("isTrusted"),
            actions: ["toggleChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["toggleChecked"]
          }
        ],
        "CHECKED.SET": [
          {
            guard: not11("isTrusted"),
            actions: ["setChecked", "dispatchChangeEvent"]
          },
          {
            actions: ["setChecked"]
          }
        ],
        "CONTEXT.SET": {
          actions: ["setContext"]
        }
      },
      states: {
        ready: {}
      }
    },
    {
      guards: {
        isTrusted: (_ctx, evt) => !!evt.isTrusted
      },
      activities: {
        trackPressEvent(ctx2) {
          if (ctx2.isDisabled)
            return;
          return trackPress({
            pointerNode: dom27.getRootEl(ctx2),
            keyboardNode: dom27.getHiddenInputEl(ctx2),
            isValidKey: (event) => event.key === " ",
            onPress: () => ctx2.active = false,
            onPressStart: () => ctx2.active = true,
            onPressEnd: () => ctx2.active = false
          });
        },
        trackFocusVisible(ctx2) {
          if (ctx2.isDisabled)
            return;
          return trackFocusVisible(dom27.getHiddenInputEl(ctx2), {
            onFocus: () => ctx2.focused = true,
            onBlur: () => ctx2.focused = false
          });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom27.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "CHECKED.SET", checked: !!initialContext.checked, src: "form-reset" });
            }
          });
        }
      },
      actions: {
        setContext(ctx2, evt) {
          Object.assign(ctx2, evt.context);
        },
        syncInputElement(ctx2) {
          const inputEl = dom27.getHiddenInputEl(ctx2);
          if (!inputEl)
            return;
          inputEl.checked = !!ctx2.checked;
        },
        removeFocusIfNeeded(ctx2) {
          if (ctx2.disabled && ctx2.focused) {
            ctx2.focused = false;
          }
        },
        setChecked(ctx2, evt) {
          set19.checked(ctx2, evt.checked);
        },
        toggleChecked(ctx2, _evt) {
          set19.checked(ctx2, !ctx2.checked);
        },
        dispatchChangeEvent(ctx2) {
          const inputEl = dom27.getHiddenInputEl(ctx2);
          dispatchInputCheckedEvent(inputEl, { checked: ctx2.checked });
        }
      }
    }
  );
}
var invoke15 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onCheckedChange) == null ? void 0 : _a.call(ctx, { checked: ctx.checked });
  }
};
var set19 = {
  checked: (ctx, checked) => {
    if (isEqual(ctx.checked, checked))
      return;
    ctx.checked = checked;
    invoke15.change(ctx);
  }
};
var props23 = createProps()([
  "checked",
  "dir",
  "disabled",
  "form",
  "getRootNode",
  "id",
  "ids",
  "invalid",
  "label",
  "name",
  "onCheckedChange",
  "readOnly",
  "required",
  "value"
]);
var splitProps23 = createSplitProps(props23);

// node_modules/@zag-js/tabs/dist/index.mjs
var anatomy34 = createAnatomy("tabs").parts("root", "list", "trigger", "content", "indicator");
var parts28 = anatomy34.build();
var dom28 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `tabs:${ctx.id}`;
  },
  getListId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.list) ?? `tabs:${ctx.id}:list`;
  },
  getContentId: (ctx, id) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `tabs:${ctx.id}:content-${id}`;
  },
  getTriggerId: (ctx, id) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `tabs:${ctx.id}:trigger-${id}`;
  },
  getIndicatorId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.indicator) ?? `tabs:${ctx.id}:indicator`;
  },
  getListEl: (ctx) => dom28.getById(ctx, dom28.getListId(ctx)),
  getContentEl: (ctx, id) => dom28.getById(ctx, dom28.getContentId(ctx, id)),
  getTriggerEl: (ctx, id) => dom28.getById(ctx, dom28.getTriggerId(ctx, id)),
  getIndicatorEl: (ctx) => dom28.getById(ctx, dom28.getIndicatorId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom28.getListId(ctx));
    const selector = `[role=tab][data-ownedby='${ownerId}']:not([disabled])`;
    return queryAll(dom28.getListEl(ctx), selector);
  },
  getFirstTriggerEl: (ctx) => first(dom28.getElements(ctx)),
  getLastTriggerEl: (ctx) => last(dom28.getElements(ctx)),
  getNextTriggerEl: (ctx, id) => nextById(dom28.getElements(ctx), dom28.getTriggerId(ctx, id), ctx.loopFocus),
  getPrevTriggerEl: (ctx, id) => prevById(dom28.getElements(ctx), dom28.getTriggerId(ctx, id), ctx.loopFocus),
  getSelectedContentEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom28.getContentEl(ctx, ctx.value);
  },
  getSelectedTriggerEl: (ctx) => {
    if (!ctx.value)
      return;
    return dom28.getTriggerEl(ctx, ctx.value);
  },
  getOffsetRect: (el) => {
    return {
      left: (el == null ? void 0 : el.offsetLeft) ?? 0,
      top: (el == null ? void 0 : el.offsetTop) ?? 0,
      width: (el == null ? void 0 : el.offsetWidth) ?? 0,
      height: (el == null ? void 0 : el.offsetHeight) ?? 0
    };
  },
  getRectById: (ctx, id) => {
    const tab = itemById(dom28.getElements(ctx), dom28.getTriggerId(ctx, id));
    return dom28.resolveRect(dom28.getOffsetRect(tab));
  },
  resolveRect: (rect) => ({
    width: `${rect.width}px`,
    height: `${rect.height}px`,
    left: `${rect.left}px`,
    top: `${rect.top}px`
  })
});
function connect28(state2, send, normalize) {
  const translations = state2.context.translations;
  const focused = state2.matches("focused");
  const isVertical = state2.context.orientation === "vertical";
  const isHorizontal = state2.context.orientation === "horizontal";
  const composite = state2.context.composite;
  const indicator = state2.context.indicatorState;
  function getTriggerState(props29) {
    return {
      selected: state2.context.value === props29.value,
      focused: state2.context.focusedValue === props29.value,
      disabled: !!props29.disabled
    };
  }
  return {
    value: state2.context.value,
    focusedValue: state2.context.focusedValue,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue() {
      send({ type: "CLEAR_VALUE" });
    },
    setIndicatorRect(value) {
      const id = dom28.getTriggerId(state2.context, value);
      send({ type: "SET_INDICATOR_RECT", id });
    },
    syncTabIndex() {
      send("SYNC_TAB_INDEX");
    },
    selectNext(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectNext" });
      send({ type: "ARROW_NEXT", src: "selectNext" });
    },
    selectPrev(fromValue) {
      send({ type: "TAB_FOCUS", value: fromValue, src: "selectPrev" });
      send({ type: "ARROW_PREV", src: "selectPrev" });
    },
    focus() {
      var _a;
      (_a = dom28.getSelectedTriggerEl(state2.context)) == null ? void 0 : _a.focus();
    },
    getRootProps() {
      return normalize.element({
        ...parts28.root.attrs,
        id: dom28.getRootId(state2.context),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(focused),
        dir: state2.context.dir
      });
    },
    getListProps() {
      return normalize.element({
        ...parts28.list.attrs,
        id: dom28.getListId(state2.context),
        role: "tablist",
        dir: state2.context.dir,
        "data-focus": dataAttr(focused),
        "aria-orientation": state2.context.orientation,
        "data-orientation": state2.context.orientation,
        "aria-label": translations == null ? void 0 : translations.listLabel,
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!isSelfTarget(event))
            return;
          if (isComposingEvent(event))
            return;
          const keyMap2 = {
            ArrowDown() {
              if (isHorizontal)
                return;
              send({ type: "ARROW_NEXT", key: "ArrowDown" });
            },
            ArrowUp() {
              if (isHorizontal)
                return;
              send({ type: "ARROW_PREV", key: "ArrowUp" });
            },
            ArrowLeft() {
              if (isVertical)
                return;
              send({ type: "ARROW_PREV", key: "ArrowLeft" });
            },
            ArrowRight() {
              if (isVertical)
                return;
              send({ type: "ARROW_NEXT", key: "ArrowRight" });
            },
            Home() {
              send("HOME");
            },
            End() {
              send("END");
            },
            Enter() {
              send({ type: "ENTER" });
            }
          };
          let key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getTriggerState,
    getTriggerProps(props29) {
      const { value, disabled } = props29;
      const triggerState = getTriggerState(props29);
      return normalize.button({
        ...parts28.trigger.attrs,
        role: "tab",
        type: "button",
        disabled,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        "data-disabled": dataAttr(disabled),
        "aria-disabled": disabled,
        "data-value": value,
        "aria-selected": triggerState.selected,
        "data-selected": dataAttr(triggerState.selected),
        "data-focus": dataAttr(triggerState.focused),
        "aria-controls": triggerState.selected ? dom28.getContentId(state2.context, value) : void 0,
        "data-ownedby": dom28.getListId(state2.context),
        "data-ssr": dataAttr(state2.context.ssr),
        id: dom28.getTriggerId(state2.context, value),
        tabIndex: triggerState.selected && composite ? 0 : -1,
        onFocus() {
          send({ type: "TAB_FOCUS", value });
        },
        onBlur(event) {
          const target = event.relatedTarget;
          if ((target == null ? void 0 : target.getAttribute("role")) !== "tab") {
            send({ type: "TAB_BLUR" });
          }
        },
        onClick(event) {
          if (event.defaultPrevented)
            return;
          if (disabled)
            return;
          if (isSafari()) {
            event.currentTarget.focus();
          }
          send({ type: "TAB_CLICK", value });
        }
      });
    },
    getContentProps(props29) {
      const { value } = props29;
      const selected = state2.context.value === value;
      return normalize.element({
        ...parts28.content.attrs,
        dir: state2.context.dir,
        id: dom28.getContentId(state2.context, value),
        tabIndex: composite ? 0 : -1,
        "aria-labelledby": dom28.getTriggerId(state2.context, value),
        role: "tabpanel",
        "data-ownedby": dom28.getListId(state2.context),
        "data-selected": dataAttr(selected),
        "data-orientation": state2.context.orientation,
        hidden: !selected
      });
    },
    getIndicatorProps() {
      var _a, _b, _c, _d;
      return normalize.element({
        id: dom28.getIndicatorId(state2.context),
        ...parts28.indicator.attrs,
        dir: state2.context.dir,
        "data-orientation": state2.context.orientation,
        style: {
          "--transition-property": "left, right, top, bottom, width, height",
          "--left": (_a = indicator.rect) == null ? void 0 : _a.left,
          "--top": (_b = indicator.rect) == null ? void 0 : _b.top,
          "--width": (_c = indicator.rect) == null ? void 0 : _c.width,
          "--height": (_d = indicator.rect) == null ? void 0 : _d.height,
          position: "absolute",
          willChange: "var(--transition-property)",
          transitionProperty: "var(--transition-property)",
          transitionDuration: indicator.transition ? "var(--transition-duration, 150ms)" : "0ms",
          transitionTimingFunction: "var(--transition-timing-function)",
          [isHorizontal ? "left" : "top"]: isHorizontal ? "var(--left)" : "var(--top)"
        }
      });
    }
  };
}
var { not: not12 } = guards;
function machine28(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      initial: "idle",
      context: {
        dir: "ltr",
        orientation: "horizontal",
        activationMode: "automatic",
        value: null,
        loopFocus: true,
        composite: true,
        ...ctx,
        focusedValue: ctx.value ?? null,
        ssr: true,
        indicatorState: {
          rendered: false,
          transition: false,
          rect: { left: "0px", top: "0px", width: "0px", height: "0px" }
        }
      },
      watch: {
        value: ["allowIndicatorTransition", "syncIndicatorRect", "syncTabIndex", "clickIfLink"],
        dir: ["syncIndicatorRect"],
        orientation: ["syncIndicatorRect"]
      },
      on: {
        SET_VALUE: {
          actions: "setValue"
        },
        CLEAR_VALUE: {
          actions: "clearValue"
        },
        SET_INDICATOR_RECT: {
          actions: "setIndicatorRect"
        },
        SYNC_TAB_INDEX: {
          actions: "syncTabIndex"
        }
      },
      created: ["syncFocusedValue"],
      entry: ["checkRenderedElements", "syncIndicatorRect", "syncTabIndex", "syncSsr"],
      exit: ["cleanupObserver"],
      states: {
        idle: {
          on: {
            TAB_FOCUS: {
              target: "focused",
              actions: "setFocusedValue"
            },
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            }
          }
        },
        focused: {
          on: {
            TAB_CLICK: {
              target: "focused",
              actions: ["setFocusedValue", "setValue"]
            },
            ARROW_PREV: [
              {
                guard: "selectOnFocus",
                actions: ["focusPrevTab", "selectFocusedTab"]
              },
              {
                actions: "focusPrevTab"
              }
            ],
            ARROW_NEXT: [
              {
                guard: "selectOnFocus",
                actions: ["focusNextTab", "selectFocusedTab"]
              },
              {
                actions: "focusNextTab"
              }
            ],
            HOME: [
              {
                guard: "selectOnFocus",
                actions: ["focusFirstTab", "selectFocusedTab"]
              },
              {
                actions: "focusFirstTab"
              }
            ],
            END: [
              {
                guard: "selectOnFocus",
                actions: ["focusLastTab", "selectFocusedTab"]
              },
              {
                actions: "focusLastTab"
              }
            ],
            ENTER: {
              guard: not12("selectOnFocus"),
              actions: "selectFocusedTab"
            },
            TAB_FOCUS: {
              actions: ["setFocusedValue"]
            },
            TAB_BLUR: {
              target: "idle",
              actions: "clearFocusedValue"
            }
          }
        }
      }
    },
    {
      guards: {
        selectOnFocus: (ctx2) => ctx2.activationMode === "automatic"
      },
      actions: {
        syncFocusedValue(ctx2) {
          if (ctx2.value != null && ctx2.focusedValue == null) {
            ctx2.focusedValue = ctx2.value;
          }
        },
        selectFocusedTab(ctx2) {
          raf(() => {
            set20.value(ctx2, ctx2.focusedValue);
          });
        },
        setFocusedValue(ctx2, evt) {
          if (evt.value == null)
            return;
          set20.focusedValue(ctx2, evt.value);
        },
        clearFocusedValue(ctx2) {
          set20.focusedValue(ctx2, null);
        },
        setValue(ctx2, evt) {
          set20.value(ctx2, evt.value);
        },
        clearValue(ctx2) {
          set20.value(ctx2, null);
        },
        focusFirstTab(ctx2) {
          raf(() => {
            var _a;
            (_a = dom28.getFirstTriggerEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        focusLastTab(ctx2) {
          raf(() => {
            var _a;
            (_a = dom28.getLastTriggerEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        focusNextTab(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const triggerEl = dom28.getNextTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set20.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        focusPrevTab(ctx2) {
          if (!ctx2.focusedValue)
            return;
          const triggerEl = dom28.getPrevTriggerEl(ctx2, ctx2.focusedValue);
          raf(() => {
            if (ctx2.composite) {
              triggerEl == null ? void 0 : triggerEl.focus();
            } else if ((triggerEl == null ? void 0 : triggerEl.dataset.value) != null) {
              set20.focusedValue(ctx2, triggerEl.dataset.value);
            }
          });
        },
        checkRenderedElements(ctx2) {
          ctx2.indicatorState.rendered = !!dom28.getIndicatorEl(ctx2);
        },
        syncTabIndex(ctx2) {
          raf(() => {
            const contentEl = dom28.getSelectedContentEl(ctx2);
            if (!contentEl)
              return;
            const focusables = getFocusables(contentEl);
            if (focusables.length > 0) {
              contentEl.removeAttribute("tabindex");
            } else {
              contentEl.setAttribute("tabindex", "0");
            }
          });
        },
        cleanupObserver(ctx2) {
          var _a;
          (_a = ctx2.indicatorCleanup) == null ? void 0 : _a.call(ctx2);
        },
        allowIndicatorTransition(ctx2) {
          ctx2.indicatorState.transition = true;
        },
        setIndicatorRect(ctx2, evt) {
          const value = evt.id ?? ctx2.value;
          if (!ctx2.indicatorState.rendered || !value)
            return;
          const triggerEl = dom28.getTriggerEl(ctx2, value);
          if (!triggerEl)
            return;
          ctx2.indicatorState.rect = dom28.getRectById(ctx2, value);
          nextTick(() => {
            ctx2.indicatorState.transition = false;
          });
        },
        syncSsr(ctx2) {
          ctx2.ssr = false;
        },
        syncIndicatorRect(ctx2) {
          var _a;
          (_a = ctx2.indicatorCleanup) == null ? void 0 : _a.call(ctx2);
          const value = ctx2.value;
          if (!ctx2.indicatorState.rendered || !value)
            return;
          const triggerEl = dom28.getSelectedTriggerEl(ctx2);
          if (!triggerEl)
            return;
          ctx2.indicatorCleanup = trackElementRect(triggerEl, {
            getRect(el) {
              return dom28.getOffsetRect(el);
            },
            onChange(rect) {
              ctx2.indicatorState.rect = dom28.resolveRect(rect);
              nextTick(() => {
                ctx2.indicatorState.transition = false;
              });
            }
          });
        },
        clickIfLink(ctx2) {
          clickIfLink(dom28.getSelectedTriggerEl(ctx2));
        }
      }
    }
  );
}
var invoke16 = {
  change: (ctx) => {
    var _a;
    if (ctx.value == null)
      return;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: ctx.value });
  },
  focusChange: (ctx) => {
    var _a;
    if (ctx.focusedValue == null)
      return;
    (_a = ctx.onFocusChange) == null ? void 0 : _a.call(ctx, { focusedValue: ctx.focusedValue });
  }
};
var set20 = {
  value: (ctx, value) => {
    if (isEqual(value, ctx.value))
      return;
    ctx.value = value;
    invoke16.change(ctx);
  },
  focusedValue: (ctx, value) => {
    if (isEqual(value, ctx.focusedValue))
      return;
    ctx.focusedValue = value;
    invoke16.focusChange(ctx);
  }
};
var props24 = createProps()([
  "activationMode",
  "composite",
  "dir",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "onFocusChange",
  "onValueChange",
  "orientation",
  "translations",
  "value"
]);
var splitProps24 = createSplitProps(props24);
var triggerProps = createProps()(["disabled", "value"]);
var splitTriggerProps = createSplitProps(triggerProps);
var contentProps = createProps()(["value"]);
var splitContentProps = createSplitProps(contentProps);

// node_modules/@zag-js/auto-resize/dist/index.mjs
function copyVisualStyles(fromEl, toEl) {
  if (!fromEl)
    return;
  const win = getWindow(fromEl);
  const el = win.getComputedStyle(fromEl);
  const cssText = "box-sizing:" + el.boxSizing + ";border-left:" + el.borderLeftWidth + " solid red;border-right:" + el.borderRightWidth + " solid red;font-family:" + el.fontFamily + ";font-feature-settings:" + el.fontFeatureSettings + ";font-kerning:" + el.fontKerning + ";font-size:" + el.fontSize + ";font-stretch:" + el.fontStretch + ";font-style:" + el.fontStyle + ";font-variant:" + el.fontVariant + ";font-variant-caps:" + el.fontVariantCaps + ";font-variant-ligatures:" + el.fontVariantLigatures + ";font-variant-numeric:" + el.fontVariantNumeric + ";font-weight:" + el.fontWeight + ";letter-spacing:" + el.letterSpacing + ";margin-left:" + el.marginLeft + ";margin-right:" + el.marginRight + ";padding-left:" + el.paddingLeft + ";padding-right:" + el.paddingRight + ";text-indent:" + el.textIndent + ";text-transform:" + el.textTransform;
  toEl.style.cssText += cssText;
}
function createGhostElement(doc) {
  var el = doc.createElement("div");
  el.id = "ghost";
  el.style.cssText = "display:inline-block;height:0;overflow:hidden;position:absolute;top:0;visibility:hidden;white-space:nowrap;";
  doc.body.appendChild(el);
  return el;
}
function autoResizeInput(input) {
  if (!input)
    return;
  const doc = getDocument(input);
  const win = getWindow(input);
  const ghost = createGhostElement(doc);
  copyVisualStyles(input, ghost);
  function resize() {
    win.requestAnimationFrame(() => {
      ghost.innerHTML = input.value;
      const rect = win.getComputedStyle(ghost);
      input == null ? void 0 : input.style.setProperty("width", rect.width);
    });
  }
  resize();
  input == null ? void 0 : input.addEventListener("input", resize);
  input == null ? void 0 : input.addEventListener("change", resize);
  return () => {
    doc.body.removeChild(ghost);
    input == null ? void 0 : input.removeEventListener("input", resize);
    input == null ? void 0 : input.removeEventListener("change", resize);
  };
}

// node_modules/@zag-js/tags-input/dist/index.mjs
var anatomy35 = createAnatomy("tagsInput").parts(
  "root",
  "label",
  "control",
  "input",
  "clearTrigger",
  "item",
  "itemPreview",
  "itemInput",
  "itemText",
  "itemDeleteTrigger"
);
var parts29 = anatomy35.build();
var dom29 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `tags-input:${ctx.id}`;
  },
  getInputId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.input) ?? `tags-input:${ctx.id}:input`;
  },
  getClearTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.clearBtn) ?? `tags-input:${ctx.id}:clear-btn`;
  },
  getHiddenInputId: (ctx) => `tags-input:${ctx.id}:hidden-input`,
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `tags-input:${ctx.id}:label`;
  },
  getControlId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.control) ?? `tags-input:${ctx.id}:control`;
  },
  getItemId: (ctx, opt) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, opt)) ?? `tags-input:${ctx.id}:tag:${opt.value}:${opt.index}`;
  },
  getItemDeleteTriggerId: (ctx, opt) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemDeleteTrigger) == null ? void 0 : _b.call(_a, opt)) ?? `${dom29.getItemId(ctx, opt)}:delete-btn`;
  },
  getItemInputId: (ctx, opt) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.itemInput) == null ? void 0 : _b.call(_a, opt)) ?? `${dom29.getItemId(ctx, opt)}:input`;
  },
  getEditInputId: (ctx) => `${ctx.editedTagId}:input`,
  getTagInputEl: (ctx, opt) => dom29.getById(ctx, dom29.getItemInputId(ctx, opt)),
  getRootEl: (ctx) => dom29.getById(ctx, dom29.getRootId(ctx)),
  getInputEl: (ctx) => dom29.getById(ctx, dom29.getInputId(ctx)),
  getHiddenInputEl: (ctx) => dom29.getById(ctx, dom29.getHiddenInputId(ctx)),
  getEditInputEl: (ctx) => dom29.getById(ctx, dom29.getEditInputId(ctx)),
  getTagElements: (ctx) => queryAll(dom29.getRootEl(ctx), `[data-part=item-preview]:not([data-disabled])`),
  getFirstEl: (ctx) => dom29.getTagElements(ctx)[0],
  getLastEl: (ctx) => dom29.getTagElements(ctx)[dom29.getTagElements(ctx).length - 1],
  getPrevEl: (ctx, id) => prevById(dom29.getTagElements(ctx), id, false),
  getNextEl: (ctx, id) => nextById(dom29.getTagElements(ctx), id, false),
  getTagElAtIndex: (ctx, index) => dom29.getTagElements(ctx)[index],
  getIndexOfId: (ctx, id) => indexOfId(dom29.getTagElements(ctx), id),
  isInputFocused: (ctx) => dom29.getDoc(ctx).activeElement === dom29.getInputEl(ctx),
  getHighlightedTagValue: (ctx) => {
    if (!ctx.highlightedTagId)
      return null;
    const tagEl = dom29.getById(ctx, ctx.highlightedTagId);
    return (tagEl == null ? void 0 : tagEl.dataset.value) ?? null;
  },
  setHoverIntent: (el) => {
    const tagEl = el.closest("[data-part=item-preview]");
    if (!tagEl)
      return;
    tagEl.dataset.deleteIntent = "";
  },
  clearHoverIntent: (el) => {
    const tagEl = el.closest("[data-part=item-preview]");
    if (!tagEl)
      return;
    delete tagEl.dataset.deleteIntent;
  },
  dispatchInputEvent(ctx) {
    const inputEl = dom29.getHiddenInputEl(ctx);
    if (!inputEl)
      return;
    dispatchInputValueEvent(inputEl, { value: ctx.valueAsString });
  }
});
function connect29(state2, send, normalize) {
  const interactive = state2.context.isInteractive;
  const disabled = state2.context.disabled;
  const readOnly = state2.context.readOnly;
  const invalid = state2.context.invalid || state2.context.isOverflowing;
  const translations = state2.context.translations;
  const focused = state2.hasTag("focused");
  const editingTag = state2.matches("editing:tag");
  const empty = state2.context.count === 0;
  function getItemState(options) {
    const id = dom29.getItemId(state2.context, options);
    return {
      id,
      editing: editingTag && state2.context.editedTagId === id,
      highlighted: id === state2.context.highlightedTagId,
      disabled: Boolean(options.disabled || disabled)
    };
  }
  return {
    empty,
    inputValue: state2.context.trimmedInputValue,
    value: state2.context.value,
    valueAsString: state2.context.valueAsString,
    count: state2.context.count,
    atMax: state2.context.isAtMax,
    setValue(value) {
      send({ type: "SET_VALUE", value });
    },
    clearValue(id) {
      if (id) {
        send({ type: "CLEAR_TAG", id });
      } else {
        send("CLEAR_VALUE");
      }
    },
    addValue(value) {
      send({ type: "ADD_TAG", value });
    },
    setValueAtIndex(index, value) {
      send({ type: "SET_VALUE_AT_INDEX", index, value });
    },
    setInputValue(value) {
      send({ type: "SET_INPUT_VALUE", value });
    },
    clearInputValue() {
      send({ type: "SET_INPUT_VALUE", value: "" });
    },
    focus() {
      var _a;
      (_a = dom29.getInputEl(state2.context)) == null ? void 0 : _a.focus();
    },
    getItemState,
    getRootProps() {
      return normalize.element({
        dir: state2.context.dir,
        ...parts29.root.attrs,
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        "data-disabled": dataAttr(disabled),
        "data-focus": dataAttr(focused),
        "data-empty": dataAttr(empty),
        id: dom29.getRootId(state2.context),
        onPointerDown() {
          if (!interactive)
            return;
          send("POINTER_DOWN");
        }
      });
    },
    getLabelProps() {
      return normalize.label({
        ...parts29.label.attrs,
        "data-disabled": dataAttr(disabled),
        "data-invalid": dataAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        id: dom29.getLabelId(state2.context),
        dir: state2.context.dir,
        htmlFor: dom29.getInputId(state2.context)
      });
    },
    getControlProps() {
      return normalize.element({
        id: dom29.getControlId(state2.context),
        ...parts29.control.attrs,
        dir: state2.context.dir,
        tabIndex: readOnly ? 0 : void 0,
        "data-disabled": dataAttr(disabled),
        "data-readonly": dataAttr(readOnly),
        "data-invalid": dataAttr(invalid),
        "data-focus": dataAttr(focused)
      });
    },
    getInputProps() {
      return normalize.input({
        ...parts29.input.attrs,
        dir: state2.context.dir,
        "data-invalid": dataAttr(invalid),
        "aria-invalid": ariaAttr(invalid),
        "data-readonly": dataAttr(readOnly),
        maxLength: state2.context.maxLength,
        id: dom29.getInputId(state2.context),
        defaultValue: state2.context.inputValue,
        autoComplete: "off",
        autoCorrect: "off",
        autoCapitalize: "none",
        disabled: disabled || readOnly,
        onChange(event) {
          const evt = getNativeEvent(event);
          if (evt.inputType === "insertFromPaste")
            return;
          let value = event.target.value;
          if (endsWith(value, state2.context.delimiter)) {
            send("DELIMITER_KEY");
          } else {
            send({ type: "TYPE", value, key: evt.inputType });
          }
        },
        onFocus() {
          send("FOCUS");
        },
        onPaste(event) {
          event.preventDefault();
          const value = event.clipboardData.getData("text/plain");
          send({ type: "PASTE", value });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (isComposingEvent(event))
            return;
          const target = event.currentTarget;
          const isCombobox = target.getAttribute("role") === "combobox";
          const isExpanded = target.ariaExpanded === "true";
          const keyMap2 = {
            ArrowDown() {
              send("ARROW_DOWN");
            },
            ArrowLeft() {
              if (isCombobox && isExpanded)
                return;
              send("ARROW_LEFT");
            },
            ArrowRight(event2) {
              if (state2.context.highlightedTagId) {
                event2.preventDefault();
              }
              if (isCombobox && isExpanded)
                return;
              send("ARROW_RIGHT");
            },
            Escape(event2) {
              event2.preventDefault();
              send("ESCAPE");
            },
            Backspace() {
              send("BACKSPACE");
            },
            Delete() {
              send("DELETE");
            },
            Enter(event2) {
              if (isCombobox && isExpanded)
                return;
              send("ENTER");
              event2.preventDefault();
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            return;
          }
        }
      });
    },
    getHiddenInputProps() {
      return normalize.input({
        type: "text",
        hidden: true,
        name: state2.context.name,
        form: state2.context.form,
        id: dom29.getHiddenInputId(state2.context),
        defaultValue: state2.context.valueAsString
      });
    },
    getItemProps(props29) {
      return normalize.element({
        ...parts29.item.attrs,
        dir: state2.context.dir,
        "data-value": props29.value,
        "data-disabled": dataAttr(disabled)
      });
    },
    getItemPreviewProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts29.itemPreview.attrs,
        id: itemState.id,
        dir: state2.context.dir,
        hidden: itemState.editing,
        "data-value": props29.value,
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted),
        onPointerDown(event) {
          if (!interactive || itemState.disabled)
            return;
          event.preventDefault();
          send({ type: "POINTER_DOWN_TAG", id: itemState.id });
        },
        onDoubleClick() {
          if (!interactive || itemState.disabled)
            return;
          send({ type: "DOUBLE_CLICK_TAG", id: itemState.id });
        }
      });
    },
    getItemTextProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts29.itemText.attrs,
        dir: state2.context.dir,
        "data-disabled": dataAttr(disabled),
        "data-highlighted": dataAttr(itemState.highlighted)
      });
    },
    getItemInputProps(props29) {
      const itemState = getItemState(props29);
      return normalize.input({
        ...parts29.itemInput.attrs,
        dir: state2.context.dir,
        "aria-label": translations.tagEdited(props29.value),
        "aria-hidden": true,
        disabled,
        id: dom29.getItemInputId(state2.context, props29),
        tabIndex: -1,
        hidden: !itemState.editing,
        defaultValue: itemState.editing ? state2.context.editedTagValue : "",
        onChange(event) {
          send({ type: "TAG_INPUT_TYPE", value: event.target.value });
        },
        onBlur(event) {
          send({ type: "TAG_INPUT_BLUR", target: event.relatedTarget, id: itemState.id });
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (isComposingEvent(event))
            return;
          const keyMap2 = {
            Enter() {
              send("TAG_INPUT_ENTER");
            },
            Escape() {
              send("TAG_INPUT_ESCAPE");
            }
          };
          const exec2 = keyMap2[event.key];
          if (exec2) {
            event.preventDefault();
            exec2(event);
          }
        }
      });
    },
    getItemDeleteTriggerProps(props29) {
      const id = dom29.getItemId(state2.context, props29);
      return normalize.button({
        ...parts29.itemDeleteTrigger.attrs,
        dir: state2.context.dir,
        id: dom29.getItemDeleteTriggerId(state2.context, props29),
        type: "button",
        disabled,
        "aria-label": translations.deleteTagTriggerLabel(props29.value),
        tabIndex: -1,
        onPointerDown(event) {
          if (!interactive) {
            event.preventDefault();
          }
        },
        onPointerMove(event) {
          if (!interactive)
            return;
          dom29.setHoverIntent(event.currentTarget);
        },
        onPointerLeave(event) {
          if (!interactive)
            return;
          dom29.clearHoverIntent(event.currentTarget);
        },
        onClick() {
          if (!interactive)
            return;
          send({ type: "CLICK_DELETE_TAG", id });
        }
      });
    },
    getClearTriggerProps() {
      return normalize.button({
        ...parts29.clearTrigger.attrs,
        dir: state2.context.dir,
        id: dom29.getClearTriggerId(state2.context),
        type: "button",
        "data-readonly": dataAttr(readOnly),
        disabled,
        "aria-label": translations.clearTriggerLabel,
        hidden: empty,
        onClick() {
          if (!interactive)
            return;
          send("CLEAR_VALUE");
        }
      });
    }
  };
}
function endsWith(str, del) {
  if (!del)
    return false;
  if (typeof del === "string")
    return str.endsWith(del);
  return new RegExp(`${del.source}$`).test(str);
}
var { and: and10, not: not13, or: or4 } = guards;
function machine29(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "tags-input",
      initial: ctx.autoFocus ? "focused:input" : "idle",
      context: {
        inputValue: "",
        editedTagValue: "",
        editedTagId: null,
        highlightedTagId: null,
        value: [],
        dir: "ltr",
        max: Infinity,
        blurBehavior: void 0,
        addOnPaste: false,
        editable: true,
        validate: () => true,
        delimiter: ",",
        disabled: false,
        readOnly: false,
        ...ctx,
        liveRegion: null,
        log: { current: null, prev: null },
        fieldsetDisabled: false,
        translations: {
          clearTriggerLabel: "Clear all tags",
          deleteTagTriggerLabel: (value) => `Delete tag ${value}`,
          tagAdded: (value) => `Added tag ${value}`,
          tagsPasted: (values) => `Pasted ${values.length} tags`,
          tagEdited: (value) => `Editing tag ${value}. Press enter to save or escape to cancel.`,
          tagUpdated: (value) => `Tag update to ${value}`,
          tagDeleted: (value) => `Tag ${value} deleted`,
          tagSelected: (value) => `Tag ${value} selected. Press enter to edit, delete or backspace to remove.`,
          ...ctx.translations
        }
      },
      computed: {
        count: (ctx2) => ctx2.value.length,
        valueAsString: (ctx2) => JSON.stringify(ctx2.value),
        trimmedInputValue: (ctx2) => ctx2.inputValue.trim(),
        isDisabled: (ctx2) => !!ctx2.disabled || ctx2.fieldsetDisabled,
        isInteractive: (ctx2) => !(ctx2.readOnly || ctx2.isDisabled),
        isAtMax: (ctx2) => ctx2.count === ctx2.max,
        isOverflowing: (ctx2) => ctx2.count > ctx2.max
      },
      watch: {
        highlightedTagId: "logHighlightedTag",
        isOverflowing: "invokeOnInvalid",
        log: "announceLog",
        inputValue: "syncInputValue",
        editedTagValue: "syncEditedTagInputValue"
      },
      activities: ["trackLiveRegion", "trackFormControlState"],
      exit: ["clearLog"],
      on: {
        DOUBLE_CLICK_TAG: {
          internal: true,
          guard: "isTagEditable",
          target: "editing:tag",
          actions: ["setEditedId", "initializeEditedTagValue"]
        },
        POINTER_DOWN_TAG: {
          internal: true,
          target: "navigating:tag",
          actions: ["highlightTag", "focusInput"]
        },
        CLICK_DELETE_TAG: {
          target: "focused:input",
          actions: ["deleteTag"]
        },
        SET_INPUT_VALUE: {
          actions: ["setInputValue"]
        },
        SET_VALUE: {
          actions: ["setValue"]
        },
        CLEAR_TAG: {
          actions: ["deleteTag"]
        },
        SET_VALUE_AT_INDEX: {
          actions: ["setValueAtIndex"]
        },
        CLEAR_VALUE: {
          actions: ["clearTags", "clearInputValue", "focusInput"]
        },
        ADD_TAG: {
          // (!isAtMax || allowOverflow) && !inputValueIsEmpty
          guard: and10(or4(not13("isAtMax"), "allowOverflow"), not13("isInputValueEmpty")),
          actions: ["addTag", "clearInputValue"]
        },
        EXTERNAL_BLUR: [
          { guard: "addOnBlur", actions: "raiseAddTagEvent" },
          { guard: "clearOnBlur", actions: "clearInputValue" }
        ]
      },
      states: {
        idle: {
          on: {
            FOCUS: "focused:input",
            POINTER_DOWN: {
              guard: not13("hasHighlightedTag"),
              target: "focused:input"
            }
          }
        },
        "focused:input": {
          tags: ["focused"],
          entry: ["focusInput", "clearHighlightedId"],
          activities: ["trackInteractOutside"],
          on: {
            TYPE: {
              actions: "setInputValue"
            },
            BLUR: [
              {
                guard: "addOnBlur",
                target: "idle",
                actions: "raiseAddTagEvent"
              },
              {
                guard: "clearOnBlur",
                target: "idle",
                actions: "clearInputValue"
              },
              { target: "idle" }
            ],
            ENTER: {
              actions: ["raiseAddTagEvent"]
            },
            DELIMITER_KEY: {
              actions: ["raiseAddTagEvent"]
            },
            ARROW_LEFT: {
              guard: and10("hasTags", "isInputCaretAtStart"),
              target: "navigating:tag",
              actions: "highlightLastTag"
            },
            BACKSPACE: {
              target: "navigating:tag",
              guard: and10("hasTags", "isInputCaretAtStart"),
              actions: "highlightLastTag"
            },
            PASTE: [
              {
                guard: "addOnPaste",
                actions: ["setInputValue", "addTagFromPaste"]
              },
              {
                actions: "setInputValue"
              }
            ]
          }
        },
        "navigating:tag": {
          tags: ["focused"],
          activities: ["trackInteractOutside"],
          on: {
            ARROW_RIGHT: [
              {
                guard: and10("hasTags", "isInputCaretAtStart", not13("isLastTagHighlighted")),
                actions: "highlightNextTag"
              },
              { target: "focused:input" }
            ],
            ARROW_LEFT: {
              actions: "highlightPrevTag"
            },
            BLUR: {
              target: "idle",
              actions: "clearHighlightedId"
            },
            ENTER: {
              guard: and10("isTagEditable", "hasHighlightedTag"),
              target: "editing:tag",
              actions: ["setEditedId", "initializeEditedTagValue", "focusEditedTagInput"]
            },
            ARROW_DOWN: "focused:input",
            ESCAPE: "focused:input",
            TYPE: {
              target: "focused:input",
              actions: "setInputValue"
            },
            BACKSPACE: [
              {
                guard: "isFirstTagHighlighted",
                actions: ["deleteHighlightedTag", "highlightFirstTag"]
              },
              {
                actions: ["deleteHighlightedTag", "highlightPrevTag"]
              }
            ],
            DELETE: {
              actions: ["deleteHighlightedTag", "highlightTagAtIndex"]
            }
          }
        },
        "editing:tag": {
          tags: ["editing", "focused"],
          entry: "focusEditedTagInput",
          activities: ["autoResize"],
          on: {
            TAG_INPUT_TYPE: {
              actions: "setEditedTagValue"
            },
            TAG_INPUT_ESCAPE: {
              target: "navigating:tag",
              actions: ["clearEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
            },
            TAG_INPUT_BLUR: [
              {
                guard: "isInputRelatedTarget",
                target: "navigating:tag",
                actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId"]
              },
              {
                target: "idle",
                actions: ["clearEditedTagValue", "clearHighlightedId", "clearEditedId", "raiseExternalBlurEvent"]
              }
            ],
            TAG_INPUT_ENTER: [
              {
                guard: "isEditedTagEmpty",
                target: "navigating:tag",
                actions: ["deleteHighlightedTag", "focusInput", "clearEditedId", "highlightTagAtIndex"]
              },
              {
                target: "navigating:tag",
                actions: ["submitEditedTagValue", "focusInput", "clearEditedId", "highlightTagAtIndex"]
              }
            ]
          }
        }
      }
    },
    {
      guards: {
        isInputRelatedTarget: (ctx2, evt) => evt.relatedTarget === dom29.getInputEl(ctx2),
        isAtMax: (ctx2) => ctx2.isAtMax,
        hasHighlightedTag: (ctx2) => ctx2.highlightedTagId !== null,
        isFirstTagHighlighted: (ctx2) => {
          const firstItemId = dom29.getItemId(ctx2, { value: ctx2.value[0], index: 0 });
          return firstItemId === ctx2.highlightedTagId;
        },
        isEditedTagEmpty: (ctx2) => ctx2.editedTagValue.trim() === "",
        isLastTagHighlighted: (ctx2) => {
          const lastIndex = ctx2.value.length - 1;
          const lastItemId = dom29.getItemId(ctx2, { value: ctx2.value[lastIndex], index: lastIndex });
          return lastItemId === ctx2.highlightedTagId;
        },
        isInputValueEmpty: (ctx2) => ctx2.trimmedInputValue.length === 0,
        hasTags: (ctx2) => ctx2.value.length > 0,
        allowOverflow: (ctx2) => !!ctx2.allowOverflow,
        autoFocus: (ctx2) => !!ctx2.autoFocus,
        addOnBlur: (ctx2) => ctx2.blurBehavior === "add",
        clearOnBlur: (ctx2) => ctx2.blurBehavior === "clear",
        addOnPaste: (ctx2) => !!ctx2.addOnPaste,
        isTagEditable: (ctx2) => !!ctx2.editable,
        isInputCaretAtStart(ctx2) {
          const input = dom29.getInputEl(ctx2);
          if (!input)
            return false;
          try {
            return input.selectionStart === 0 && input.selectionEnd === 0;
          } catch (e) {
            return input.value === "";
          }
        }
      },
      activities: {
        trackInteractOutside(ctx2, _evt, { send }) {
          return trackInteractOutside(dom29.getInputEl(ctx2), {
            exclude(target) {
              return contains(dom29.getRootEl(ctx2), target);
            },
            onFocusOutside: ctx2.onFocusOutside,
            onPointerDownOutside: ctx2.onPointerDownOutside,
            onInteractOutside(event) {
              var _a;
              (_a = ctx2.onInteractOutside) == null ? void 0 : _a.call(ctx2, event);
              if (event.defaultPrevented)
                return;
              send({ type: "BLUR", src: "interact-outside" });
            }
          });
        },
        trackFormControlState(ctx2, _evt, { send, initialContext }) {
          return trackFormControl(dom29.getHiddenInputEl(ctx2), {
            onFieldsetDisabledChange(disabled) {
              ctx2.fieldsetDisabled = disabled;
            },
            onFormReset() {
              send({ type: "SET_VALUE", value: initialContext.value, src: "form-reset" });
            }
          });
        },
        autoResize(ctx2) {
          if (!ctx2.editedTagValue || ctx2.idx == null || !ctx2.editable)
            return;
          const input = dom29.getTagInputEl(ctx2, { value: ctx2.editedTagValue, index: ctx2.idx });
          return autoResizeInput(input);
        },
        trackLiveRegion(ctx2) {
          ctx2.liveRegion = createLiveRegion({
            level: "assertive",
            document: dom29.getDoc(ctx2)
          });
          return () => {
            var _a;
            return (_a = ctx2.liveRegion) == null ? void 0 : _a.destroy();
          };
        }
      },
      actions: {
        raiseAddTagEvent(_, __, { self: self2 }) {
          self2.send("ADD_TAG");
        },
        raiseExternalBlurEvent(_, evt, { self: self2 }) {
          self2.send({ type: "EXTERNAL_BLUR", id: evt.id });
        },
        dispatchChangeEvent(ctx2) {
          dom29.dispatchInputEvent(ctx2);
        },
        highlightNextTag(ctx2) {
          if (ctx2.highlightedTagId == null)
            return;
          const next = dom29.getNextEl(ctx2, ctx2.highlightedTagId);
          set21.highlightedId(ctx2, (next == null ? void 0 : next.id) ?? null);
        },
        highlightFirstTag(ctx2) {
          raf(() => {
            const first2 = dom29.getFirstEl(ctx2);
            set21.highlightedId(ctx2, (first2 == null ? void 0 : first2.id) ?? null);
          });
        },
        highlightLastTag(ctx2) {
          const last2 = dom29.getLastEl(ctx2);
          set21.highlightedId(ctx2, (last2 == null ? void 0 : last2.id) ?? null);
        },
        highlightPrevTag(ctx2) {
          if (ctx2.highlightedTagId == null)
            return;
          const prev = dom29.getPrevEl(ctx2, ctx2.highlightedTagId);
          set21.highlightedId(ctx2, (prev == null ? void 0 : prev.id) ?? null);
        },
        highlightTag(ctx2, evt) {
          set21.highlightedId(ctx2, evt.id);
        },
        highlightTagAtIndex(ctx2) {
          raf(() => {
            if (ctx2.idx == null)
              return;
            const tagEl = dom29.getTagElAtIndex(ctx2, ctx2.idx);
            if (tagEl == null)
              return;
            set21.highlightedId(ctx2, tagEl.id);
            ctx2.idx = void 0;
          });
        },
        deleteTag(ctx2, evt) {
          const index = dom29.getIndexOfId(ctx2, evt.id);
          const value = ctx2.value[index];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "delete", value };
          set21.value(ctx2, removeAt(ctx2.value, index));
        },
        deleteHighlightedTag(ctx2) {
          if (ctx2.highlightedTagId == null)
            return;
          const index = dom29.getIndexOfId(ctx2, ctx2.highlightedTagId);
          ctx2.idx = index;
          const value = ctx2.value[index];
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "delete", value };
          set21.value(ctx2, removeAt(ctx2.value, index));
        },
        setEditedId(ctx2, evt) {
          ctx2.editedTagId = evt.id ?? ctx2.highlightedTagId;
          ctx2.idx = dom29.getIndexOfId(ctx2, ctx2.editedTagId);
        },
        clearEditedId(ctx2) {
          ctx2.editedTagId = null;
        },
        clearEditedTagValue(ctx2) {
          ctx2.editedTagValue = "";
        },
        setEditedTagValue(ctx2, evt) {
          ctx2.editedTagValue = evt.value;
        },
        submitEditedTagValue(ctx2) {
          if (!ctx2.editedTagId)
            return;
          const index = dom29.getIndexOfId(ctx2, ctx2.editedTagId);
          set21.valueAtIndex(ctx2, index, ctx2.editedTagValue ?? "");
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "update", value: ctx2.editedTagValue };
        },
        setValueAtIndex(ctx2, evt) {
          if (evt.value) {
            ctx2.value[evt.index] = evt.value;
            ctx2.log.prev = ctx2.log.current;
            ctx2.log.current = { type: "update", value: evt.value };
          } else {
            warn("You need to provide a value for the tag");
          }
        },
        initializeEditedTagValue(ctx2) {
          if (!ctx2.editedTagId)
            return;
          const index = dom29.getIndexOfId(ctx2, ctx2.editedTagId);
          ctx2.editedTagValue = ctx2.value[index];
        },
        focusEditedTagInput(ctx2) {
          raf(() => {
            var _a;
            (_a = dom29.getEditInputEl(ctx2)) == null ? void 0 : _a.select();
          });
        },
        setInputValue(ctx2, evt) {
          set21.inputValue(ctx2, evt.value);
        },
        clearHighlightedId(ctx2) {
          ctx2.highlightedTagId = null;
        },
        focusInput(ctx2) {
          raf(() => {
            var _a;
            (_a = dom29.getInputEl(ctx2)) == null ? void 0 : _a.focus();
          });
        },
        clearInputValue(ctx2) {
          raf(() => {
            set21.inputValue(ctx2, "");
          });
        },
        syncInputValue(ctx2) {
          const inputEl = dom29.getInputEl(ctx2);
          dom29.setValue(inputEl, ctx2.inputValue);
        },
        syncEditedTagInputValue(ctx2, evt) {
          const id = ctx2.editedTagId || ctx2.highlightedTagId || evt.id;
          if (id == null)
            return;
          const editTagInputEl = dom29.getById(ctx2, `${id}:input`);
          dom29.setValue(editTagInputEl, ctx2.editedTagValue);
        },
        addTag(ctx2, evt) {
          var _a, _b;
          const value = evt.value ?? ctx2.trimmedInputValue;
          const guard = (_a = ctx2.validate) == null ? void 0 : _a.call(ctx2, { inputValue: value, value: Array.from(ctx2.value) });
          if (guard) {
            set21.value(ctx2, ctx2.value.concat(value));
            ctx2.log.prev = ctx2.log.current;
            ctx2.log.current = { type: "add", value };
          } else {
            (_b = ctx2.onValueInvalid) == null ? void 0 : _b.call(ctx2, { reason: "invalidTag" });
          }
        },
        addTagFromPaste(ctx2) {
          raf(() => {
            var _a, _b;
            const value = ctx2.trimmedInputValue;
            const guard = (_a = ctx2.validate) == null ? void 0 : _a.call(ctx2, { inputValue: value, value: Array.from(ctx2.value) });
            if (guard) {
              const trimmedValue = ctx2.delimiter ? value.split(ctx2.delimiter).map((v) => v.trim()) : [value];
              set21.value(ctx2, ctx2.value.concat(...trimmedValue));
              ctx2.log.prev = ctx2.log.current;
              ctx2.log.current = { type: "paste", values: trimmedValue };
            } else {
              (_b = ctx2.onValueInvalid) == null ? void 0 : _b.call(ctx2, { reason: "invalidTag" });
            }
            set21.inputValue(ctx2, "");
          });
        },
        clearTags(ctx2) {
          set21.value(ctx2, []);
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "clear" };
        },
        setValue(ctx2, evt) {
          set21.value(ctx2, evt.value);
        },
        invokeOnInvalid(ctx2) {
          var _a;
          if (ctx2.isOverflowing) {
            (_a = ctx2.onValueInvalid) == null ? void 0 : _a.call(ctx2, { reason: "rangeOverflow" });
          }
        },
        clearLog(ctx2) {
          ctx2.log = { prev: null, current: null };
        },
        logHighlightedTag(ctx2) {
          if (ctx2.highlightedTagId == null)
            return;
          const index = dom29.getIndexOfId(ctx2, ctx2.highlightedTagId);
          ctx2.log.prev = ctx2.log.current;
          ctx2.log.current = { type: "select", value: ctx2.value[index] };
        },
        // queue logs with screen reader and get it announced
        announceLog(ctx2) {
          if (!ctx2.log.current || ctx2.liveRegion == null)
            return;
          const region = ctx2.liveRegion;
          const { current, prev } = ctx2.log;
          let msg;
          switch (current.type) {
            case "add":
              msg = ctx2.translations.tagAdded(current.value);
              break;
            case "delete":
              msg = ctx2.translations.tagDeleted(current.value);
              break;
            case "update":
              msg = ctx2.translations.tagUpdated(current.value);
              break;
            case "paste":
              msg = ctx2.translations.tagsPasted(current.values);
              break;
            case "select":
              msg = ctx2.translations.tagSelected(current.value);
              if ((prev == null ? void 0 : prev.type) === "delete") {
                msg = `${ctx2.translations.tagDeleted(prev.value)}. ${msg}`;
              } else if ((prev == null ? void 0 : prev.type) === "update") {
                msg = `${ctx2.translations.tagUpdated(prev.value)}. ${msg}`;
              }
              break;
            default:
              break;
          }
          if (msg)
            region.announce(msg);
        }
      }
    }
  );
}
var invoke17 = {
  change: (ctx) => {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: Array.from(ctx.value) });
    dom29.dispatchInputEvent(ctx);
  },
  highlightChange: (ctx) => {
    var _a;
    const highlightedValue = dom29.getHighlightedTagValue(ctx);
    (_a = ctx.onHighlightChange) == null ? void 0 : _a.call(ctx, { highlightedValue });
  },
  valueChange: (ctx) => {
    var _a;
    (_a = ctx.onInputValueChange) == null ? void 0 : _a.call(ctx, { inputValue: ctx.inputValue });
  }
};
var set21 = {
  value: (ctx, value) => {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke17.change(ctx);
  },
  valueAtIndex: (ctx, index, value) => {
    if (isEqual(ctx.value[index], value))
      return;
    ctx.value[index] = value;
    invoke17.change(ctx);
  },
  highlightedId: (ctx, id) => {
    if (isEqual(ctx.highlightedTagId, id))
      return;
    ctx.highlightedTagId = id;
    invoke17.highlightChange(ctx);
  },
  inputValue: (ctx, value) => {
    if (isEqual(ctx.inputValue, value))
      return;
    ctx.inputValue = value;
    invoke17.valueChange(ctx);
  }
};
var props25 = createProps()([
  "addOnPaste",
  "allowOverflow",
  "autoFocus",
  "blurBehavior",
  "delimiter",
  "dir",
  "disabled",
  "editable",
  "form",
  "getRootNode",
  "id",
  "ids",
  "inputValue",
  "invalid",
  "max",
  "maxLength",
  "name",
  "onFocusOutside",
  "onHighlightChange",
  "onInputValueChange",
  "onInteractOutside",
  "onPointerDownOutside",
  "onValueChange",
  "onValueInvalid",
  "readOnly",
  "translations",
  "validate",
  "value"
]);
var splitProps25 = createSplitProps(props25);
var itemProps8 = createProps()(["index", "disabled", "value"]);
var splitItemProps8 = createSplitProps(itemProps8);

// node_modules/@zag-js/toast/dist/index.mjs
var anatomy36 = createAnatomy("toast").parts(
  "group",
  "root",
  "title",
  "description",
  "actionTrigger",
  "closeTrigger"
);
var parts30 = anatomy36.build();
var dom30 = createScope({
  getRegionId: (placement) => `toast-group:${placement}`,
  getRegionEl: (ctx, placement) => dom30.getById(ctx, `toast-group:${placement}`),
  getRootId: (ctx) => `toast:${ctx.id}`,
  getRootEl: (ctx) => dom30.getById(ctx, dom30.getRootId(ctx)),
  getTitleId: (ctx) => `toast:${ctx.id}:title`,
  getDescriptionId: (ctx) => `toast:${ctx.id}:description`,
  getCloseTriggerId: (ctx) => `toast${ctx.id}:close`
});
function getToastsByPlacement(toasts, placement) {
  return toasts.filter((toast) => toast.state.context.placement === placement);
}
var defaultTimeouts = {
  info: 5e3,
  error: 5e3,
  success: 2e3,
  loading: Infinity,
  DEFAULT: 5e3
};
function getToastDuration(duration, type) {
  return duration ?? defaultTimeouts[type] ?? defaultTimeouts.DEFAULT;
}
function getGroupPlacementStyle(ctx, placement) {
  var _a;
  const offset3 = ctx.offsets;
  const computedOffset = typeof offset3 === "string" ? { left: offset3, right: offset3, bottom: offset3, top: offset3 } : offset3;
  const rtl = ctx.dir === "rtl";
  const computedPlacement = placement.replace("-start", rtl ? "-right" : "-left").replace("-end", rtl ? "-left" : "-right");
  const isRighty = computedPlacement.includes("right");
  const isLefty = computedPlacement.includes("left");
  const styles = {
    position: "fixed",
    pointerEvents: ctx.count > 0 ? void 0 : "none",
    display: "flex",
    flexDirection: "column",
    "--gap": `${ctx.gap}px`,
    "--first-height": `${((_a = ctx.heights[0]) == null ? void 0 : _a.height) || 0}px`,
    zIndex: MAX_Z_INDEX
  };
  let alignItems = "center";
  if (isRighty)
    alignItems = "flex-end";
  if (isLefty)
    alignItems = "flex-start";
  styles.alignItems = alignItems;
  if (computedPlacement.includes("top")) {
    const offset22 = computedOffset.top;
    styles.top = `max(env(safe-area-inset-top, 0px), ${offset22})`;
  }
  if (computedPlacement.includes("bottom")) {
    const offset22 = computedOffset.bottom;
    styles.bottom = `max(env(safe-area-inset-bottom, 0px), ${offset22})`;
  }
  if (!computedPlacement.includes("left")) {
    const offset22 = computedOffset.right;
    styles.insetInlineEnd = `calc(env(safe-area-inset-right, 0px) + ${offset22})`;
  }
  if (!computedPlacement.includes("right")) {
    const offset22 = computedOffset.left;
    styles.insetInlineStart = `calc(env(safe-area-inset-left, 0px) + ${offset22})`;
  }
  return styles;
}
function getPlacementStyle(ctx, visible) {
  const [side] = ctx.placement.split("-");
  const sibling = !ctx.frontmost;
  const overlap = !ctx.stacked;
  const styles = {
    position: "absolute",
    pointerEvents: "auto",
    "--opacity": "0",
    "--remove-delay": `${ctx.removeDelay}ms`,
    "--duration": `${ctx.type === "loading" ? Number.MAX_SAFE_INTEGER : ctx.duration}ms`,
    "--initial-height": `${ctx.height}px`,
    "--offset": `${ctx.offset}px`,
    "--index": ctx.index,
    "--z-index": ctx.zIndex,
    "--lift-amount": "calc(var(--lift) * var(--gap))",
    "--y": "100%",
    "--x": "0"
  };
  const assign = (overrides) => Object.assign(styles, overrides);
  if (side === "top") {
    assign({
      top: "0",
      "--sign": "-1",
      "--y": "-100%",
      "--lift": "1"
    });
  } else if (side === "bottom") {
    assign({
      bottom: "0",
      "--sign": "1",
      "--y": "100%",
      "--lift": "-1"
    });
  }
  if (ctx.mounted) {
    assign({
      "--y": "0",
      "--opacity": "1"
    });
    if (ctx.stacked) {
      assign({
        "--y": "calc(var(--lift) * var(--offset))",
        "--height": "var(--initial-height)"
      });
    }
  }
  if (!visible) {
    assign({
      "--opacity": "0",
      pointerEvents: "none"
    });
  }
  if (sibling && overlap) {
    assign({
      "--base-scale": "var(--index) * 0.05 + 1",
      "--y": "calc(var(--lift-amount) * var(--index))",
      "--scale": "calc(-1 * var(--base-scale))",
      "--height": "var(--first-height)"
    });
    if (!visible) {
      assign({
        "--y": "calc(var(--sign) * 40%)"
      });
    }
  }
  if (sibling && ctx.stacked && !visible) {
    assign({
      "--y": "calc(var(--lift) * var(--offset) + var(--lift) * -100%)"
    });
  }
  if (ctx.frontmost && !visible) {
    assign({
      "--y": "calc(var(--lift) * -100%)"
    });
  }
  return styles;
}
function getGhostBeforeStyle(ctx, visible) {
  const styles = {
    position: "absolute",
    inset: "0",
    scale: "1 2",
    pointerEvents: visible ? "none" : "auto"
  };
  const assign = (overrides) => Object.assign(styles, overrides);
  if (ctx.frontmost && !visible) {
    assign({
      height: "calc(var(--initial-height) + 80%)"
    });
  }
  return styles;
}
function getGhostAfterStyle(_ctx, _visible) {
  return {
    position: "absolute",
    left: "0",
    height: "calc(var(--gap) + 2px)",
    bottom: "100%",
    width: "100%"
  };
}
function groupConnect(serviceOrState, send, normalize) {
  function getState() {
    const result = isMachine(serviceOrState) ? serviceOrState.getState() : serviceOrState;
    return result;
  }
  function getToastsByPlacementImpl(placement) {
    return getToastsByPlacement(getState().context.toasts, placement);
  }
  function isVisible2(id) {
    const toasts = getState().context.toasts;
    if (!toasts.length)
      return false;
    return !!toasts.find((toast) => toast.id == id);
  }
  function create(options) {
    const uid = `toast:${uuid()}`;
    const id = options.id ? options.id : uid;
    if (isVisible2(id))
      return id;
    send({ type: "ADD_TOAST", toast: { ...options, id } });
    return id;
  }
  function update(id, options) {
    if (!isVisible2(id))
      return id;
    send({ type: "UPDATE_TOAST", id, toast: options });
    return id;
  }
  function upsert(options) {
    const { id } = options;
    const visible = id ? isVisible2(id) : false;
    if (visible && id != null) {
      return update(id, options);
    } else {
      return create(options);
    }
  }
  function dismiss(id) {
    if (id == null) {
      send("DISMISS_ALL");
    } else if (isVisible2(id)) {
      send({ type: "DISMISS_TOAST", id });
    }
  }
  return {
    getCount() {
      return getState().context.count;
    },
    getPlacements() {
      const toasts = getState().context.toasts;
      const placements2 = toasts.map((toast) => toast.state.context.placement);
      return Array.from(new Set(placements2));
    },
    getToastsByPlacement: getToastsByPlacementImpl,
    isVisible: isVisible2,
    create,
    update,
    upsert,
    dismiss,
    remove(id) {
      if (id == null) {
        send("REMOVE_ALL");
      } else if (isVisible2(id)) {
        send({ type: "REMOVE_TOAST", id });
      }
    },
    dismissByPlacement(placement) {
      const toasts = getToastsByPlacementImpl(placement);
      toasts.forEach((toast) => dismiss(toast.id));
    },
    loading(options) {
      return upsert({ ...options, type: "loading" });
    },
    success(options) {
      return upsert({ ...options, type: "success" });
    },
    error(options) {
      return upsert({ ...options, type: "error" });
    },
    promise(promise, options, shared = {}) {
      const id = upsert({ ...shared, ...options.loading, type: "loading" });
      runIfFn(promise).then((response) => {
        const successOptions = runIfFn(options.success, response);
        upsert({ ...shared, ...successOptions, id, type: "success" });
      }).catch((error) => {
        const errorOptions = runIfFn(options.error, error);
        upsert({ ...shared, ...errorOptions, id, type: "error" });
      }).finally(() => {
        var _a;
        (_a = options.finally) == null ? void 0 : _a.call(options);
      });
      return id;
    },
    pause(id) {
      if (id == null) {
        send("PAUSE_ALL");
      } else if (isVisible2(id)) {
        send({ type: "PAUSE_TOAST", id });
      }
    },
    resume(id) {
      if (id == null) {
        send("RESUME_ALL");
      } else if (isVisible2(id)) {
        send({ type: "RESUME_TOAST", id });
      }
    },
    getGroupProps(options) {
      const { placement, label = "Notifications" } = options;
      const state2 = getState();
      const hotkeyLabel = state2.context.hotkey.join("+").replace(/Key/g, "").replace(/Digit/g, "");
      const [side, align = "center"] = placement.split("-");
      return normalize.element({
        ...parts30.group.attrs,
        dir: state2.context.dir,
        tabIndex: -1,
        "aria-label": `${placement} ${label} ${hotkeyLabel}`,
        id: dom30.getRegionId(placement),
        "data-placement": placement,
        "data-side": side,
        "data-align": align,
        "aria-live": "polite",
        role: "region",
        style: getGroupPlacementStyle(state2.context, placement),
        onMouseMove() {
          send({ type: "REGION.POINTER_ENTER", placement });
        },
        onMouseLeave() {
          send({ type: "REGION.POINTER_LEAVE", placement });
        },
        onFocus(event) {
          send({ type: "REGION.FOCUS", target: event.relatedTarget });
        },
        onBlur(event) {
          if (state2.context.isFocusWithin && !contains(event.currentTarget, event.relatedTarget)) {
            send({ type: "REGION.BLUR" });
          }
        }
      });
    },
    subscribe(fn) {
      const state2 = getState();
      return subscribe(state2.context.toasts, () => {
        const toasts = getToastsByPlacementImpl(state2.context.placement);
        const contexts = toasts.map((toast) => toast.getState().context);
        fn(contexts);
      });
    }
  };
}
var { not: not14, and: and11, or: or5 } = guards;
function createToastMachine(options) {
  const { type = "info", duration, id = "1", placement = "bottom", removeDelay = 200, ...restProps } = options;
  const ctx = compact(restProps);
  const computedDuration = getToastDuration(duration, type);
  return createMachine(
    {
      id,
      context: {
        id,
        type,
        remaining: computedDuration,
        duration: computedDuration,
        removeDelay,
        createdAt: Date.now(),
        placement,
        ...ctx,
        height: 0,
        offset: 0,
        frontmost: false,
        mounted: false,
        index: -1,
        zIndex: 0
      },
      initial: type === "loading" ? "visible:persist" : "visible",
      on: {
        UPDATE: [
          {
            guard: and11("hasTypeChanged", "isChangingToLoading"),
            target: "visible:persist",
            actions: ["setContext"]
          },
          {
            guard: or5("hasDurationChanged", "hasTypeChanged"),
            target: "visible:updating",
            actions: ["setContext"]
          },
          {
            actions: ["setContext"]
          }
        ],
        MEASURE: {
          actions: ["measureHeight"]
        }
      },
      entry: ["invokeOnVisible"],
      activities: ["trackHeight"],
      states: {
        "visible:updating": {
          tags: ["visible", "updating"],
          after: {
            0: "visible"
          }
        },
        "visible:persist": {
          tags: ["visible", "paused"],
          on: {
            RESUME: {
              guard: not14("isLoadingType"),
              target: "visible",
              actions: ["setCreatedAt"]
            },
            DISMISS: "dismissing"
          }
        },
        visible: {
          tags: ["visible"],
          after: {
            VISIBLE_DURATION: "dismissing"
          },
          on: {
            DISMISS: "dismissing",
            PAUSE: {
              target: "visible:persist",
              actions: "setRemainingDuration"
            }
          }
        },
        dismissing: {
          entry: "invokeOnDismiss",
          after: {
            REMOVE_DELAY: {
              target: "unmounted",
              actions: "notifyParentToRemove"
            }
          }
        },
        unmounted: {
          entry: "invokeOnUnmount",
          type: "final"
        }
      }
    },
    {
      activities: {
        trackHeight(ctx2, _evt, { self: self2 }) {
          let cleanup;
          raf(() => {
            const rootEl = dom30.getRootEl(ctx2);
            if (!rootEl)
              return;
            ctx2.mounted = true;
            const ghosts = queryAll(rootEl, "[data-ghost]");
            warn(
              ghosts.length !== 2,
              "[toast] No ghost element found in toast. Render the `ghostBefore` and `ghostAfter` elements"
            );
            const syncHeight = () => {
              const originalHeight = rootEl.style.height;
              rootEl.style.height = "auto";
              const newHeight = rootEl.getBoundingClientRect().height;
              rootEl.style.height = originalHeight;
              ctx2.height = newHeight;
              self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
            };
            syncHeight();
            const win = dom30.getWin(ctx2);
            const observer = new win.MutationObserver(syncHeight);
            observer.observe(rootEl, { childList: true, subtree: true, characterData: true });
            cleanup = () => observer.disconnect();
          });
          return () => cleanup == null ? void 0 : cleanup();
        }
      },
      guards: {
        isChangingToLoading: (_, evt) => {
          var _a;
          return ((_a = evt.toast) == null ? void 0 : _a.type) === "loading";
        },
        isLoadingType: (ctx2) => ctx2.type === "loading",
        hasTypeChanged: (ctx2, evt) => {
          var _a;
          return ((_a = evt.toast) == null ? void 0 : _a.type) != null && evt.toast.type !== ctx2.type;
        },
        hasDurationChanged: (ctx2, evt) => {
          var _a;
          return ((_a = evt.toast) == null ? void 0 : _a.duration) != null && evt.toast.duration !== ctx2.duration;
        }
      },
      delays: {
        VISIBLE_DURATION: (ctx2) => ctx2.remaining,
        REMOVE_DELAY: (ctx2) => ctx2.removeDelay
      },
      actions: {
        measureHeight(ctx2, _evt, { self: self2 }) {
          raf(() => {
            const rootEl = dom30.getRootEl(ctx2);
            if (!rootEl)
              return;
            ctx2.mounted = true;
            const originalHeight = rootEl.style.height;
            rootEl.style.height = "auto";
            const newHeight = rootEl.getBoundingClientRect().height;
            rootEl.style.height = originalHeight;
            ctx2.height = newHeight;
            self2.sendParent({ type: "UPDATE_HEIGHT", id: self2.id, height: newHeight, placement: ctx2.placement });
          });
        },
        setRemainingDuration(ctx2) {
          ctx2.remaining -= Date.now() - ctx2.createdAt;
        },
        setCreatedAt(ctx2) {
          ctx2.createdAt = Date.now();
        },
        notifyParentToRemove(_ctx, _evt, { self: self2 }) {
          self2.sendParent({ type: "REMOVE_TOAST", id: self2.id });
        },
        invokeOnDismiss(ctx2) {
          var _a;
          (_a = ctx2.onStatusChange) == null ? void 0 : _a.call(ctx2, { status: "dismissing" });
        },
        invokeOnUnmount(ctx2) {
          var _a;
          (_a = ctx2.onStatusChange) == null ? void 0 : _a.call(ctx2, { status: "unmounted" });
        },
        invokeOnVisible(ctx2) {
          var _a;
          (_a = ctx2.onStatusChange) == null ? void 0 : _a.call(ctx2, { status: "visible" });
        },
        setContext(ctx2, evt) {
          var _a, _b;
          const duration2 = (_a = evt.toast) == null ? void 0 : _a.duration;
          const type2 = ((_b = evt.toast) == null ? void 0 : _b.type) ?? ctx2.type;
          const computedDuration2 = getToastDuration(duration2, type2);
          Object.assign(ctx2, {
            ...evt.toast,
            duration: computedDuration2,
            remaining: computedDuration2
          });
        }
      }
    }
  );
}
function groupMachine(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "toaster",
      initial: ctx.overlap ? "overlap" : "stack",
      context: {
        dir: "ltr",
        max: Number.MAX_SAFE_INTEGER,
        gap: 16,
        pauseOnPageIdle: false,
        hotkey: ["altKey", "KeyT"],
        offsets: "1rem",
        placement: "bottom",
        removeDelay: 200,
        ...ctx,
        toasts: [],
        lastFocusedEl: null,
        isFocusWithin: false,
        heights: []
      },
      computed: {
        count: (ctx2) => ctx2.toasts.length
      },
      activities: ["trackDocumentVisibility", "trackHotKeyPress"],
      watch: {
        toasts: ["collapsedIfEmpty", "setDismissableBranch"]
      },
      exit: ["removeToasts", "clearDismissableBranch", "clearLastFocusedEl"],
      on: {
        PAUSE_TOAST: {
          actions: ["pauseToast"]
        },
        PAUSE_ALL: {
          actions: ["pauseToasts"]
        },
        RESUME_TOAST: {
          actions: ["resumeToast"]
        },
        RESUME_ALL: {
          actions: ["resumeToasts"]
        },
        ADD_TOAST: {
          guard: "isWithinRange",
          actions: ["createToast", "syncToastIndex"]
        },
        UPDATE_TOAST: {
          actions: ["updateToast"]
        },
        DISMISS_TOAST: {
          actions: ["dismissToast"]
        },
        DISMISS_ALL: {
          actions: ["dismissToasts"]
        },
        REMOVE_TOAST: {
          actions: ["removeToast", "syncToastIndex", "syncToastOffset"]
        },
        REMOVE_ALL: {
          actions: ["removeToasts"]
        },
        UPDATE_HEIGHT: {
          actions: ["syncHeights", "syncToastOffset"]
        },
        "DOC.HOTKEY": {
          actions: ["focusRegionEl"]
        },
        "REGION.BLUR": [
          {
            guard: "isOverlapping",
            target: "overlap",
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          },
          {
            actions: ["resumeToasts", "restoreLastFocusedEl"]
          }
        ]
      },
      states: {
        stack: {
          entry: ["expandToasts"],
          on: {
            "REGION.POINTER_LEAVE": [
              {
                guard: "isOverlapping",
                target: "overlap",
                actions: ["resumeToasts"]
              },
              {
                actions: ["resumeToasts"]
              }
            ],
            "REGION.OVERLAP": {
              target: "overlap"
            },
            "REGION.FOCUS": {
              actions: ["setLastFocusedEl", "pauseToasts"]
            },
            "REGION.POINTER_ENTER": {
              actions: ["pauseToasts"]
            }
          }
        },
        overlap: {
          entry: ["collapseToasts"],
          on: {
            "REGION.STACK": {
              target: "stack"
            },
            "REGION.POINTER_ENTER": {
              target: "stack",
              actions: ["pauseToasts"]
            },
            "REGION.FOCUS": {
              target: "stack",
              actions: ["setLastFocusedEl", "pauseToasts"]
            }
          }
        }
      }
    },
    {
      guards: {
        isWithinRange: (ctx2) => ctx2.toasts.length < ctx2.max,
        isOverlapping: (ctx2) => !!ctx2.overlap
      },
      activities: {
        trackHotKeyPress(ctx2, _evt, { send }) {
          const handleKeyDown = (event) => {
            const isHotkeyPressed = ctx2.hotkey.every((key) => event[key] || event.code === key);
            if (!isHotkeyPressed)
              return;
            send({ type: "DOC.HOTKEY" });
          };
          return addDomEvent(document, "keydown", handleKeyDown, { capture: true });
        },
        trackDocumentVisibility(ctx2, _evt, { send }) {
          if (!ctx2.pauseOnPageIdle)
            return;
          const doc = dom30.getDoc(ctx2);
          return addDomEvent(doc, "visibilitychange", () => {
            send(doc.visibilityState === "hidden" ? "PAUSE_ALL" : "RESUME_ALL");
          });
        }
      },
      actions: {
        setDismissableBranch(ctx2) {
          var _a;
          const currentToasts = getToastsByPlacement(ctx2.toasts, ctx2.placement);
          const hasToasts = currentToasts.length > 0;
          if (!hasToasts) {
            (_a = ctx2._cleanup) == null ? void 0 : _a.call(ctx2);
            return;
          }
          if (hasToasts && ctx2._cleanup) {
            return;
          }
          const groupEl = () => dom30.getRegionEl(ctx2, ctx2.placement);
          ctx2._cleanup = trackDismissableBranch(groupEl, { defer: true });
        },
        clearDismissableBranch(ctx2) {
          var _a;
          (_a = ctx2._cleanup) == null ? void 0 : _a.call(ctx2);
        },
        focusRegionEl(ctx2) {
          queueMicrotask(() => {
            var _a;
            (_a = dom30.getRegionEl(ctx2, ctx2.placement)) == null ? void 0 : _a.focus();
          });
        },
        expandToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = true;
          });
        },
        collapseToasts(ctx2) {
          each(ctx2, (toast) => {
            toast.state.context.stacked = false;
          });
        },
        collapsedIfEmpty(ctx2, _evt, { send }) {
          if (!ctx2.overlap || ctx2.toasts.length > 1)
            return;
          send("REGION.OVERLAP");
        },
        pauseToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("PAUSE", evt.id);
        },
        pauseToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("PAUSE"));
        },
        resumeToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("RESUME", evt.id);
        },
        resumeToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("RESUME"));
        },
        measureToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("MEASURE"));
        },
        createToast(ctx2, evt, { self: self2, getState }) {
          const options = {
            placement: ctx2.placement,
            duration: ctx2.duration,
            removeDelay: ctx2.removeDelay,
            ...evt.toast,
            dir: ctx2.dir,
            getRootNode: ctx2.getRootNode,
            stacked: getState().matches("stack")
          };
          const toast = createToastMachine(options);
          const actor = self2.spawn(toast);
          ctx2.toasts = [actor, ...ctx2.toasts];
        },
        updateToast(_ctx, evt, { self: self2 }) {
          self2.sendChild({ type: "UPDATE", toast: evt.toast }, evt.id);
        },
        dismissToast(_ctx, evt, { self: self2 }) {
          self2.sendChild("DISMISS", evt.id);
        },
        dismissToasts(ctx2) {
          ctx2.toasts.forEach((toast) => toast.send("DISMISS"));
        },
        removeToast(ctx2, evt, { self: self2 }) {
          self2.stopChild(evt.id);
          ctx2.toasts = ctx2.toasts.filter((toast) => toast.id !== evt.id);
          ctx2.heights = ctx2.heights.filter((height) => height.id !== evt.id);
        },
        removeToasts(ctx2, _evt, { self: self2 }) {
          ctx2.toasts.forEach((toast) => self2.stopChild(toast.id));
          ctx2.toasts = [];
          ctx2.heights = [];
        },
        syncHeights(ctx2, evt) {
          const existing = ctx2.heights.find((height) => height.id === evt.id);
          if (existing) {
            existing.height = evt.height;
            existing.placement = evt.placement;
          } else {
            const newHeight = { id: evt.id, height: evt.height, placement: evt.placement };
            ctx2.heights = [newHeight, ...ctx2.heights];
          }
        },
        syncToastIndex(ctx2) {
          each(ctx2, (toast, index, toasts) => {
            toast.state.context.index = index;
            toast.state.context.frontmost = index === 0;
            toast.state.context.zIndex = toasts.length - index;
          });
        },
        syncToastOffset(ctx2, evt) {
          const placement = evt.placement ?? ctx2.placement;
          each({ ...ctx2, placement }, (toast) => {
            const heightIndex = Math.max(
              ctx2.heights.findIndex((height) => height.id === toast.id),
              0
            );
            const toastsHeightBefore = ctx2.heights.reduce((prev, curr, reducerIndex) => {
              if (reducerIndex >= heightIndex)
                return prev;
              return prev + curr.height;
            }, 0);
            toast.state.context.offset = heightIndex * ctx2.gap + toastsHeightBefore;
          });
        },
        setLastFocusedEl(ctx2, evt) {
          if (ctx2.isFocusWithin || !evt.target)
            return;
          ctx2.isFocusWithin = true;
          ctx2.lastFocusedEl = ref(evt.target);
        },
        restoreLastFocusedEl(ctx2) {
          ctx2.isFocusWithin = false;
          if (!ctx2.lastFocusedEl)
            return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
        },
        clearLastFocusedEl(ctx2) {
          if (!ctx2.lastFocusedEl)
            return;
          ctx2.lastFocusedEl.focus({ preventScroll: true });
          ctx2.lastFocusedEl = null;
          ctx2.isFocusWithin = false;
        }
      }
    }
  );
}
function each(ctx, fn) {
  const currentToasts = getToastsByPlacement(ctx.toasts, ctx.placement);
  currentToasts.forEach(fn);
}
function connect30(state2, send, normalize) {
  const visible = state2.hasTag("visible");
  const paused = state2.hasTag("paused");
  const placement = state2.context.placement;
  const type = state2.context.type;
  const [side, align = "center"] = placement.split("-");
  return {
    type,
    title: state2.context.title,
    description: state2.context.description,
    placement,
    visible,
    paused,
    pause() {
      send("PAUSE");
    },
    resume() {
      send("RESUME");
    },
    dismiss() {
      send("DISMISS");
    },
    getRootProps() {
      return normalize.element({
        ...parts30.root.attrs,
        dir: state2.context.dir,
        id: dom30.getRootId(state2.context),
        "data-state": visible ? "open" : "closed",
        "data-type": type,
        "data-placement": placement,
        "data-align": align,
        "data-side": side,
        "data-mounted": dataAttr(state2.context.mounted),
        "data-paused": dataAttr(paused),
        "data-first": dataAttr(state2.context.frontmost),
        "data-sibling": dataAttr(!state2.context.frontmost),
        "data-stack": dataAttr(state2.context.stacked),
        "data-overlap": dataAttr(!state2.context.stacked),
        role: "status",
        "aria-atomic": "true",
        tabIndex: 0,
        style: getPlacementStyle(state2.context, visible),
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (event.key == "Escape") {
            send("DISMISS");
            event.preventDefault();
          }
        }
      });
    },
    /* Leave a ghost div to avoid setting hover to false when transitioning out */
    getGhostBeforeProps() {
      return normalize.element({
        "data-ghost": "before",
        style: getGhostBeforeStyle(state2.context, visible)
      });
    },
    /* Needed to avoid setting hover to false when in between toasts */
    getGhostAfterProps() {
      return normalize.element({
        "data-ghost": "after",
        style: getGhostAfterStyle(state2.context, visible)
      });
    },
    getTitleProps() {
      return normalize.element({
        ...parts30.title.attrs,
        id: dom30.getTitleId(state2.context)
      });
    },
    getDescriptionProps() {
      return normalize.element({
        ...parts30.description.attrs,
        id: dom30.getDescriptionId(state2.context)
      });
    },
    getActionTriggerProps() {
      return normalize.button({
        ...parts30.actionTrigger.attrs,
        type: "button",
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("DISMISS");
        }
      });
    },
    getCloseTriggerProps() {
      return normalize.button({
        id: dom30.getCloseTriggerId(state2.context),
        ...parts30.closeTrigger.attrs,
        type: "button",
        "aria-label": "Dismiss notification",
        onClick(event) {
          if (event.defaultPrevented)
            return;
          send("DISMISS");
        }
      });
    }
  };
}
var group = {
  connect: groupConnect,
  machine: groupMachine
};

// node_modules/@zag-js/toggle-group/dist/index.mjs
var anatomy37 = createAnatomy("toggle-group").parts("root", "item");
var parts31 = anatomy37.build();
var dom31 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `toggle-group:${ctx.id}`;
  },
  getItemId: (ctx, value) => {
    var _a, _b;
    return ((_b = (_a = ctx.ids) == null ? void 0 : _a.item) == null ? void 0 : _b.call(_a, value)) ?? `toggle-group:${ctx.id}:${value}`;
  },
  getRootEl: (ctx) => dom31.getById(ctx, dom31.getRootId(ctx)),
  getElements: (ctx) => {
    const ownerId = CSS.escape(dom31.getRootId(ctx));
    const selector = `[data-ownedby='${ownerId}']:not([data-disabled])`;
    return queryAll(dom31.getRootEl(ctx), selector);
  },
  getFirstEl: (ctx) => first(dom31.getElements(ctx)),
  getLastEl: (ctx) => last(dom31.getElements(ctx)),
  getNextEl: (ctx, id) => nextById(dom31.getElements(ctx), id, ctx.currentLoopFocus),
  getPrevEl: (ctx, id) => prevById(dom31.getElements(ctx), id, ctx.currentLoopFocus)
});
function connect31(state2, send, normalize) {
  const value = state2.context.value;
  const disabled = state2.context.disabled;
  const isSingle = !state2.context.multiple;
  const rovingFocus = state2.context.rovingFocus;
  const isHorizontal = state2.context.orientation === "horizontal";
  function getItemState(props29) {
    const id = dom31.getItemId(state2.context, props29.value);
    return {
      id,
      disabled: Boolean(props29.disabled || disabled),
      pressed: !!value.includes(props29.value),
      focused: state2.context.focusedId === id
    };
  }
  return {
    value,
    setValue(value2) {
      send({ type: "VALUE.SET", value: value2 });
    },
    getRootProps() {
      return normalize.element({
        ...parts31.root.attrs,
        id: dom31.getRootId(state2.context),
        dir: state2.context.dir,
        role: isSingle ? "radiogroup" : "group",
        tabIndex: state2.context.isTabbingBackward ? -1 : 0,
        "data-disabled": dataAttr(disabled),
        "data-orientation": state2.context.orientation,
        "data-focus": dataAttr(state2.context.focusedId != null),
        style: { outline: "none" },
        onMouseDown() {
          if (disabled)
            return;
          send("ROOT.MOUSE_DOWN");
        },
        onFocus(event) {
          if (disabled)
            return;
          const evt = event.nativeEvent || event;
          if (!isSelfTarget(evt) || !!state2.context.isClickFocus || state2.context.isTabbingBackward)
            return;
          send("ROOT.FOCUS");
        },
        onBlur() {
          if (disabled)
            return;
          send("ROOT.BLUR");
        }
      });
    },
    getItemState,
    getItemProps(props29) {
      const itemState = getItemState(props29);
      const rovingTabIndex = itemState.focused ? 0 : -1;
      return normalize.button({
        ...parts31.item.attrs,
        id: itemState.id,
        type: "button",
        "data-ownedby": dom31.getRootId(state2.context),
        "data-focus": dataAttr(itemState.focused),
        disabled: itemState.disabled,
        tabIndex: rovingFocus ? rovingTabIndex : void 0,
        // radio
        role: isSingle ? "radio" : void 0,
        "aria-checked": isSingle ? itemState.pressed : void 0,
        "aria-pressed": isSingle ? void 0 : itemState.pressed,
        //
        "data-disabled": dataAttr(itemState.disabled),
        "data-orientation": state2.context.orientation,
        dir: state2.context.dir,
        "data-state": itemState.pressed ? "on" : "off",
        onFocus() {
          if (itemState.disabled)
            return;
          send({ type: "TOGGLE.FOCUS", id: itemState.id });
        },
        onClick(event) {
          if (itemState.disabled)
            return;
          send({ type: "TOGGLE.CLICK", id: itemState.id, value: props29.value });
          if (isSafari()) {
            event.currentTarget.focus({ preventScroll: true });
          }
        },
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (!isSelfTarget(event))
            return;
          if (itemState.disabled)
            return;
          const keyMap2 = {
            Tab(event2) {
              const isShiftTab = event2.shiftKey;
              send({ type: "TOGGLE.SHIFT_TAB", isShiftTab });
            },
            ArrowLeft() {
              if (!rovingFocus || !isHorizontal)
                return;
              send("TOGGLE.FOCUS_PREV");
            },
            ArrowRight() {
              if (!rovingFocus || !isHorizontal)
                return;
              send("TOGGLE.FOCUS_NEXT");
            },
            ArrowUp() {
              if (!rovingFocus || isHorizontal)
                return;
              send("TOGGLE.FOCUS_PREV");
            },
            ArrowDown() {
              if (!rovingFocus || isHorizontal)
                return;
              send("TOGGLE.FOCUS_NEXT");
            },
            Home() {
              if (!rovingFocus)
                return;
              send("TOGGLE.FOCUS_FIRST");
            },
            End() {
              if (!rovingFocus)
                return;
              send("TOGGLE.FOCUS_LAST");
            }
          };
          const exec2 = keyMap2[getEventKey(event)];
          if (exec2) {
            exec2(event);
            if (event.key !== "Tab")
              event.preventDefault();
          }
        }
      });
    }
  };
}
var { not: not15, and: and12 } = guards;
function machine30(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "toggle-group",
      initial: "idle",
      context: {
        value: [],
        disabled: false,
        orientation: "horizontal",
        rovingFocus: true,
        loopFocus: true,
        ...ctx,
        focusedId: null,
        isTabbingBackward: false,
        isClickFocus: false,
        isWithinToolbar: false
      },
      computed: {
        currentLoopFocus: (ctx2) => ctx2.loopFocus && !ctx2.isWithinToolbar
      },
      entry: ["checkIfWithinToolbar"],
      on: {
        "VALUE.SET": {
          actions: ["setValue"]
        },
        "TOGGLE.CLICK": {
          actions: ["setValue"]
        },
        "ROOT.MOUSE_DOWN": {
          actions: ["setClickFocus"]
        }
      },
      states: {
        idle: {
          on: {
            "ROOT.FOCUS": {
              target: "focused",
              guard: not15(and12("isClickFocus", "isTabbingBackward")),
              actions: ["focusFirstToggle", "clearClickFocus"]
            },
            "TOGGLE.FOCUS": {
              target: "focused",
              actions: ["setFocusedId"]
            }
          }
        },
        focused: {
          on: {
            "ROOT.BLUR": {
              target: "idle",
              actions: ["clearIsTabbingBackward"]
            },
            "TOGGLE.FOCUS": {
              actions: ["setFocusedId"]
            },
            "TOGGLE.FOCUS_NEXT": {
              actions: ["focusNextToggle"]
            },
            "TOGGLE.FOCUS_PREV": {
              actions: ["focusPrevToggle"]
            },
            "TOGGLE.FOCUS_FIRST": {
              actions: ["focusFirstToggle"]
            },
            "TOGGLE.FOCUS_LAST": {
              actions: ["focusLastToggle"]
            },
            "TOGGLE.SHIFT_TAB": {
              target: "idle",
              actions: ["setIsTabbingBackward"]
            }
          }
        }
      }
    },
    {
      guards: {
        isClickFocus: (ctx2) => ctx2.isClickFocus,
        isTabbingBackward: (ctx2) => ctx2.isTabbingBackward
      },
      actions: {
        setIsTabbingBackward(ctx2) {
          ctx2.isTabbingBackward = true;
        },
        clearIsTabbingBackward(ctx2) {
          ctx2.isTabbingBackward = false;
        },
        setClickFocus(ctx2) {
          ctx2.isClickFocus = true;
        },
        clearClickFocus(ctx2) {
          ctx2.isClickFocus = false;
        },
        checkIfWithinToolbar(ctx2) {
          var _a;
          const closestToolbar = (_a = dom31.getRootEl(ctx2)) == null ? void 0 : _a.closest("[role=toolbar]");
          ctx2.isWithinToolbar = !!closestToolbar;
        },
        setFocusedId(ctx2, evt) {
          ctx2.focusedId = evt.id;
        },
        clearFocusedId(ctx2) {
          ctx2.focusedId = null;
        },
        setValue(ctx2, evt) {
          if (!evt.value)
            return;
          let next = Array.from(ctx2.value);
          if (ctx2.multiple) {
            next = next.includes(evt.value) ? remove(next, evt.value) : add(next, evt.value);
          } else {
            next = isEqual(ctx2.value, [evt.value]) ? [] : [evt.value];
          }
          set22.value(ctx2, next);
        },
        focusNextToggle(ctx2) {
          raf(() => {
            var _a;
            if (!ctx2.focusedId)
              return;
            (_a = dom31.getNextEl(ctx2, ctx2.focusedId)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        focusPrevToggle(ctx2) {
          raf(() => {
            var _a;
            if (!ctx2.focusedId)
              return;
            (_a = dom31.getPrevEl(ctx2, ctx2.focusedId)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        focusFirstToggle(ctx2) {
          raf(() => {
            var _a;
            (_a = dom31.getFirstEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        },
        focusLastToggle(ctx2) {
          raf(() => {
            var _a;
            (_a = dom31.getLastEl(ctx2)) == null ? void 0 : _a.focus({ preventScroll: true });
          });
        }
      }
    }
  );
}
var invoke18 = {
  change(ctx) {
    var _a;
    (_a = ctx.onValueChange) == null ? void 0 : _a.call(ctx, { value: Array.from(ctx.value) });
  }
};
var set22 = {
  value(ctx, value) {
    if (isEqual(ctx.value, value))
      return;
    ctx.value = value;
    invoke18.change(ctx);
  }
};
var props26 = createProps()([
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "loopFocus",
  "multiple",
  "onValueChange",
  "orientation",
  "rovingFocus",
  "value"
]);
var splitProps26 = createSplitProps(props26);
var itemProps9 = createProps()(["value", "disabled"]);
var splitItemProps9 = createSplitProps(itemProps9);

// node_modules/@zag-js/tooltip/dist/index.mjs
var anatomy38 = createAnatomy("tooltip").parts("trigger", "arrow", "arrowTip", "positioner", "content");
var parts32 = anatomy38.build();
var dom32 = createScope({
  getTriggerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.trigger) ?? `tooltip:${ctx.id}:trigger`;
  },
  getContentId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.content) ?? `tooltip:${ctx.id}:content`;
  },
  getArrowId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.arrow) ?? `tooltip:${ctx.id}:arrow`;
  },
  getPositionerId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.positioner) ?? `tooltip:${ctx.id}:popper`;
  },
  getTriggerEl: (ctx) => dom32.getById(ctx, dom32.getTriggerId(ctx)),
  getContentEl: (ctx) => dom32.getById(ctx, dom32.getContentId(ctx)),
  getPositionerEl: (ctx) => dom32.getById(ctx, dom32.getPositionerId(ctx)),
  getArrowEl: (ctx) => dom32.getById(ctx, dom32.getArrowId(ctx))
});
var store = proxy({
  id: null,
  prevId: null,
  setId(val) {
    this.prevId = this.id;
    this.id = val;
  }
});
function connect32(state2, send, normalize) {
  const id = state2.context.id;
  const hasAriaLabel = state2.context.hasAriaLabel;
  const open = state2.hasTag("open");
  const triggerId = dom32.getTriggerId(state2.context);
  const contentId = dom32.getContentId(state2.context);
  const disabled = state2.context.disabled;
  const popperStyles = getPlacementStyles({
    ...state2.context.positioning,
    placement: state2.context.currentPlacement
  });
  return {
    open,
    setOpen(nextOpen) {
      if (nextOpen === open)
        return;
      send(nextOpen ? "OPEN" : "CLOSE");
    },
    reposition(options = {}) {
      send({ type: "POSITIONING.SET", options });
    },
    getTriggerProps() {
      return normalize.button({
        ...parts32.trigger.attrs,
        id: triggerId,
        dir: state2.context.dir,
        "data-expanded": dataAttr(open),
        "data-state": open ? "open" : "closed",
        "aria-describedby": open ? contentId : void 0,
        onClick() {
          if (disabled)
            return;
          send("CLOSE");
        },
        onFocus() {
          if (disabled || state2.event.type === "POINTER_DOWN")
            return;
          send("OPEN");
        },
        onBlur() {
          if (disabled)
            return;
          if (id === store.id) {
            send("CLOSE");
          }
        },
        onPointerDown() {
          if (disabled || !state2.context.closeOnPointerDown)
            return;
          if (id === store.id) {
            send("CLOSE");
          }
        },
        onPointerMove(event) {
          if (disabled || event.pointerType === "touch")
            return;
          send("POINTER_MOVE");
        },
        onPointerLeave() {
          if (disabled)
            return;
          send("POINTER_LEAVE");
        },
        onPointerCancel() {
          if (disabled)
            return;
          send("POINTER_LEAVE");
        }
      });
    },
    getArrowProps() {
      return normalize.element({
        id: dom32.getArrowId(state2.context),
        ...parts32.arrow.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrow
      });
    },
    getArrowTipProps() {
      return normalize.element({
        ...parts32.arrowTip.attrs,
        dir: state2.context.dir,
        style: popperStyles.arrowTip
      });
    },
    getPositionerProps() {
      return normalize.element({
        id: dom32.getPositionerId(state2.context),
        ...parts32.positioner.attrs,
        dir: state2.context.dir,
        style: popperStyles.floating
      });
    },
    getContentProps() {
      return normalize.element({
        ...parts32.content.attrs,
        dir: state2.context.dir,
        hidden: !open,
        "data-state": open ? "open" : "closed",
        role: hasAriaLabel ? void 0 : "tooltip",
        id: hasAriaLabel ? void 0 : contentId,
        "data-placement": state2.context.currentPlacement,
        onPointerEnter() {
          send("CONTENT.POINTER_MOVE");
        },
        onPointerLeave() {
          send("CONTENT.POINTER_LEAVE");
        },
        style: {
          pointerEvents: state2.context.interactive ? "auto" : "none"
        }
      });
    }
  };
}
var { and: and13, not: not16 } = guards;
function machine31(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "tooltip",
      initial: ctx.open ? "open" : "closed",
      context: {
        openDelay: 1e3,
        closeDelay: 500,
        closeOnPointerDown: true,
        closeOnEscape: true,
        interactive: false,
        ...ctx,
        currentPlacement: void 0,
        hasPointerMoveOpened: false,
        positioning: {
          placement: "bottom",
          ...ctx.positioning
        }
      },
      computed: {
        hasAriaLabel: (ctx2) => !!ctx2["aria-label"]
      },
      watch: {
        disabled: ["closeIfDisabled"],
        open: ["toggleVisibility"]
      },
      states: {
        closed: {
          tags: ["closed"],
          entry: ["clearGlobalId"],
          on: {
            "CONTROLLED.OPEN": "open",
            OPEN: {
              target: "open",
              actions: ["invokeOnOpen"]
            },
            POINTER_LEAVE: {
              actions: ["clearPointerMoveOpened"]
            },
            POINTER_MOVE: [
              {
                guard: and13("noVisibleTooltip", not16("hasPointerMoveOpened")),
                target: "opening"
              },
              {
                guard: not16("hasPointerMoveOpened"),
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          }
        },
        opening: {
          tags: ["closed"],
          activities: ["trackScroll", "trackPointerlockChange"],
          after: {
            OPEN_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ]
          },
          on: {
            "CONTROLLED.OPEN": "open",
            "CONTROLLED.CLOSE": "closed",
            OPEN: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["invokeOnOpen"]
              }
            ],
            POINTER_LEAVE: [
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            }
          }
        },
        open: {
          tags: ["open"],
          activities: [
            "trackEscapeKey",
            "trackDisabledTriggerOnSafari",
            "trackScroll",
            "trackPointerlockChange",
            "trackPositioning"
          ],
          entry: ["setGlobalId"],
          on: {
            "CONTROLLED.CLOSE": "closed",
            CLOSE: {
              target: "closed",
              actions: ["invokeOnClose"]
            },
            POINTER_LEAVE: [
              {
                guard: "isVisible",
                target: "closing",
                actions: ["clearPointerMoveOpened"]
              },
              // == group ==
              {
                guard: "isOpenControlled",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["clearPointerMoveOpened", "invokeOnClose"]
              }
            ],
            "CONTENT.POINTER_LEAVE": {
              guard: "isInteractive",
              target: "closing"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        },
        closing: {
          tags: ["open"],
          activities: ["trackStore", "trackPositioning"],
          after: {
            CLOSE_DELAY: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ]
          },
          on: {
            "CONTROLLED.CLOSE": "closed",
            "CONTROLLED.OPEN": "open",
            CLOSE: [
              {
                guard: "isOpenControlled",
                actions: ["invokeOnClose"]
              },
              {
                target: "closed",
                actions: ["invokeOnClose"]
              }
            ],
            POINTER_MOVE: [
              {
                guard: "isOpenControlled",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              },
              {
                target: "open",
                actions: ["setPointerMoveOpened", "invokeOnOpen"]
              }
            ],
            "CONTENT.POINTER_MOVE": {
              guard: "isInteractive",
              target: "open"
            },
            "POSITIONING.SET": {
              actions: "reposition"
            }
          }
        }
      }
    },
    {
      activities: {
        trackPositioning(ctx2) {
          ctx2.currentPlacement = ctx2.positioning.placement;
          const getPositionerEl = () => dom32.getPositionerEl(ctx2);
          return getPlacement(dom32.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            defer: true,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        trackPointerlockChange(ctx2, _evt, { send }) {
          const onChange = () => send({ type: "CLOSE", src: "pointerlock:change" });
          return addDomEvent(dom32.getDoc(ctx2), "pointerlockchange", onChange, false);
        },
        trackScroll(ctx2, _evt, { send }) {
          const triggerEl = dom32.getTriggerEl(ctx2);
          if (!triggerEl)
            return;
          const overflowParents = getOverflowAncestors(triggerEl);
          const cleanups2 = overflowParents.map(
            (overflowParent) => addDomEvent(overflowParent, "scroll", () => send({ type: "CLOSE", src: "scroll" }), {
              passive: true,
              capture: true
            })
          );
          return () => {
            cleanups2.forEach((fn) => fn == null ? void 0 : fn());
          };
        },
        trackStore(ctx2, _evt, { send }) {
          return subscribe(store, () => {
            if (store.id !== ctx2.id) {
              send({ type: "CLOSE", src: "id:change" });
            }
          });
        },
        trackDisabledTriggerOnSafari(ctx2, _evt, { send }) {
          if (!isSafari())
            return;
          const doc = dom32.getDoc(ctx2);
          return addDomEvent(doc, "pointermove", (event) => {
            const selector = "[data-part=trigger][data-expanded]";
            if (isHTMLElement(event.target) && event.target.closest(selector))
              return;
            send("POINTER_LEAVE");
          });
        },
        trackEscapeKey(ctx2, _evt, { send }) {
          if (!ctx2.closeOnEscape)
            return;
          const doc = dom32.getDoc(ctx2);
          return addDomEvent(doc, "keydown", (event) => {
            if (event.key === "Escape") {
              send("CLOSE");
            }
          });
        }
      },
      actions: {
        setGlobalId(ctx2) {
          store.setId(ctx2.id);
        },
        clearGlobalId(ctx2) {
          if (ctx2.id === store.id) {
            store.setId(null);
          }
        },
        invokeOnOpen(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: true });
        },
        invokeOnClose(ctx2) {
          var _a;
          (_a = ctx2.onOpenChange) == null ? void 0 : _a.call(ctx2, { open: false });
        },
        closeIfDisabled(ctx2, _evt, { send }) {
          if (!ctx2.disabled)
            return;
          send({ type: "CLOSE", src: "disabled:change" });
        },
        reposition(ctx2, evt) {
          const getPositionerEl = () => dom32.getPositionerEl(ctx2);
          getPlacement(dom32.getTriggerEl(ctx2), getPositionerEl, {
            ...ctx2.positioning,
            ...evt.options,
            defer: true,
            listeners: false,
            onComplete(data) {
              ctx2.currentPlacement = data.placement;
            }
          });
        },
        toggleVisibility(ctx2, evt, { send }) {
          send({ type: ctx2.open ? "CONTROLLED.OPEN" : "CONTROLLED.CLOSE", previousEvent: evt });
        },
        setPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = true;
        },
        clearPointerMoveOpened(ctx2) {
          ctx2.hasPointerMoveOpened = false;
        }
      },
      guards: {
        noVisibleTooltip: () => store.id === null,
        isVisible: (ctx2) => ctx2.id === store.id,
        isInteractive: (ctx2) => ctx2.interactive,
        hasPointerMoveOpened: (ctx2) => !!ctx2.hasPointerMoveOpened,
        isOpenControlled: (ctx2) => !!ctx2["open.controlled"]
      },
      delays: {
        OPEN_DELAY: (ctx2) => ctx2.openDelay,
        CLOSE_DELAY: (ctx2) => ctx2.closeDelay
      }
    }
  );
}
var props27 = createProps()([
  "aria-label",
  "closeDelay",
  "closeOnEscape",
  "closeOnPointerDown",
  "dir",
  "disabled",
  "getRootNode",
  "id",
  "ids",
  "interactive",
  "onOpenChange",
  "open.controlled",
  "open",
  "openDelay",
  "positioning"
]);
var splitProps27 = createSplitProps(props27);

// node_modules/@zag-js/tree-view/dist/index.mjs
var anatomy39 = createAnatomy("tree-view").parts(
  "root",
  "label",
  "tree",
  "item",
  "itemIndicator",
  "itemText",
  "branch",
  "branchControl",
  "branchTrigger",
  "branchContent",
  "branchText",
  "branchIndicator"
);
var parts33 = anatomy39.build();
var dom33 = createScope({
  getRootId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.root) ?? `tree-root:${ctx.id}`;
  },
  getLabelId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.label) ?? `tree-label:${ctx.id}`;
  },
  getTreeId: (ctx) => {
    var _a;
    return ((_a = ctx.ids) == null ? void 0 : _a.tree) ?? `tree-tree:${ctx.id}`;
  },
  getNodeId(node) {
    if (!isHTMLElement(node))
      return null;
    return node.dataset.branch ?? node.dataset.item ?? null;
  },
  getNodeEl(ctx, id) {
    const node = dom33.getItemEl(ctx, id) ?? dom33.getBranchEl(ctx, id);
    if ((node == null ? void 0 : node.dataset.part) === "branch") {
      return query(node, "[data-part=branch-control]");
    }
    return node;
  },
  getTreeEl(ctx) {
    return dom33.getById(ctx, dom33.getTreeId(ctx));
  },
  getBranchEl(ctx, id) {
    const selector = `[role=treeitem][data-branch="${id}"]`;
    return query(dom33.getTreeEl(ctx), selector);
  },
  getItemEl(ctx, id) {
    const selector = `[role=treeitem][data-item="${id}"]`;
    return query(dom33.getTreeEl(ctx), selector);
  },
  getBranchControlEl(ctx, id) {
    const selector = "[data-part=branch-control]";
    return query(dom33.getBranchEl(ctx, id), selector);
  },
  getFocusedEl(ctx) {
    if (!ctx.focusedValue)
      return null;
    return dom33.getById(ctx, ctx.focusedValue);
  },
  focusNode(node, options) {
    if (isHTMLElement(node))
      node.focus(options);
  },
  getNodeDepth(node) {
    return (node == null ? void 0 : node.dataset.depth) ? Number(node.dataset.depth) : -1;
  },
  getTreeWalker(ctx, opts) {
    const { skipHidden = true, root } = opts ?? {};
    const treeEl = root || dom33.getTreeEl(ctx);
    if (!treeEl)
      throw new Error("Tree or branch root not found");
    const doc = dom33.getDoc(ctx);
    return doc.createTreeWalker(treeEl, NodeFilter.SHOW_ELEMENT, {
      acceptNode(node) {
        if (skipHidden && isHiddenElement(node)) {
          return NodeFilter.FILTER_REJECT;
        }
        if (node.role === "treeitem" && node.dataset.part !== "branch") {
          return NodeFilter.FILTER_ACCEPT;
        }
        if (node.role === "button" && node.dataset.part === "branch-control") {
          return NodeFilter.FILTER_ACCEPT;
        }
        return NodeFilter.FILTER_SKIP;
      }
    });
  },
  getMatchingEl(ctx, key) {
    const walker = dom33.getTreeWalker(ctx);
    const elements = [];
    let node = walker.firstChild();
    while (node) {
      if (isHTMLElement(node))
        elements.push(node);
      node = walker.nextNode();
    }
    return getByTypeahead(elements, {
      state: ctx.typeaheadState,
      key,
      activeId: ctx.focusedValue,
      itemToId: (v) => dom33.getNodeId(v) ?? v.id
    });
  },
  getTreeNodes(ctx, options = {}) {
    const walker = dom33.getTreeWalker(ctx, options);
    const nodes = [];
    let node = walker.firstChild();
    while (node) {
      if (isHTMLElement(node)) {
        nodes.push(node);
      }
      node = walker.nextNode();
    }
    return nodes;
  },
  getBranchNodes(ctx, depth) {
    if (depth === -1)
      return [];
    return queryAll(dom33.getTreeEl(ctx), `[role=treeitem][data-part=branch][data-depth="${depth}"]`);
  },
  getNodesInRange(nodes, startNode, endNode) {
    const nextSet = /* @__PURE__ */ new Set();
    nodes.forEach((node) => {
      const nodeId = dom33.getNodeId(node);
      if (nodeId == null)
        return;
      if (node === startNode || node === endNode) {
        nextSet.add(nodeId);
        return;
      }
      const startPos = node.compareDocumentPosition(startNode);
      const endPos = node.compareDocumentPosition(endNode);
      if (startPos & Node.DOCUMENT_POSITION_FOLLOWING && endPos & Node.DOCUMENT_POSITION_PRECEDING) {
        nextSet.add(nodeId);
        return;
      }
      if (startPos & Node.DOCUMENT_POSITION_PRECEDING && endPos & Node.DOCUMENT_POSITION_FOLLOWING) {
        nextSet.add(nodeId);
        return;
      }
    });
    return Array.from(nextSet);
  }
});
function connect33(state2, send, normalize) {
  const expandedValue = state2.context.expandedValue;
  const selectedValue = state2.context.selectedValue;
  const isTypingAhead = state2.context.isTypingAhead;
  const focusedValue = state2.context.focusedValue;
  function getItemState(props29) {
    return {
      value: props29.value,
      disabled: Boolean(props29.disabled),
      focused: focusedValue === props29.value,
      selected: selectedValue.includes(props29.value)
    };
  }
  function getBranchState(props29) {
    return {
      value: props29.value,
      disabled: Boolean(props29.disabled),
      focused: focusedValue === props29.value,
      expanded: expandedValue.includes(props29.value),
      selected: selectedValue.includes(props29.value)
    };
  }
  return {
    expandedValue,
    selectedValue,
    expand(value) {
      if (!value) {
        send({ type: "EXPANDED.ALL" });
        return;
      }
      const nextValue = new Set(expandedValue);
      value.forEach((id) => nextValue.add(id));
      send({ type: "EXPANDED.SET", value: nextValue, src: "expand" });
    },
    collapse(value) {
      if (!value) {
        send({ type: "EXPANDED.SET", value: /* @__PURE__ */ new Set([]), src: "collapseAll" });
        return;
      }
      const nextValue = new Set(expandedValue);
      value.forEach((id) => nextValue.delete(id));
      send({ type: "EXPANDED.SET", value: nextValue, src: "collapse" });
    },
    deselect(value) {
      if (!value) {
        send({ type: "SELECTED.SET", value: /* @__PURE__ */ new Set([]), src: "deselectAll" });
        return;
      }
      const nextValue = new Set(selectedValue);
      value.forEach((id) => nextValue.delete(id));
      send({ type: "SELECTED.SET", value: nextValue, src: "deselect" });
    },
    select(value) {
      if (!value) {
        send({ type: "SELECTED.ALL" });
        return;
      }
      const nextValue = new Set(selectedValue);
      value.forEach((id) => nextValue.add(id));
      send({ type: "SELECTED.SET", value: nextValue, src: "select" });
    },
    focusBranch(id) {
      var _a;
      (_a = dom33.getBranchControlEl(state2.context, id)) == null ? void 0 : _a.focus();
    },
    focusItem(id) {
      var _a;
      (_a = dom33.getItemEl(state2.context, id)) == null ? void 0 : _a.focus();
    },
    getRootProps() {
      return normalize.element({
        ...parts33.root.attrs,
        id: dom33.getRootId(state2.context),
        dir: state2.context.dir
      });
    },
    getLabelProps() {
      return normalize.element({
        ...parts33.label.attrs,
        id: dom33.getLabelId(state2.context),
        dir: state2.context.dir
      });
    },
    getTreeProps() {
      return normalize.element({
        ...parts33.tree.attrs,
        id: dom33.getTreeId(state2.context),
        dir: state2.context.dir,
        role: "tree",
        "aria-label": "Tree View",
        "aria-labelledby": dom33.getLabelId(state2.context),
        "aria-multiselectable": state2.context.selectionMode === "multiple" || void 0,
        onKeyDown(event) {
          if (event.defaultPrevented)
            return;
          if (isComposingEvent(event))
            return;
          const target = getEventTarget(event);
          const node = target == null ? void 0 : target.closest("[role=treeitem]");
          if (!node)
            return;
          const nodeId = dom33.getNodeId(node);
          if (nodeId == null) {
            console.warn(`Node id not found for node`, node);
            return;
          }
          const isBranchNode = !!(target == null ? void 0 : target.dataset.branch);
          const keyMap2 = {
            ArrowDown(event2) {
              if (isModifierKey(event2))
                return;
              event2.preventDefault();
              send({ type: "ITEM.ARROW_DOWN", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowUp(event2) {
              if (isModifierKey(event2))
                return;
              event2.preventDefault();
              send({ type: "ITEM.ARROW_UP", id: nodeId, shiftKey: event2.shiftKey });
            },
            ArrowLeft(event2) {
              if (isModifierKey(event2) || node.dataset.disabled)
                return;
              event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH.ARROW_LEFT" : "ITEM.ARROW_LEFT", id: nodeId });
            },
            ArrowRight(event2) {
              if (!isBranchNode || node.dataset.disabled)
                return;
              event2.preventDefault();
              send({ type: "BRANCH.ARROW_RIGHT", id: nodeId });
            },
            Home(event2) {
              if (isModifierKey(event2))
                return;
              event2.preventDefault();
              send({ type: "ITEM.HOME", id: nodeId, shiftKey: event2.shiftKey });
            },
            End(event2) {
              if (isModifierKey(event2))
                return;
              event2.preventDefault();
              send({ type: "ITEM.END", id: nodeId, shiftKey: event2.shiftKey });
            },
            Space(event2) {
              var _a;
              if (node.dataset.disabled)
                return;
              if (isTypingAhead) {
                send({ type: "TREE.TYPEAHEAD", key: event2.key });
              } else {
                (_a = keyMap2.Enter) == null ? void 0 : _a.call(keyMap2, event2);
              }
            },
            Enter(event2) {
              if (node.dataset.disabled)
                return;
              const isLink = target == null ? void 0 : target.closest("a[href]");
              if (!isLink)
                event2.preventDefault();
              send({ type: isBranchNode ? "BRANCH.CLICK" : "ITEM.CLICK", id: nodeId, src: "keyboard" });
            },
            "*"(event2) {
              if (node.dataset.disabled)
                return;
              event2.preventDefault();
              send({ type: "EXPAND.SIBLINGS", id: nodeId });
            },
            a(event2) {
              if (!event2.metaKey || node.dataset.disabled)
                return;
              event2.preventDefault();
              send({ type: "SELECTED.ALL", preventScroll: true, moveFocus: true });
            }
          };
          const key = getEventKey(event, state2.context);
          const exec2 = keyMap2[key];
          if (exec2) {
            exec2(event);
            return;
          }
          if (!state2.context.typeahead)
            return;
          const isValidTypeahead = event.key.length === 1 && !isModifierKey(event);
          if (!isValidTypeahead)
            return;
          send({ type: "TREE.TYPEAHEAD", key: event.key, id: nodeId });
          event.preventDefault();
        },
        onBlur(event) {
          if (contains(event.currentTarget, event.relatedTarget))
            return;
          send({ type: "TREE.BLUR" });
        }
      });
    },
    getItemState,
    getItemProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts33.item.attrs,
        dir: state2.context.dir,
        "data-ownedby": dom33.getTreeId(state2.context),
        "data-item": itemState.value,
        tabIndex: itemState.focused ? 0 : -1,
        "data-focus": dataAttr(itemState.focused),
        role: "treeitem",
        "aria-current": itemState.selected ? "true" : void 0,
        "aria-selected": itemState.disabled ? void 0 : itemState.selected,
        "data-selected": dataAttr(itemState.selected),
        "aria-disabled": itemState.disabled,
        "data-disabled": dataAttr(itemState.disabled),
        "aria-level": props29.depth,
        "data-depth": props29.depth,
        style: {
          "--depth": props29.depth
        },
        onFocus(event) {
          event.stopPropagation();
          send({ type: "ITEM.FOCUS", id: itemState.value });
        },
        onClick(event) {
          if (itemState.disabled)
            return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "ITEM.CLICK", id: itemState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
          const isLink = event.currentTarget.matches("a[href]");
          if (!isLink)
            event.preventDefault();
        }
      });
    },
    getItemTextProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts33.itemText.attrs,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused)
      });
    },
    getItemIndicatorProps(props29) {
      const itemState = getItemState(props29);
      return normalize.element({
        ...parts33.itemIndicator.attrs,
        "aria-hidden": true,
        "data-disabled": dataAttr(itemState.disabled),
        "data-selected": dataAttr(itemState.selected),
        "data-focus": dataAttr(itemState.focused),
        hidden: !itemState.selected
      });
    },
    getBranchState,
    getBranchProps(props29) {
      const branchState = getBranchState(props29);
      return normalize.element({
        ...parts33.branch.attrs,
        "data-depth": props29.depth,
        dir: state2.context.dir,
        "data-branch": branchState.value,
        role: "treeitem",
        "data-ownedby": dom33.getTreeId(state2.context),
        "aria-level": props29.depth,
        "aria-selected": branchState.disabled ? void 0 : branchState.selected,
        "data-selected": dataAttr(branchState.selected),
        "aria-expanded": branchState.expanded,
        "data-state": branchState.expanded ? "open" : "closed",
        "aria-disabled": branchState.disabled,
        "data-disabled": dataAttr(branchState.disabled),
        style: {
          "--depth": props29.depth
        }
      });
    },
    getBranchIndicatorProps(props29) {
      const branchState = getBranchState(props29);
      return normalize.element({
        ...parts33.branchIndicator.attrs,
        "aria-hidden": true,
        "data-state": branchState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(branchState.disabled),
        "data-selected": dataAttr(branchState.selected),
        "data-focus": dataAttr(branchState.focused)
      });
    },
    getBranchTriggerProps(props29) {
      const branchState = getBranchState(props29);
      return normalize.element({
        ...parts33.branchTrigger.attrs,
        role: "button",
        dir: state2.context.dir,
        "data-disabled": dataAttr(branchState.disabled),
        "data-state": branchState.expanded ? "open" : "closed",
        onClick(event) {
          if (branchState.disabled)
            return;
          send({ type: "BRANCH_TOGGLE.CLICK", id: branchState.value });
          event.stopPropagation();
        }
      });
    },
    getBranchControlProps(props29) {
      const branchState = getBranchState(props29);
      return normalize.element({
        ...parts33.branchControl.attrs,
        role: "button",
        dir: state2.context.dir,
        tabIndex: branchState.focused ? 0 : -1,
        "data-state": branchState.expanded ? "open" : "closed",
        "data-disabled": dataAttr(branchState.disabled),
        "data-selected": dataAttr(branchState.selected),
        "data-branch": branchState.value,
        "data-depth": props29.depth,
        onFocus(event) {
          send({ type: "ITEM.FOCUS", id: branchState.value });
          event.stopPropagation();
        },
        onClick(event) {
          if (branchState.disabled)
            return;
          const isMetaKey = event.metaKey || event.ctrlKey;
          send({ type: "BRANCH.CLICK", id: branchState.value, shiftKey: event.shiftKey, ctrlKey: isMetaKey });
          event.stopPropagation();
        }
      });
    },
    getBranchTextProps(props29) {
      const branchState = getBranchState(props29);
      return normalize.element({
        ...parts33.branchText.attrs,
        dir: state2.context.dir,
        "data-branch": branchState.value,
        "data-disabled": dataAttr(branchState.disabled),
        "data-state": branchState.expanded ? "open" : "closed"
      });
    },
    getBranchContentProps(props29) {
      const branchState = getBranchState(props29);
      return normalize.element({
        ...parts33.branchContent.attrs,
        role: "group",
        dir: state2.context.dir,
        "data-branch": branchState.value,
        "data-state": branchState.expanded ? "open" : "closed",
        hidden: !branchState.expanded
      });
    }
  };
}
var { and: and14 } = guards;
function machine32(userContext) {
  const ctx = compact(userContext);
  return createMachine(
    {
      id: "tree-view",
      initial: "idle",
      context: {
        expandedValue: [],
        selectedValue: [],
        focusedValue: null,
        expandOnClick: true,
        selectionMode: "single",
        typeahead: true,
        ...ctx,
        typeaheadState: getByTypeahead.defaultOptions
      },
      computed: {
        isMultipleSelection: (ctx2) => ctx2.selectionMode === "multiple"
      },
      on: {
        "EXPANDED.SET": {
          actions: ["setExpanded"]
        },
        "SELECTED.SET": {
          actions: ["setSelected"]
        },
        "SELECTED.ALL": [
          {
            guard: and14("isMultipleSelection", "moveFocus"),
            actions: ["selectAllItems", "focusTreeLastItem"]
          },
          {
            guard: "isMultipleSelection",
            actions: ["selectAllItems"]
          }
        ],
        "EXPANDED.ALL": {
          actions: ["expandAllBranches"]
        }
      },
      activities: ["trackChildrenMutation"],
      entry: ["setFocusableNode"],
      states: {
        idle: {
          on: {
            "ITEM.FOCUS": {
              actions: ["setFocusedItem"]
            },
            "ITEM.ARROW_DOWN": [
              {
                guard: and14("isShiftKey", "isMultipleSelection"),
                actions: ["focusTreeNextItem", "extendSelectionToNextItem"]
              },
              {
                actions: ["focusTreeNextItem"]
              }
            ],
            "ITEM.ARROW_UP": [
              {
                guard: and14("isShiftKey", "isMultipleSelection"),
                actions: ["focusTreePrevItem", "extendSelectionToPrevItem"]
              },
              {
                actions: ["focusTreePrevItem"]
              }
            ],
            "ITEM.ARROW_LEFT": {
              actions: ["focusBranchControl"]
            },
            "BRANCH.ARROW_LEFT": [
              {
                guard: "isBranchExpanded",
                actions: ["collapseBranch"]
              },
              {
                actions: ["focusBranchControl"]
              }
            ],
            "BRANCH.ARROW_RIGHT": [
              {
                guard: and14("isBranchFocused", "isBranchExpanded"),
                actions: ["focusBranchFirstItem"]
              },
              {
                actions: ["expandBranch"]
              }
            ],
            "EXPAND.SIBLINGS": {
              actions: ["expandSiblingBranches"]
            },
            "ITEM.HOME": [
              {
                guard: and14("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToFirstItem", "focusTreeFirstItem"]
              },
              {
                actions: ["focusTreeFirstItem"]
              }
            ],
            "ITEM.END": [
              {
                guard: and14("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToLastItem", "focusTreeLastItem"]
              },
              {
                actions: ["focusTreeLastItem"]
              }
            ],
            "ITEM.CLICK": [
              {
                guard: and14("isCtrlKey", "isMultipleSelection"),
                actions: ["addOrRemoveItemFromSelection"]
              },
              {
                guard: and14("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToItem"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            "BRANCH.CLICK": [
              {
                guard: and14("isCtrlKey", "isMultipleSelection"),
                actions: ["addOrRemoveItemFromSelection"]
              },
              {
                guard: and14("isShiftKey", "isMultipleSelection"),
                actions: ["extendSelectionToItem"]
              },
              {
                guard: "openOnClick",
                actions: ["selectItem", "toggleBranch"]
              },
              {
                actions: ["selectItem"]
              }
            ],
            "BRANCH_TOGGLE.CLICK": {
              actions: ["toggleBranch"]
            },
            "TREE.TYPEAHEAD": {
              actions: ["focusMatchedItem"]
            },
            "TREE.BLUR": {
              actions: ["clearFocusedItem", "setFocusableNode"]
            }
          }
        }
      }
    },
    {
      guards: {
        isBranchFocused: (ctx2, evt) => ctx2.focusedValue === evt.id,
        isBranchExpanded: (ctx2, evt) => ctx2.expandedValue.includes(evt.id),
        isShiftKey: (_ctx, evt) => evt.shiftKey,
        isCtrlKey: (_ctx, evt) => evt.ctrlKey,
        hasSelectedItems: (ctx2) => ctx2.selectedValue.length > 0,
        isMultipleSelection: (ctx2) => ctx2.isMultipleSelection,
        moveFocus: (_ctx, evt) => !!evt.moveFocus,
        openOnClick: (ctx2) => !!ctx2.expandOnClick
      },
      activities: {
        trackChildrenMutation(ctx2, _evt, { send }) {
          const treeEl = dom33.getTreeEl(ctx2);
          return observeChildren(treeEl, {
            callback(records) {
              const removedNodes = records.flatMap((r) => Array.from(r.removedNodes)).filter((node) => {
                if (!isHTMLElement(node))
                  return false;
                return node.matches("[role=treeitem]") || node.matches("[role=group]");
              });
              if (!removedNodes.length)
                return;
              let elementToFocus = null;
              records.forEach((record) => {
                if (isHTMLElement(record.nextSibling)) {
                  elementToFocus = record.nextSibling;
                } else if (isHTMLElement(record.previousSibling)) {
                  elementToFocus = record.previousSibling;
                }
              });
              if (elementToFocus) {
                dom33.focusNode(elementToFocus);
              }
              const removedIds = /* @__PURE__ */ new Set();
              removedNodes.forEach((node) => {
                const nodeId = dom33.getNodeId(node);
                if (isHTMLElement(node) && nodeId != null) {
                  removedIds.add(nodeId);
                }
              });
              const nextSet = new Set(ctx2.selectedValue);
              removedIds.forEach((id) => nextSet.delete(id));
              send({ type: "SELECTED.SET", value: removedIds });
            }
          });
        }
      },
      actions: {
        setFocusableNode(ctx2) {
          if (ctx2.focusedValue)
            return;
          if (ctx2.selectedValue.length > 0) {
            const firstSelectedId = Array.from(ctx2.selectedValue)[0];
            ctx2.focusedValue = firstSelectedId;
            return;
          }
          const walker = dom33.getTreeWalker(ctx2);
          const firstItem = walker.firstChild();
          if (!isHTMLElement(firstItem))
            return;
          ctx2.focusedValue = dom33.getNodeId(firstItem);
        },
        selectItem(ctx2, evt) {
          set23.selected(ctx2, [evt.id]);
        },
        setFocusedItem(ctx2, evt) {
          set23.focused(ctx2, evt.id);
        },
        clearFocusedItem(ctx2) {
          set23.focused(ctx2, null);
        },
        clearSelectedItem(ctx2) {
          set23.selected(ctx2, []);
        },
        toggleBranch(ctx2, evt) {
          const nextSet = new Set(ctx2.expandedValue);
          if (nextSet.has(evt.id)) {
            nextSet.delete(evt.id);
          } else {
            nextSet.add(evt.id);
          }
          set23.expanded(ctx2, Array.from(nextSet));
        },
        expandBranch(ctx2, evt) {
          const nextSet = new Set(ctx2.expandedValue);
          nextSet.add(evt.id);
          set23.expanded(ctx2, Array.from(nextSet));
        },
        collapseBranch(ctx2, evt) {
          const nextSet = new Set(ctx2.expandedValue);
          nextSet.delete(evt.id);
          set23.expanded(ctx2, Array.from(nextSet));
        },
        setExpanded(ctx2, evt) {
          set23.expanded(ctx2, evt.value);
        },
        setSelected(ctx2, evt) {
          set23.selected(ctx2, evt.value);
        },
        focusTreeFirstItem(ctx2) {
          const walker = dom33.getTreeWalker(ctx2);
          dom33.focusNode(walker.firstChild());
        },
        focusTreeLastItem(ctx2, evt) {
          const walker = dom33.getTreeWalker(ctx2);
          dom33.focusNode(walker.lastChild(), { preventScroll: evt.preventScroll });
        },
        focusBranchFirstItem(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          if (!focusedEl)
            return;
          const walker = dom33.getTreeWalker(ctx2);
          walker.currentNode = focusedEl;
          dom33.focusNode(walker.nextNode());
        },
        focusTreeNextItem(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          if (!focusedEl)
            return;
          const walker = dom33.getTreeWalker(ctx2);
          if (ctx2.focusedValue) {
            walker.currentNode = focusedEl;
            const nextNode = walker.nextNode();
            dom33.focusNode(nextNode);
          } else {
            dom33.focusNode(walker.firstChild());
          }
        },
        focusTreePrevItem(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          if (!focusedEl)
            return;
          const walker = dom33.getTreeWalker(ctx2);
          if (ctx2.focusedValue) {
            walker.currentNode = focusedEl;
            const prevNode = walker.previousNode();
            dom33.focusNode(prevNode);
          } else {
            dom33.focusNode(walker.lastChild());
          }
        },
        focusBranchControl(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          if (!focusedEl)
            return;
          const parentDepth = Number(focusedEl.dataset.depth) - 1;
          if (parentDepth < 0)
            return;
          const branchSelector = `[data-part=branch][data-depth="${parentDepth}"]`;
          const closestBranch = focusedEl.closest(branchSelector);
          const branchControl = closestBranch == null ? void 0 : closestBranch.querySelector("[data-part=branch-control]");
          dom33.focusNode(branchControl);
        },
        selectAllItems(ctx2) {
          const nextSet = /* @__PURE__ */ new Set();
          const walker = dom33.getTreeWalker(ctx2);
          let node = walker.firstChild();
          while (node) {
            const nodeId = dom33.getNodeId(node);
            if (isHTMLElement(node) && nodeId != null) {
              nextSet.add(nodeId);
            }
            node = walker.nextNode();
          }
          set23.selected(ctx2, Array.from(nextSet));
        },
        focusMatchedItem(ctx2, evt) {
          dom33.focusNode(dom33.getMatchingEl(ctx2, evt.key));
        },
        addOrRemoveItemFromSelection(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          if (!focusedEl)
            return;
          const nextSet = new Set(ctx2.selectedValue);
          const nodeId = dom33.getNodeId(focusedEl);
          if (nodeId == null)
            return;
          if (nextSet.has(nodeId)) {
            nextSet.delete(nodeId);
          } else {
            nextSet.add(nodeId);
          }
          set23.selected(ctx2, Array.from(nextSet));
        },
        expandAllBranches(ctx2) {
          const nextSet = /* @__PURE__ */ new Set();
          const walker = dom33.getTreeWalker(ctx2, { skipHidden: false });
          while (walker.nextNode()) {
            const node = walker.currentNode;
            const nodeId = dom33.getNodeId(node);
            if (isHTMLElement(node) && node.dataset.part === "branch-control" && nodeId != null) {
              nextSet.add(nodeId);
            }
          }
          set23.expanded(ctx2, Array.from(nextSet));
        },
        expandSiblingBranches(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          const nodes = dom33.getBranchNodes(ctx2, dom33.getNodeDepth(focusedEl));
          const nextSet = /* @__PURE__ */ new Set();
          nodes.forEach((node) => {
            const nodeId = dom33.getNodeId(node);
            if (nodeId == null)
              return;
            nextSet.add(nodeId);
          });
          set23.expanded(ctx2, Array.from(nextSet));
        },
        extendSelectionToItem(ctx2, evt) {
          const focusedEl = dom33.getNodeEl(ctx2, evt.id);
          if (!focusedEl)
            return;
          const nodes = dom33.getTreeNodes(ctx2);
          const selectedIds = Array.from(ctx2.selectedValue);
          const anchorEl = dom33.getNodeEl(ctx2, selectedIds[0]) || nodes[0];
          const nextSet = dom33.getNodesInRange(nodes, anchorEl, focusedEl);
          set23.selected(ctx2, nextSet);
        },
        extendSelectionToNextItem(ctx2, evt) {
          const nodeId = evt.id;
          const currentNode = dom33.getNodeEl(ctx2, nodeId);
          if (!currentNode)
            return;
          const walker = dom33.getTreeWalker(ctx2);
          walker.currentNode = currentNode;
          const nextNode = walker.nextNode();
          dom33.focusNode(nextNode);
          const selectedIds = new Set(ctx2.selectedValue);
          const nextNodeId = dom33.getNodeId(nextNode);
          if (nextNodeId == null)
            return;
          if (selectedIds.has(nodeId) && selectedIds.has(nextNodeId)) {
            selectedIds.delete(nodeId);
          } else if (!selectedIds.has(nextNodeId)) {
            selectedIds.add(nextNodeId);
          }
          set23.selected(ctx2, Array.from(selectedIds));
        },
        extendSelectionToPrevItem(ctx2, evt) {
          const nodeId = evt.id;
          const currentNode = dom33.getNodeEl(ctx2, nodeId);
          if (!currentNode)
            return;
          const walker = dom33.getTreeWalker(ctx2);
          walker.currentNode = currentNode;
          const prevNode = walker.previousNode();
          dom33.focusNode(prevNode);
          const selectedIds = new Set(ctx2.selectedValue);
          const prevNodeId = dom33.getNodeId(prevNode);
          if (prevNodeId == null)
            return;
          if (selectedIds.has(nodeId) && selectedIds.has(prevNodeId)) {
            selectedIds.delete(nodeId);
          } else if (!selectedIds.has(prevNodeId)) {
            selectedIds.add(prevNodeId);
          }
          set23.selected(ctx2, Array.from(selectedIds));
        },
        extendSelectionToFirstItem(ctx2) {
          const nodes = dom33.getTreeNodes(ctx2);
          const anchorEl = dom33.getNodeEl(ctx2, [...ctx2.selectedValue][0]) || nodes[0];
          const focusedEl = nodes[0];
          const selectedIds = dom33.getNodesInRange(nodes, anchorEl, focusedEl);
          set23.selected(ctx2, selectedIds);
        },
        extendSelectionToLastItem(ctx2) {
          const nodes = dom33.getTreeNodes(ctx2);
          const anchorEl = dom33.getNodeEl(ctx2, [...ctx2.selectedValue][0]) || nodes[0];
          const focusedEl = nodes[nodes.length - 1];
          const selectedIds = dom33.getNodesInRange(nodes, anchorEl, focusedEl);
          set23.selected(ctx2, selectedIds);
        }
      }
    }
  );
}
var invoke19 = {
  focusChange(ctx) {
    var _a;
    (_a = ctx.onFocusChange) == null ? void 0 : _a.call(ctx, { focusedValue: ctx.focusedValue });
  },
  expandedChange(ctx) {
    var _a;
    (_a = ctx.onExpandedChange) == null ? void 0 : _a.call(ctx, {
      expandedValue: ctx.expandedValue,
      focusedValue: ctx.focusedValue
    });
  },
  selectionChange(ctx) {
    var _a;
    (_a = ctx.onSelectionChange) == null ? void 0 : _a.call(ctx, {
      selectedValue: ctx.selectedValue,
      focusedValue: ctx.focusedValue
    });
  }
};
var set23 = {
  selected(ctx, ids) {
    ctx.selectedValue = ids;
    invoke19.selectionChange(ctx);
  },
  focused(ctx, id) {
    ctx.focusedValue = id;
    invoke19.focusChange(ctx);
  },
  expanded(ctx, ids) {
    ctx.expandedValue = ids;
    invoke19.expandedChange(ctx);
  }
};

// node_modules/@ark-ui/react/dist/components/carousel/carousel-control.js
var import_react39 = __toESM(require_react(), 1);
var CarouselControl = (0, import_react39.forwardRef)((props29, ref2) => (0, import_jsx_runtime14.jsx)(ark.div, { ...anatomy5.build().control.attrs, ...props29, ref: ref2 }));
CarouselControl.displayName = "CarouselControl";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react41 = __toESM(require_react(), 1);
var CarouselIndicator = (0, import_react41.forwardRef)(
  (props29, ref2) => {
    const [indicatorProps3, localProps] = createSplitProps2()(props29, [
      "readOnly",
      "index"
    ]);
    const carousel = useCarouselContext();
    const mergedProps = mergeProps(carousel.getIndicatorProps(indicatorProps3), localProps);
    return (0, import_jsx_runtime15.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselIndicator.displayName = "CarouselIndicator";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-indicator-group.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);
var import_react43 = __toESM(require_react(), 1);
var CarouselIndicatorGroup = (0, import_react43.forwardRef)(
  (props29, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps(carousel.getIndicatorGroupProps(), props29);
    return (0, import_jsx_runtime16.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CarouselIndicatorGroup.displayName = "CarouselIndicatorGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item.js
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var import_react45 = __toESM(require_react(), 1);
var CarouselItem = (0, import_react45.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["index"]);
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getItemProps(itemProps10), localProps);
  return (0, import_jsx_runtime17.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CarouselItem.displayName = "CarouselItem";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-item-group.js
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var CarouselItemGroup = (0, import_react47.forwardRef)(
  (props29, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps(carousel.getItemGroupProps(), props29);
    return (0, import_jsx_runtime18.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
CarouselItemGroup.displayName = "CarouselItemGroup";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-next-trigger.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var CarouselNextTrigger = (0, import_react49.forwardRef)(
  (props29, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps(carousel.getNextTriggerProps(), props29);
    return (0, import_jsx_runtime19.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselNextTrigger.displayName = "CarouselNextTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-prev-trigger.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var CarouselPrevTrigger = (0, import_react51.forwardRef)(
  (props29, ref2) => {
    const carousel = useCarouselContext();
    const mergedProps = mergeProps(carousel.getPrevTriggerProps(), props29);
    return (0, import_jsx_runtime20.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CarouselPrevTrigger.displayName = "CarouselPrevTrigger";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react55 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/carousel/use-carousel.js
var import_react53 = __toESM(require_react(), 1);
var useCarousel = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react53.useId)(),
    dir,
    getRootNode: getRootNode2,
    index: props29.defaultIndex,
    ...props29
  };
  const context = {
    ...initialContext,
    index: props29.index,
    onIndexChange: useEvent(props29.onIndexChange, { sync: true })
  };
  const [state2, send] = useMachine(machine4(initialContext), { context });
  return connect4(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root.js
var CarouselRoot = (0, import_react55.forwardRef)((props29, ref2) => {
  const [useCarouselProps, localProps] = createSplitProps2()(props29, [
    "align",
    "defaultIndex",
    "id",
    "ids",
    "index",
    "loop",
    "onIndexChange",
    "orientation",
    "slidesPerView",
    "spacing"
  ]);
  const carousel = useCarousel(useCarouselProps);
  const mergedProps = mergeProps(carousel.getRootProps(), localProps);
  return (0, import_jsx_runtime21.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime21.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
CarouselRoot.displayName = "CarouselRoot";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-root-provider.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);
var CarouselRootProvider = (0, import_react57.forwardRef)(
  (props29, ref2) => {
    const [{ value: carousel }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(carousel.getRootProps(), localProps);
    return (0, import_jsx_runtime22.jsx)(CarouselProvider, { value: carousel, children: (0, import_jsx_runtime22.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CarouselRootProvider.displayName = "CarouselRootProvider";

// node_modules/@ark-ui/react/dist/components/carousel/carousel-viewport.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react59 = __toESM(require_react(), 1);
var CarouselViewport = (0, import_react59.forwardRef)((props29, ref2) => {
  const carousel = useCarouselContext();
  const mergedProps = mergeProps(carousel.getViewportProps(), props29);
  return (0, import_jsx_runtime23.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CarouselViewport.displayName = "CarouselViewport";

// node_modules/@ark-ui/react/dist/components/carousel/carousel.js
var carousel_exports = {};
__export(carousel_exports, {
  Context: () => CarouselContext,
  Control: () => CarouselControl,
  Indicator: () => CarouselIndicator,
  IndicatorGroup: () => CarouselIndicatorGroup,
  Item: () => CarouselItem,
  ItemGroup: () => CarouselItemGroup,
  NextTrigger: () => CarouselNextTrigger,
  PrevTrigger: () => CarouselPrevTrigger,
  Root: () => CarouselRoot,
  RootProvider: () => CarouselRootProvider,
  Viewport: () => CarouselViewport
});

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-context.js
var [CheckboxProvider, useCheckboxContext] = createContext({
  name: "CheckboxContext",
  hookName: "useCheckboxContext",
  providerName: "<CheckboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-context.js
var CheckboxContext = (props29) => props29.children(useCheckboxContext());

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-control.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react61 = __toESM(require_react(), 1);
var CheckboxControl = (0, import_react61.forwardRef)((props29, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps(checkbox.getControlProps(), props29);
  return (0, import_jsx_runtime24.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
CheckboxControl.displayName = "CheckboxControl";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react63 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-controllable-state.js
var import_react62 = __toESM(require_react(), 1);
function useControllableState(props29) {
  const { value, onChange, defaultValue } = props29;
  const [uncontrolledValue, setUncontrolledValue] = (0, import_react62.useState)(defaultValue);
  const controlled = value !== void 0;
  const currentValue = controlled ? value : uncontrolledValue;
  const setValue = (0, import_react62.useCallback)(
    (value2) => {
      if (controlled) {
        return onChange == null ? void 0 : onChange(value2);
      }
      setUncontrolledValue(value2);
      return onChange == null ? void 0 : onChange(value2);
    },
    [controlled, onChange]
  );
  return [currentValue, setValue];
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group.js
function useCheckboxGroup(props29 = {}) {
  const { defaultValue, value: controlledValue, onValueChange, disabled, readOnly } = props29;
  const interative = !(disabled || readOnly);
  const onChangeProp = useEvent(onValueChange, { sync: true });
  const [value, setValue] = useControllableState({
    value: controlledValue,
    defaultValue: defaultValue || [],
    onChange: onChangeProp
  });
  const isChecked2 = (val) => {
    return value.some((v) => String(v) === String(val));
  };
  const toggleValue = (val) => {
    isChecked2(val) ? removeValue(val) : addValue(val);
  };
  const addValue = (val) => {
    if (!interative)
      return;
    if (isChecked2(val))
      return;
    setValue(value.concat(val));
  };
  const removeValue = (val) => {
    if (!interative)
      return;
    setValue(value.filter((v) => String(v) !== String(val)));
  };
  const getItemProps = (props210) => {
    return {
      checked: props210.value != null ? isChecked2(props210.value) : void 0,
      onCheckedChange() {
        if (props210.value != null) {
          toggleValue(props210.value);
        }
      },
      disabled,
      readOnly
    };
  };
  return {
    isChecked: isChecked2,
    value,
    disabled,
    readOnly,
    setValue,
    addValue,
    toggleValue,
    getItemProps
  };
}

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox-group-context.js
var [CheckboxGroupContextProvider, useCheckboxGroupContext] = createContext({
  name: "CheckboxGroupContext",
  hookName: "useCheckboxGroupContext",
  providerName: "<CheckboxGroupProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-group.js
var CheckboxGroup = (0, import_react63.forwardRef)((props29, ref2) => {
  const [checkboxGroupProps, localProps] = createSplitProps2()(props29, [
    "defaultValue",
    "value",
    "onValueChange",
    "disabled",
    "readOnly"
  ]);
  const checkboxGroup = useCheckboxGroup(checkboxGroupProps);
  return (0, import_jsx_runtime25.jsx)(CheckboxGroupContextProvider, { value: checkboxGroup, children: (0, import_jsx_runtime25.jsx)(ark.div, { ref: ref2, ...localProps, ...anatomy7.build().group.attrs }) });
});
CheckboxGroup.displayName = "CheckboxGroup";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-hidden-input.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var CheckboxHiddenInput = (0, import_react65.forwardRef)(
  (props29, ref2) => {
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps(checkbox.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime26.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
CheckboxHiddenInput.displayName = "CheckboxHiddenInput";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-indicator.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);
var CheckboxIndicator = (0, import_react67.forwardRef)(
  (props29, ref2) => {
    const { indeterminate, ...rest } = props29;
    const checkbox = useCheckboxContext();
    const mergedProps = mergeProps(checkbox.getIndicatorProps(), rest);
    const isVisible2 = indeterminate ? checkbox.indeterminate : checkbox.checked;
    return (0, import_jsx_runtime27.jsx)(ark.div, { ...mergedProps, hidden: !isVisible2, ref: ref2 });
  }
);
CheckboxIndicator.displayName = "CheckboxIndicator";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-label.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);
var CheckboxLabel = (0, import_react69.forwardRef)((props29, ref2) => {
  const checkbox = useCheckboxContext();
  const mergedProps = mergeProps(checkbox.getLabelProps(), props29);
  return (0, import_jsx_runtime28.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
CheckboxLabel.displayName = "CheckboxLabel";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/checkbox/use-checkbox.js
var import_react71 = __toESM(require_react(), 1);
var useCheckbox = (ownProps = {}) => {
  const checkboxGroup = useCheckboxGroupContext();
  const props29 = (0, import_react71.useMemo)(() => {
    return mergeProps(ownProps, (checkboxGroup == null ? void 0 : checkboxGroup.getItemProps({ value: ownProps.value })) ?? {});
  }, [ownProps, checkboxGroup]);
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react71.useId)(),
    dir,
    getRootNode: getRootNode2,
    checked: props29.defaultChecked,
    ...props29
  };
  const context = {
    ...initialContext,
    checked: props29.checked,
    onCheckedChange: useEvent(props29.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine5(initialContext), { context });
  return connect5(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root.js
var CheckboxRoot = (0, import_react73.forwardRef)((props29, ref2) => {
  const [useCheckboxProps, localProps] = createSplitProps2()(props29, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const checkbox = useCheckbox(useCheckboxProps);
  const mergedProps = mergeProps(checkbox.getRootProps(), localProps);
  return (0, import_jsx_runtime29.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime29.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
CheckboxRoot.displayName = "CheckboxRoot";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox-root-provider.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react75 = __toESM(require_react(), 1);
var CheckboxRootProvider = (0, import_react75.forwardRef)(
  (props29, ref2) => {
    const [{ value: checkbox }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(checkbox.getRootProps(), localProps);
    return (0, import_jsx_runtime30.jsx)(CheckboxProvider, { value: checkbox, children: (0, import_jsx_runtime30.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
CheckboxRootProvider.displayName = "CheckboxRootProvider";

// node_modules/@ark-ui/react/dist/components/checkbox/checkbox.js
var checkbox_exports = {};
__export(checkbox_exports, {
  Context: () => CheckboxContext,
  Control: () => CheckboxControl,
  Group: () => CheckboxGroup,
  HiddenInput: () => CheckboxHiddenInput,
  Indicator: () => CheckboxIndicator,
  Label: () => CheckboxLabel,
  Root: () => CheckboxRoot,
  RootProvider: () => CheckboxRootProvider
});

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard-context.js
var [ClipboardProvider, useClipboardContext] = createContext({
  name: "ClipboardContext",
  hookName: "useClipboardContext",
  providerName: "<ClipboardProvider />"
});

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-context.js
var ClipboardContext = (props29) => props29.children(useClipboardContext());

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-control.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);
var ClipboardControl = (0, import_react77.forwardRef)((props29, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getControlProps(), props29);
  return (0, import_jsx_runtime31.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ClipboardControl.displayName = "ClipboardControl";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-indicator.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react79 = __toESM(require_react(), 1);
var ClipboardIndicator = (0, import_react79.forwardRef)(
  (props29, ref2) => {
    const { children, copied, ...localProps } = props29;
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps(
      clipboard.getIndicatorProps({ copied: clipboard.copied }),
      localProps
    );
    return (0, import_jsx_runtime32.jsx)(ark.div, { ...mergedProps, ref: ref2, children: clipboard.copied ? copied : children });
  }
);
ClipboardIndicator.displayName = "ClipboardIndicator";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-input.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react81 = __toESM(require_react(), 1);
var ClipboardInput = (0, import_react81.forwardRef)((props29, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getInputProps(), props29);
  return (0, import_jsx_runtime33.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
ClipboardInput.displayName = "ClipboardInput";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-label.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react83 = __toESM(require_react(), 1);
var ClipboardLabel = (0, import_react83.forwardRef)((props29, ref2) => {
  const clipboard = useClipboardContext();
  const mergedProps = mergeProps(clipboard.getLabelProps(), props29);
  return (0, import_jsx_runtime34.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ClipboardLabel.displayName = "ClipboardLabel";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react87 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/clipboard/use-clipboard.js
var import_react85 = __toESM(require_react(), 1);
var useClipboard = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react85.useId)(),
    getRootNode: getRootNode2,
    ...props29
  };
  const context = {
    ...initialContext
  };
  const [state2, send] = useMachine(machine6(initialContext), { context });
  return connect6(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root.js
var ClipboardRoot = (0, import_react87.forwardRef)((props29, ref2) => {
  const [useClipboardProps, localProps] = createSplitProps2()(props29, [
    "id",
    "ids",
    "onStatusChange",
    "timeout",
    "value"
  ]);
  const clipboard = useClipboard(useClipboardProps);
  const mergedProps = mergeProps(clipboard.getRootProps(), localProps);
  return (0, import_jsx_runtime35.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime35.jsx)(ark.div, { ref: ref2, ...mergedProps }) });
});
ClipboardRoot.displayName = "ClipboardRoot";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-root-provider.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react89 = __toESM(require_react(), 1);
var ClipboardRootProvider = (0, import_react89.forwardRef)(
  (props29, ref2) => {
    const [{ value: clipboard }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(clipboard.getRootProps(), localProps);
    return (0, import_jsx_runtime36.jsx)(ClipboardProvider, { value: clipboard, children: (0, import_jsx_runtime36.jsx)(ark.div, { ref: ref2, ...mergedProps }) });
  }
);
ClipboardRootProvider.displayName = "ClipboardRootProvider";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard-trigger.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var ClipboardTrigger = (0, import_react91.forwardRef)(
  (props29, ref2) => {
    const clipboard = useClipboardContext();
    const mergedProps = mergeProps(clipboard.getTriggerProps(), props29);
    return (0, import_jsx_runtime37.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ClipboardTrigger.displayName = "ClipboardTrigger";

// node_modules/@ark-ui/react/dist/components/clipboard/clipboard.js
var clipboard_exports = {};
__export(clipboard_exports, {
  Context: () => ClipboardContext,
  Control: () => ClipboardControl,
  Indicator: () => ClipboardIndicator,
  Input: () => ClipboardInput,
  Label: () => ClipboardLabel,
  Root: () => ClipboardRoot,
  RootProvider: () => ClipboardRootProvider,
  Trigger: () => ClipboardTrigger
});

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-context.js
var CollapsibleContext = (props29) => props29.children(useCollapsibleContext());

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-root-provider.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var import_react93 = __toESM(require_react(), 1);
var CollapsibleRootProvider = (0, import_react93.forwardRef)(
  (props29, ref2) => {
    const [{ value: collapsible }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(collapsible.getRootProps(), localProps);
    return (0, import_jsx_runtime38.jsx)(CollapsibleProvider, { value: collapsible, children: (0, import_jsx_runtime38.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
CollapsibleRootProvider.displayName = "CollapsibleRootProvider";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible-trigger.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);
var CollapsibleTrigger = (0, import_react95.forwardRef)(
  (props29, ref2) => {
    const collapsible = useCollapsibleContext();
    const mergedProps = mergeProps(collapsible.getTriggerProps(), props29);
    return (0, import_jsx_runtime39.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
CollapsibleTrigger.displayName = "CollapsibleTrigger";

// node_modules/@ark-ui/react/dist/components/collapsible/collapsible.js
var collapsible_exports = {};
__export(collapsible_exports, {
  Content: () => CollapsibleContent,
  Context: () => CollapsibleContext,
  Root: () => CollapsibleRoot,
  RootProvider: () => CollapsibleRootProvider,
  Trigger: () => CollapsibleTrigger
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react97 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-area-props-context.js
var [ColorPickerAreaPropsProvider, useColorPickerAreaPropsContext] = createContext({
  name: "ColorPickerAreaContext",
  hookName: "useColorPickerAreaContext",
  providerName: "<ColorPickerAreaProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-context.js
var [ColorPickerProvider, useColorPickerContext] = createContext({
  name: "ColorPickerContext",
  hookName: "useColorPickerContext",
  providerName: "<ColorPickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area.js
var ColorPickerArea = (0, import_react97.forwardRef)((props29, ref2) => {
  const [areaProps, localProps] = createSplitProps2()(props29, ["xChannel", "yChannel"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getAreaProps(areaProps), localProps);
  return (0, import_jsx_runtime40.jsx)(ColorPickerAreaPropsProvider, { value: areaProps, children: (0, import_jsx_runtime40.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ColorPickerArea.displayName = "ColorPickerArea";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-background.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react99 = __toESM(require_react(), 1);
var ColorPickerAreaBackground = (0, import_react99.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps(colorPicker.getAreaBackgroundProps(areaProps), props29);
    return (0, import_jsx_runtime41.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaBackground.displayName = "ColorPickerAreaBackground";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-area-thumb.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);
var ColorPickerAreaThumb = (0, import_react101.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const areaProps = useColorPickerAreaPropsContext();
    const mergedProps = mergeProps(colorPicker.getAreaThumbProps(areaProps), props29);
    return (0, import_jsx_runtime42.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerAreaThumb.displayName = "ColorPickerAreaThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-input.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react103 = __toESM(require_react(), 1);
var ColorPickerChannelInput = (0, import_react103.forwardRef)(
  (props29, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props29, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getChannelInputProps(channelProps), localProps);
    return (0, import_jsx_runtime43.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerChannelInput.displayName = "ColorPickerChannelInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react105 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-channel-props-context.js
var [ColorPickerChannelPropsProvider, useColorPickerChannelPropsContext] = createContext({
  name: "ColorPickerChannelSliderContext",
  hookName: "useColorPickerChannelSliderContext",
  providerName: "<ColorPickerChannelSliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider.js
var ColorPickerChannelSlider = (0, import_react105.forwardRef)(
  (props29, ref2) => {
    const [channelProps, localProps] = createSplitProps2()(props29, [
      "channel",
      "orientation"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getChannelSliderProps(channelProps), localProps);
    return (0, import_jsx_runtime44.jsx)(ColorPickerChannelPropsProvider, { value: channelProps, children: (0, import_jsx_runtime44.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerChannelSlider.displayName = "ColorPickerChannelSlider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-thumb.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);
var ColorPickerChannelSliderThumb = (0, import_react107.forwardRef)((props29, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps(colorPicker.getChannelSliderThumbProps(channelProps), props29);
  return (0, import_jsx_runtime45.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderThumb.displayName = "ColorPickerChannelSliderThumb";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-channel-slider-track.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react109 = __toESM(require_react(), 1);
var ColorPickerChannelSliderTrack = (0, import_react109.forwardRef)((props29, ref2) => {
  const colorPicker = useColorPickerContext();
  const channelProps = useColorPickerChannelPropsContext();
  const mergedProps = mergeProps(colorPicker.getChannelSliderTrackProps(channelProps), props29);
  return (0, import_jsx_runtime46.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerChannelSliderTrack.displayName = "ColorPickerChannelSliderTrack";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-content.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react111 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/presence/use-presence-context.js
var [PresenceProvider, usePresenceContext] = createContext({
  name: "PresenceContext",
  hookName: "usePresenceContext",
  providerName: "<PresenceProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-content.js
var ColorPickerContent = (0, import_react111.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(
      colorPicker.getContentProps(),
      presence.getPresenceProps(ref2),
      props29
    );
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime47.jsx)(ark.div, { ...mergedProps });
  }
);
ColorPickerContent.displayName = "ColorPickerContent";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-context.js
var ColorPickerContext = (props29) => props29.children(useColorPickerContext());

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-control.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
var ColorPickerControl = (0, import_react113.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getControlProps(), props29);
    return (0, import_jsx_runtime48.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerControl.displayName = "ColorPickerControl";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-eye-dropper-trigger.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react115 = __toESM(require_react(), 1);
var ColorPickerEyeDropperTrigger = (0, import_react115.forwardRef)((props29, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getEyeDropperTriggerProps(), props29);
  return (0, import_jsx_runtime49.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerEyeDropperTrigger.displayName = "ColorPickerEyeDropperTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-select.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var import_react117 = __toESM(require_react(), 1);
var ColorPickerFormatSelect = (0, import_react117.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getFormatSelectProps(), props29);
    return (0, import_jsx_runtime50.jsx)(ark.select, { ...mergedProps, ref: ref2, children: ["rgba", "hsla", "hsba"].map((format) => (0, import_jsx_runtime50.jsx)(ark.option, { value: format, children: format }, format)) });
  }
);
ColorPickerFormatSelect.displayName = "ColorPickerFormatSelect";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-format-trigger.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react119 = __toESM(require_react(), 1);
var ColorPickerFormatTrigger = (0, import_react119.forwardRef)((props29, ref2) => {
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getFormatTriggerProps(), props29);
  return (0, import_jsx_runtime51.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerFormatTrigger.displayName = "ColorPickerFormatTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-hidden-input.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react121 = __toESM(require_react(), 1);
var ColorPickerHiddenInput = (0, import_react121.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime52.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerHiddenInput.displayName = "ColorPickerHiddenInput";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-label.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react123 = __toESM(require_react(), 1);
var ColorPickerLabel = (0, import_react123.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getLabelProps(), props29);
    return (0, import_jsx_runtime53.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerLabel.displayName = "ColorPickerLabel";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-positioner.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react125 = __toESM(require_react(), 1);
var ColorPickerPositioner = (0, import_react125.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getPositionerProps(), props29);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime54.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerPositioner.displayName = "ColorPickerPositioner";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react131 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/presence/split-presence-props.js
var splitPresenceProps = (props29) => createSplitProps2()(props29, [
  "immediate",
  "lazyMount",
  "onExitComplete",
  "present",
  "unmountOnExit"
]);

// node_modules/@zag-js/presence/dist/index.mjs
function connect34(state2, send, _normalize) {
  const present = state2.matches("mounted", "unmountSuspended");
  return {
    skip: !state2.context.initial && present,
    present,
    setNode(node) {
      if (!node)
        return;
      send({ type: "NODE.SET", node });
    },
    unmount() {
      send({ type: "UNMOUNT" });
    }
  };
}
function getAnimationName(styles) {
  return (styles == null ? void 0 : styles.animationName) || "none";
}
function machine33(ctx) {
  return createMachine(
    {
      initial: ctx.present ? "mounted" : "unmounted",
      context: {
        node: null,
        styles: null,
        unmountAnimationName: null,
        prevAnimationName: null,
        present: false,
        initial: false,
        ...ctx
      },
      exit: ["clearInitial"],
      watch: {
        present: ["setInitial", "syncPresence"]
      },
      on: {
        "NODE.SET": {
          actions: ["setNode", "setStyles"]
        }
      },
      states: {
        mounted: {
          on: {
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            "UNMOUNT.SUSPEND": "unmountSuspended"
          }
        },
        unmountSuspended: {
          activities: ["trackAnimationEvents"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            },
            "ANIMATION.END": {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            },
            UNMOUNT: {
              target: "unmounted",
              actions: ["invokeOnExitComplete"]
            }
          }
        },
        unmounted: {
          entry: ["clearPrevAnimationName"],
          on: {
            MOUNT: {
              target: "mounted",
              actions: ["setPrevAnimationName"]
            }
          }
        }
      }
    },
    {
      actions: {
        setInitial(ctx2) {
          ctx2.initial = true;
        },
        clearInitial(ctx2) {
          ctx2.initial = false;
        },
        invokeOnExitComplete(ctx2) {
          var _a;
          (_a = ctx2.onExitComplete) == null ? void 0 : _a.call(ctx2);
        },
        setNode(ctx2, evt) {
          ctx2.node = ref(evt.node);
        },
        setStyles(ctx2, evt) {
          const win = evt.node.ownerDocument.defaultView || window;
          ctx2.styles = ref(win.getComputedStyle(evt.node));
        },
        syncPresence(ctx2, _evt, { send }) {
          if (ctx2.present) {
            send({ type: "MOUNT", src: "presence.changed" });
            return;
          }
          const animationName = getAnimationName(ctx2.styles);
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            var _a;
            ctx2.unmountAnimationName = animationName;
            if (animationName === "none" || animationName === ctx2.prevAnimationName || ((_a = ctx2.styles) == null ? void 0 : _a.display) === "none") {
              send({ type: "UNMOUNT", src: "presence.changed" });
            } else {
              send({ type: "UNMOUNT.SUSPEND" });
            }
          });
        },
        setPrevAnimationName(ctx2) {
          const exec2 = ctx2.immediate ? queueMicrotask : requestAnimationFrame;
          exec2(() => {
            ctx2.prevAnimationName = getAnimationName(ctx2.styles);
          });
        },
        clearPrevAnimationName(ctx2) {
          ctx2.prevAnimationName = null;
        }
      },
      activities: {
        trackAnimationEvents(ctx2, _evt, { send }) {
          const node = ctx2.node;
          if (!node)
            return;
          const onStart = (event) => {
            if (event.target === node) {
              ctx2.prevAnimationName = getAnimationName(ctx2.styles);
            }
          };
          const onEnd = (event) => {
            const animationName = getAnimationName(ctx2.styles);
            if (event.target === node && animationName === ctx2.unmountAnimationName) {
              send({ type: "UNMOUNT", src: "animationend" });
            }
          };
          node.addEventListener("animationstart", onStart);
          node.addEventListener("animationcancel", onEnd);
          node.addEventListener("animationend", onEnd);
          return () => {
            node.removeEventListener("animationstart", onStart);
            node.removeEventListener("animationcancel", onEnd);
            node.removeEventListener("animationend", onEnd);
          };
        }
      }
    }
  );
}
var props28 = createProps()(["onExitComplete", "present", "immediate"]);

// node_modules/@ark-ui/react/dist/components/presence/use-presence.js
var import_react127 = __toESM(require_react(), 1);
var usePresence = (props29) => {
  const { lazyMount, unmountOnExit, ...rest } = props29;
  const wasEverPresent = (0, import_react127.useRef)(false);
  const context = {
    ...rest,
    onExitComplete: useEvent(props29.onExitComplete)
  };
  const [state2, send] = useMachine(machine33(context), { context });
  const api = connect34(state2, send, normalizeProps);
  if (api.present) {
    wasEverPresent.current = true;
  }
  const unmounted = !api.present && !wasEverPresent.current && lazyMount || unmountOnExit && !api.present && wasEverPresent.current;
  const getPresenceProps = (ref2) => ({
    ref: composeRefs(api.setNode, ref2),
    "data-state": props29.present ? "open" : "closed",
    hidden: !api.present
  });
  return {
    getPresenceProps,
    present: api.present,
    unmounted
  };
};

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker.js
var import_react129 = __toESM(require_react(), 1);
var useColorPicker = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react129.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29,
    value: props29.value ? parse(props29.value) : props29.defaultValue ? parse(props29.defaultValue) : void 0
  };
  const context = {
    ...initialContext,
    value: props29.value ? parse(props29.value) : void 0,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props29.onValueChangeEnd)
  };
  const [state2, send] = useMachine(machine7(initialContext), { context });
  return connect7(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root.js
var ColorPickerRoot = (0, import_react131.forwardRef)((props29, ref2) => {
  const [presenceProps, colorPickerProps] = splitPresenceProps(props29);
  const [useColorPickerProps, localProps] = createSplitProps2()(
    colorPickerProps,
    [
      "closeOnSelect",
      "defaultOpen",
      "defaultValue",
      "disabled",
      "format",
      "id",
      "ids",
      "initialFocusEl",
      "name",
      "name",
      "onFocusOutside",
      "onFormatChange",
      "onInteractOutside",
      "onOpenChange",
      "onPointerDownOutside",
      "onValueChange",
      "onValueChangeEnd",
      "open",
      "positioning",
      "readOnly",
      "value"
    ]
  );
  const colorPicker = useColorPicker(useColorPickerProps);
  const presence = usePresence(mergeProps({ present: colorPicker.open }, presenceProps));
  const mergedProps = mergeProps(colorPicker.getRootProps(), localProps);
  return (0, import_jsx_runtime55.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime55.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime55.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
ColorPickerRoot.displayName = "ColorPickerRoot";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-root-provider.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react133 = __toESM(require_react(), 1);
var ColorPickerRootProvider = (0, import_react133.forwardRef)(
  (props29, ref2) => {
    const [presenceProps, colorPickerProps] = splitPresenceProps(props29);
    const [{ value: colorPicker }, localProps] = createSplitProps2()(
      colorPickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps({ present: colorPicker.open }, presenceProps));
    const mergedProps = mergeProps(colorPicker.getRootProps(), localProps);
    return (0, import_jsx_runtime56.jsx)(ColorPickerProvider, { value: colorPicker, children: (0, import_jsx_runtime56.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime56.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
ColorPickerRootProvider.displayName = "ColorPickerRootProvider";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react135 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/color-picker/use-color-picker-swatch-props-context.js
var [ColorPickerSwatchPropsProvider, useColorPickerSwatchPropsContext] = createContext({
  name: "ColorPickerSwatchContext",
  hookName: "useColorPickerSwatchContext",
  providerName: "<ColorPickerSwatchProvider />"
});

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch.js
var ColorPickerSwatch = (0, import_react135.forwardRef)(
  (props29, ref2) => {
    const [swatwchProps, localProps] = createSplitProps2()(props29, [
      "respectAlpha",
      "value"
    ]);
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getSwatchProps(swatwchProps), localProps);
    return (0, import_jsx_runtime57.jsx)(ColorPickerSwatchPropsProvider, { value: swatwchProps, children: (0, import_jsx_runtime57.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ColorPickerSwatch.displayName = "ColorPickerSwatch";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-group.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react137 = __toESM(require_react(), 1);
var ColorPickerSwatchGroup = (0, import_react137.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getSwatchGroupProps(), props29);
    return (0, import_jsx_runtime58.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerSwatchGroup.displayName = "ColorPickerSwatchGroup";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-indicator.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react139 = __toESM(require_react(), 1);
var ColorPickerSwatchIndicator = (0, import_react139.forwardRef)((props29, ref2) => {
  const colorPicker = useColorPickerContext();
  const swatchProps = useColorPickerSwatchPropsContext();
  const mergedProps = mergeProps(colorPicker.getSwatchIndicatorProps(swatchProps), props29);
  return (0, import_jsx_runtime59.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchIndicator.displayName = "ColorPickerSwatchIndicator";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-swatch-trigger.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react141 = __toESM(require_react(), 1);
var ColorPickerSwatchTrigger = (0, import_react141.forwardRef)((props29, ref2) => {
  const [triggerProps2, localProps] = createSplitProps2()(props29, [
    "value",
    "disabled"
  ]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getSwatchTriggerProps(triggerProps2), localProps);
  return (0, import_jsx_runtime60.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ColorPickerSwatchTrigger.displayName = "ColorPickerSwatchTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-transparency-grid.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react143 = __toESM(require_react(), 1);
var ColorPickerTransparencyGrid = (0, import_react143.forwardRef)((props29, ref2) => {
  const [gridProps, localProps] = createSplitProps2()(props29, ["size"]);
  const colorPicker = useColorPickerContext();
  const mergedProps = mergeProps(colorPicker.getTransparencyGridProps(gridProps), localProps);
  return (0, import_jsx_runtime61.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ColorPickerTransparencyGrid.displayName = "ColorPickerTransparencyGrid";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-trigger.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react145 = __toESM(require_react(), 1);
var ColorPickerTrigger = (0, import_react145.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    const mergedProps = mergeProps(colorPicker.getTriggerProps(), props29);
    return (0, import_jsx_runtime62.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ColorPickerTrigger.displayName = "ColorPickerTrigger";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-value-text.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react146 = __toESM(require_react(), 1);
var ColorPickerValueText = (0, import_react146.forwardRef)(
  (props29, ref2) => {
    const colorPicker = useColorPickerContext();
    return (0, import_jsx_runtime63.jsx)(ark.span, { ...anatomy10.build().valueText.attrs, ...props29, ref: ref2, children: props29.children || colorPicker.valueAsString });
  }
);
ColorPickerValueText.displayName = "ColorPickerValueText";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker-view.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react147 = __toESM(require_react(), 1);
var ColorPickerView = (0, import_react147.forwardRef)((props29, ref2) => {
  const colorPicker = useColorPickerContext();
  if (colorPicker.format !== props29.format) {
    return null;
  }
  return (0, import_jsx_runtime64.jsx)(
    ark.div,
    {
      ref: ref2,
      "data-format": props29.format,
      ...anatomy10.build().view.attrs,
      ...props29
    }
  );
});
ColorPickerView.displayName = "ColorPickerView";

// node_modules/@ark-ui/react/dist/components/color-picker/color-picker.js
var color_picker_exports = {};
__export(color_picker_exports, {
  Area: () => ColorPickerArea,
  AreaBackground: () => ColorPickerAreaBackground,
  AreaThumb: () => ColorPickerAreaThumb,
  ChannelInput: () => ColorPickerChannelInput,
  ChannelSlider: () => ColorPickerChannelSlider,
  ChannelSliderThumb: () => ColorPickerChannelSliderThumb,
  ChannelSliderTrack: () => ColorPickerChannelSliderTrack,
  Content: () => ColorPickerContent,
  Context: () => ColorPickerContext,
  Control: () => ColorPickerControl,
  EyeDropperTrigger: () => ColorPickerEyeDropperTrigger,
  FormatSelect: () => ColorPickerFormatSelect,
  FormatTrigger: () => ColorPickerFormatTrigger,
  HiddenInput: () => ColorPickerHiddenInput,
  Label: () => ColorPickerLabel,
  Positioner: () => ColorPickerPositioner,
  Root: () => ColorPickerRoot,
  Swatch: () => ColorPickerSwatch,
  SwatchGroup: () => ColorPickerSwatchGroup,
  SwatchIndicator: () => ColorPickerSwatchIndicator,
  SwatchTrigger: () => ColorPickerSwatchTrigger,
  TransparencyGrid: () => ColorPickerTransparencyGrid,
  Trigger: () => ColorPickerTrigger,
  ValueText: () => ColorPickerValueText,
  View: () => ColorPickerView
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-clear-trigger.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react149 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-context.js
var [ComboboxProvider, useComboboxContext] = createContext({
  name: "ComboboxContext",
  hookName: "useComboboxContext",
  providerName: "<ComboboxProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-clear-trigger.js
var ComboboxClearTrigger = (0, import_react149.forwardRef)(
  (props29, ref2) => {
    const combobox = useComboboxContext();
    const mergedProps = mergeProps(combobox.getClearTriggerProps(), props29);
    return (0, import_jsx_runtime65.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ComboboxClearTrigger.displayName = "ComboboxClearTrigger";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-content.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react151 = __toESM(require_react(), 1);
var ComboboxContent = (0, import_react151.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(combobox.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime66.jsx)(ark.div, { ...mergedProps });
});
ComboboxContent.displayName = "ComboboxContent";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-context.js
var ComboboxContext = (props29) => props29.children(useComboboxContext());

// node_modules/@ark-ui/react/dist/components/combobox/combobox-control.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react153 = __toESM(require_react(), 1);
var ComboboxControl = (0, import_react153.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps(combobox.getControlProps(), props29);
  return (0, import_jsx_runtime67.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ComboboxControl.displayName = "ComboboxControl";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-input.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react155 = __toESM(require_react(), 1);
var ComboboxInput = (0, import_react155.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps(combobox.getInputProps(), props29);
  return (0, import_jsx_runtime68.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
ComboboxInput.displayName = "ComboboxInput";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react157 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-context.js
var [ComboboxItemProvider, useComboboxItemContext] = createContext(
  {
    name: "ComboboxItemContext",
    hookName: "useComboboxItemContext",
    providerName: "<ComboboxItemProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-props-context.js
var [ComboboxItemPropsProvider, useComboboxItemPropsContext] = createContext({
  name: "ComboboxItemPropsContext",
  hookName: "useComboboxItemPropsContext",
  providerName: "<ComboboxItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item.js
var ComboboxItem = (0, import_react157.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["item", "persistFocus"]);
  const combobox = useComboboxContext();
  const mergedProps = mergeProps(combobox.getItemProps(itemProps10), localProps);
  const itemState = combobox.getItemState(itemProps10);
  return (0, import_jsx_runtime69.jsx)(ComboboxItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime69.jsx)(ComboboxItemProvider, { value: itemState, children: (0, import_jsx_runtime69.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
ComboboxItem.displayName = "ComboboxItem";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-context.js
var ComboboxItemContext = (props29) => props29.children(useComboboxItemContext());

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var import_react159 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox-item-group-props-context.js
var [ComboboxItemGroupPropsProvider, useComboboxItemGroupPropsContext] = createContext({
  name: "ComboboxItemGroupPropsContext",
  hookName: "useComboboxItemGroupPropsContext",
  providerName: "<ComboboxItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group.js
var ComboboxItemGroup = (0, import_react159.forwardRef)(
  (props29, ref2) => {
    const id = (0, import_react159.useId)();
    const [_itemGroupProps, localProps] = createSplitProps2()(props29, ["id"]);
    const itemGroupProps3 = { id, ..._itemGroupProps };
    const combobox = useComboboxContext();
    const mergedProps = mergeProps(combobox.getItemGroupProps(itemGroupProps3), localProps);
    return (0, import_jsx_runtime70.jsx)(ComboboxItemGroupPropsProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime70.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ComboboxItemGroup.displayName = "ComboboxItemGroup";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-group-label.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);
var import_react161 = __toESM(require_react(), 1);
var ComboboxItemGroupLabel = (0, import_react161.forwardRef)(
  (props29, ref2) => {
    const combobox = useComboboxContext();
    const itemGroupProps3 = useComboboxItemGroupPropsContext();
    const mergedProps = mergeProps(
      combobox.getItemGroupLabelProps({ htmlFor: itemGroupProps3.id }),
      props29
    );
    return (0, import_jsx_runtime71.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ComboboxItemGroupLabel.displayName = "ComboboxItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-indicator.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react163 = __toESM(require_react(), 1);
var ComboboxItemIndicator = (0, import_react163.forwardRef)(
  (props29, ref2) => {
    const combobox = useComboboxContext();
    const itemProps10 = useComboboxItemPropsContext();
    const mergedProps = mergeProps(combobox.getItemIndicatorProps(itemProps10), props29);
    return (0, import_jsx_runtime72.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ComboboxItemIndicator.displayName = "ComboboxItemIndicator";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-item-text.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react165 = __toESM(require_react(), 1);
var ComboboxItemText = (0, import_react165.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const itemProps10 = useComboboxItemPropsContext();
  const mergedProps = mergeProps(combobox.getItemTextProps(itemProps10), props29);
  return (0, import_jsx_runtime73.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
ComboboxItemText.displayName = "ComboboxItemText";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-label.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react167 = __toESM(require_react(), 1);
var ComboboxLabel = (0, import_react167.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps(combobox.getLabelProps(), props29);
  return (0, import_jsx_runtime74.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ComboboxLabel.displayName = "ComboboxLabel";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-list.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react169 = __toESM(require_react(), 1);
var ComboboxList = (0, import_react169.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps(combobox.getListProps(), props29);
  return (0, import_jsx_runtime75.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ComboboxList.displayName = "ComboboxList";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-positioner.js
var import_jsx_runtime76 = __toESM(require_jsx_runtime(), 1);
var import_react171 = __toESM(require_react(), 1);
var ComboboxPositioner = (0, import_react171.forwardRef)(
  (props29, ref2) => {
    const combobox = useComboboxContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(combobox.getPositionerProps(), props29);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime76.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
ComboboxPositioner.displayName = "ComboboxPositioner";

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root.js
var import_jsx_runtime77 = __toESM(require_jsx_runtime(), 1);
var import_react175 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/combobox/use-combobox.js
var import_react173 = __toESM(require_react(), 1);
var useCombobox = (props29) => {
  const [collectionOptions, comboboxProps] = createSplitProps2()(props29, [
    "isItemDisabled",
    "itemToValue",
    "itemToString",
    "items"
  ]);
  const collection3 = (0, import_react173.useMemo)(
    () => collection(collectionOptions),
    Object.values(collectionOptions)
  );
  const { dir } = useLocaleContext();
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const initialContext = {
    id: (0, import_react173.useId)(),
    dir,
    getRootNode: getRootNode2,
    collection: collection3,
    open: props29.defaultOpen,
    value: props29.defaultValue,
    "open.controlled": props29.open !== void 0,
    ...comboboxProps
  };
  const context = {
    ...initialContext,
    collection: collection3,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onInputValueChange: useEvent(props29.onInputValueChange, { sync: true }),
    onHighlightChange: useEvent(props29.onHighlightChange),
    onOpenChange: useEvent(props29.onOpenChange)
  };
  const [state2, send] = useMachine(machine8(initialContext), {
    context
  });
  return connect8(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root.js
var ComboboxImpl = (props29, ref2) => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props29);
  const [useComboboxProps, localProps] = createSplitProps2()(comboboxProps, [
    "allowCustomValue",
    "autoFocus",
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "disableLayer",
    "form",
    "getSelectionValue",
    "highlightedValue",
    "id",
    "ids",
    "inputBehavior",
    "inputValue",
    "invalid",
    "isItemDisabled",
    "items",
    "itemToString",
    "itemToValue",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onOpenChange",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "openOnChange",
    "openOnClick",
    "openOnKeyPress",
    "placeholder",
    "positioning",
    "readOnly",
    "scrollToIndexFn",
    "selectionBehavior",
    "translations",
    "value"
  ]);
  const combobox = useCombobox(useComboboxProps);
  const presence = usePresence(mergeProps({ present: combobox.open }, presenceProps));
  const mergedProps = mergeProps(combobox.getRootProps(), localProps);
  return (0, import_jsx_runtime77.jsx)(ComboboxProvider, { value: combobox, children: (0, import_jsx_runtime77.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime77.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var ComboboxRoot = (0, import_react175.forwardRef)(ComboboxImpl);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-root-provider.js
var import_jsx_runtime78 = __toESM(require_jsx_runtime(), 1);
var import_react177 = __toESM(require_react(), 1);
var ComboboxImpl2 = (props29, ref2) => {
  const [presenceProps, comboboxProps] = splitPresenceProps(props29);
  const [{ value: combobox }, localProps] = createSplitProps2()(
    comboboxProps,
    ["value"]
  );
  const presence = usePresence(mergeProps({ present: combobox.open }, presenceProps));
  const mergedProps = mergeProps(combobox.getRootProps(), localProps);
  return (0, import_jsx_runtime78.jsx)(ComboboxProvider, { value: combobox, children: (0, import_jsx_runtime78.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime78.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var ComboboxRootProvider = (0, import_react177.forwardRef)(ComboboxImpl2);

// node_modules/@ark-ui/react/dist/components/combobox/combobox-trigger.js
var import_jsx_runtime79 = __toESM(require_jsx_runtime(), 1);
var import_react179 = __toESM(require_react(), 1);
var ComboboxTrigger = (0, import_react179.forwardRef)((props29, ref2) => {
  const combobox = useComboboxContext();
  const mergedProps = mergeProps(combobox.getTriggerProps(), props29);
  return (0, import_jsx_runtime79.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ComboboxTrigger.displayName = "ComboboxTrigger";

// node_modules/@ark-ui/react/dist/components/combobox/combobox.js
var combobox_exports = {};
__export(combobox_exports, {
  ClearTrigger: () => ComboboxClearTrigger,
  Content: () => ComboboxContent,
  Context: () => ComboboxContext,
  Control: () => ComboboxControl,
  Input: () => ComboboxInput,
  Item: () => ComboboxItem,
  ItemContext: () => ComboboxItemContext,
  ItemGroup: () => ComboboxItemGroup,
  ItemGroupLabel: () => ComboboxItemGroupLabel,
  ItemIndicator: () => ComboboxItemIndicator,
  ItemText: () => ComboboxItemText,
  Label: () => ComboboxLabel,
  List: () => ComboboxList,
  Positioner: () => ComboboxPositioner,
  Root: () => ComboboxRoot,
  RootProvider: () => ComboboxRootProvider,
  Trigger: () => ComboboxTrigger
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-clear-trigger.js
var import_jsx_runtime80 = __toESM(require_jsx_runtime(), 1);
var import_react181 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-context.js
var [DatePickerProvider, useDatePickerContext] = createContext({
  name: "DatePickerContext",
  hookName: "useDatePickerContext",
  providerName: "<DatePickerProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-clear-trigger.js
var DatePickerClearTrigger = (0, import_react181.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getClearTriggerProps(), props29);
    return (0, import_jsx_runtime80.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerClearTrigger.displayName = "DatePickerClearTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-content.js
var import_jsx_runtime81 = __toESM(require_jsx_runtime(), 1);
var import_react183 = __toESM(require_react(), 1);
var DatePickerContent = (0, import_react183.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(
      datePicker.getContentProps(),
      presence.getPresenceProps(ref2),
      props29
    );
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime81.jsx)(ark.div, { ...mergedProps });
  }
);
DatePickerContent.displayName = "DatePickerContent";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-context.js
var DatePickerContext = (props29) => props29.children(useDatePickerContext());

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-control.js
var import_jsx_runtime82 = __toESM(require_jsx_runtime(), 1);
var import_react185 = __toESM(require_react(), 1);
var DatePickerControl = (0, import_react185.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getControlProps(), props29);
    return (0, import_jsx_runtime82.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DatePickerControl.displayName = "DatePickerControl";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-input.js
var import_jsx_runtime83 = __toESM(require_jsx_runtime(), 1);
var import_react187 = __toESM(require_react(), 1);
var DatePickerInput = (0, import_react187.forwardRef)((props29, ref2) => {
  const [inputProps2, localProps] = createSplitProps2()(props29, ["index"]);
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps(datePicker.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime83.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
DatePickerInput.displayName = "DatePickerInput";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-label.js
var import_jsx_runtime84 = __toESM(require_jsx_runtime(), 1);
var import_react189 = __toESM(require_react(), 1);
var DatePickerLabel = (0, import_react189.forwardRef)((props29, ref2) => {
  const datePicker = useDatePickerContext();
  const mergedProps = mergeProps(datePicker.getLabelProps(), props29);
  return (0, import_jsx_runtime84.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
DatePickerLabel.displayName = "DatePickerLabel";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-month-select.js
var import_jsx_runtime85 = __toESM(require_jsx_runtime(), 1);
var import_react191 = __toESM(require_react(), 1);
var DatePickerMonthSelect = (0, import_react191.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getMonthSelectProps(), props29);
    return (0, import_jsx_runtime85.jsx)(ark.select, { ...mergedProps, ref: ref2, children: datePicker.getMonths().map((month, i) => (0, import_jsx_runtime85.jsx)("option", { value: month.value, children: month.label }, i)) });
  }
);
DatePickerMonthSelect.displayName = "DatePickerMonthSelect";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-next-trigger.js
var import_jsx_runtime86 = __toESM(require_jsx_runtime(), 1);
var import_react193 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-view-props-context.js
var [DatePickerViewPropsProvider, useDatePickerViewPropsContext] = createContext({
  name: "DatePickerViewContext",
  hookName: "useDatePickerViewContext",
  providerName: "<DatePickerViewProvider />",
  strict: false,
  defaultValue: { view: "day" }
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-next-trigger.js
var DatePickerNextTrigger = (0, import_react193.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps(datePicker.getNextTriggerProps(viewProps2), props29);
    return (0, import_jsx_runtime86.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerNextTrigger.displayName = "DatePickerNextTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-positioner.js
var import_jsx_runtime87 = __toESM(require_jsx_runtime(), 1);
var import_react195 = __toESM(require_react(), 1);
var DatePickerPositioner = (0, import_react195.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getPositionerProps(), props29);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime87.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DatePickerPositioner.displayName = "DatePickerPositioner";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-preset-trigger.js
var import_jsx_runtime88 = __toESM(require_jsx_runtime(), 1);
var import_react197 = __toESM(require_react(), 1);
var DatePickerPresetTrigger = (0, import_react197.forwardRef)(
  (props29, ref2) => {
    const [presetTriggerProps2, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getPresetTriggerProps(presetTriggerProps2), localProps);
    return (0, import_jsx_runtime88.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerPresetTrigger.displayName = "DatePickerPresetTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-prev-trigger.js
var import_jsx_runtime89 = __toESM(require_jsx_runtime(), 1);
var import_react199 = __toESM(require_react(), 1);
var DatePickerPrevTrigger = (0, import_react199.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps(datePicker.getPrevTriggerProps(viewProps2), props29);
    return (0, import_jsx_runtime89.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerPrevTrigger.displayName = "DatePickerPrevTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-range-text.js
var import_jsx_runtime90 = __toESM(require_jsx_runtime(), 1);
var import_react201 = __toESM(require_react(), 1);
var DatePickerRangeText = (0, import_react201.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getRangeTextProps(), props29);
    return (0, import_jsx_runtime90.jsx)(ark.div, { ...mergedProps, ref: ref2, children: datePicker.visibleRangeText.start });
  }
);
DatePickerRangeText.displayName = "DatePickerRangeText";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root.js
var import_jsx_runtime91 = __toESM(require_jsx_runtime(), 1);
var import_react205 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker.js
var import_react203 = __toESM(require_react(), 1);
var useDatePicker = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react203.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29,
    focusedValue: props29.focusedValue ? parse2(props29.focusedValue) : void 0,
    value: props29.defaultValue ? parse2(props29.defaultValue) : void 0,
    max: props29.max ? parse2(props29.max) : void 0,
    min: props29.min ? parse2(props29.min) : void 0
  };
  const context = {
    ...initialContext,
    max: props29.max ? parse2(props29.max) : void 0,
    min: props29.min ? parse2(props29.min) : void 0,
    value: props29.value ? parse2(props29.value) : void 0,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onFocusChange: useEvent(props29.onFocusChange),
    onViewChange: useEvent(props29.onViewChange),
    onOpenChange: useEvent(props29.onOpenChange)
  };
  const [state2, send] = useMachine(machine9(initialContext), { context });
  return connect9(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root.js
var DatePickerRoot = (0, import_react205.forwardRef)((props29, ref2) => {
  const [presenceProps, datePickerProps] = splitPresenceProps(props29);
  const [useDatePickerProps, localProps] = createSplitProps2()(datePickerProps, [
    "closeOnSelect",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "fixedWeeks",
    "focusedValue",
    "format",
    "id",
    "ids",
    "isDateUnavailable",
    "isDateUnavailable",
    "locale",
    "max",
    "min",
    "modal",
    "name",
    "numOfMonths",
    "onFocusChange",
    "onOpenChange",
    "onValueChange",
    "onViewChange",
    "open",
    "positioning",
    "readOnly",
    "selectionMode",
    "startOfWeek",
    "timeZone",
    "translations",
    "value",
    "view"
  ]);
  const datePicker = useDatePicker(useDatePickerProps);
  const presence = usePresence(mergeProps({ present: datePicker.open }, presenceProps));
  const mergedProps = mergeProps(datePicker.getRootProps(), localProps);
  return (0, import_jsx_runtime91.jsx)(DatePickerProvider, { value: datePicker, children: (0, import_jsx_runtime91.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime91.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
DatePickerRoot.displayName = "DatePickerRoot";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-root-provider.js
var import_jsx_runtime92 = __toESM(require_jsx_runtime(), 1);
var import_react207 = __toESM(require_react(), 1);
var DatePickerRootProvider = (0, import_react207.forwardRef)(
  (props29, ref2) => {
    const [presenceProps, datePickerProps] = splitPresenceProps(props29);
    const [{ value: datePicker }, localProps] = createSplitProps2()(
      datePickerProps,
      ["value"]
    );
    const presence = usePresence(mergeProps({ present: datePicker.open }, presenceProps));
    const mergedProps = mergeProps(datePicker.getRootProps(), localProps);
    return (0, import_jsx_runtime92.jsx)(DatePickerProvider, { value: datePicker, children: (0, import_jsx_runtime92.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime92.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
  }
);
DatePickerRootProvider.displayName = "DatePickerRootProvider";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table.js
var import_jsx_runtime93 = __toESM(require_jsx_runtime(), 1);
var import_react209 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-table-props-context.js
var [DatePickerTablePropsProvider, useDatePickerTablePropsContext] = createContext({
  name: "DatePickerTableContext",
  hookName: "useDatePickerTableContext",
  providerName: "<DatePickerTableProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table.js
var DatePickerTable = (0, import_react209.forwardRef)((props29, ref2) => {
  const [{ columns }, localProps] = createSplitProps2()(props29, [
    "columns"
  ]);
  const datePicker = useDatePickerContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const tableProps2 = { columns, id: (0, import_react209.useId)(), ...viewProps2 };
  const mergedProps = mergeProps(datePicker.getTableProps(tableProps2), localProps);
  return (0, import_jsx_runtime93.jsx)(DatePickerTablePropsProvider, { value: tableProps2, children: (0, import_jsx_runtime93.jsx)(ark.table, { ...mergedProps, ref: ref2 }) });
});
DatePickerTable.displayName = "DatePickerTable";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-body.js
var import_jsx_runtime94 = __toESM(require_jsx_runtime(), 1);
var import_react211 = __toESM(require_react(), 1);
var DatePickerTableBody = (0, import_react211.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps(datePicker.getTableBodyProps(tableProps2), props29);
    return (0, import_jsx_runtime94.jsx)(ark.tbody, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableBody.displayName = "DatePickerTableBody";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell.js
var import_jsx_runtime95 = __toESM(require_jsx_runtime(), 1);
var import_react213 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/date-picker/use-date-picker-table-cell-props-context.js
var [DatePickerTableCellPropsProvider, useDatePickerTableCellPropsContext] = createContext({
  name: "DatePickerTableCellContext",
  hookName: "useDatePickerTableCellContext",
  providerName: "<DatePickerTableCellProvider />"
});

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell.js
var DatePickerTableCell = (0, import_react213.forwardRef)(
  (props29, ref2) => {
    const [cellProps, localProps] = createSplitProps2()(props29, [
      "disabled",
      "value",
      "visibleRange",
      "columns"
    ]);
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const tableCellProps2 = {
      day: datePicker.getDayTableCellProps,
      month: datePicker.getMonthTableCellProps,
      year: datePicker.getYearTableCellProps
      // @ts-expect-error value is number filter
    }[viewProps2.view](cellProps);
    const mergedProps = mergeProps(tableCellProps2, localProps);
    return (0, import_jsx_runtime95.jsx)(DatePickerTableCellPropsProvider, { value: cellProps, children: (0, import_jsx_runtime95.jsx)(ark.td, { ref: ref2, ...mergedProps }) });
  }
);
DatePickerTableCell.displayName = "DatePickerTableCell";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-cell-trigger.js
var import_jsx_runtime96 = __toESM(require_jsx_runtime(), 1);
var import_react215 = __toESM(require_react(), 1);
var DatePickerTableCellTrigger = (0, import_react215.forwardRef)((props29, ref2) => {
  const datePicker = useDatePickerContext();
  const tableCellProps2 = useDatePickerTableCellPropsContext();
  const viewProps2 = useDatePickerViewPropsContext();
  const viewMap = {
    day: datePicker.getDayTableCellTriggerProps,
    month: datePicker.getMonthTableCellTriggerProps,
    year: datePicker.getYearTableCellTriggerProps
  };
  const viewFn = viewMap[viewProps2.view];
  const triggerProps2 = viewFn(tableCellProps2);
  const mergedProps = mergeProps(triggerProps2, props29);
  return (0, import_jsx_runtime96.jsx)(ark.div, { ref: ref2, ...mergedProps });
});
DatePickerTableCellTrigger.displayName = "DatePickerTableCellTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-head.js
var import_jsx_runtime97 = __toESM(require_jsx_runtime(), 1);
var import_react217 = __toESM(require_react(), 1);
var DatePickerTableHead = (0, import_react217.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps(datePicker.getTableHeadProps(tableProps2), props29);
    return (0, import_jsx_runtime97.jsx)(ark.thead, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableHead.displayName = "DatePickerTableHead";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-header.js
var import_jsx_runtime98 = __toESM(require_jsx_runtime(), 1);
var import_react219 = __toESM(require_react(), 1);
var DatePickerTableHeader = (0, import_react219.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps(datePicker.getTableHeaderProps(tableProps2), props29);
    return (0, import_jsx_runtime98.jsx)(ark.th, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableHeader.displayName = "DatePickerTableHeader";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-table-row.js
var import_jsx_runtime99 = __toESM(require_jsx_runtime(), 1);
var import_react221 = __toESM(require_react(), 1);
var DatePickerTableRow = (0, import_react221.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const tableProps2 = useDatePickerTablePropsContext();
    const mergedProps = mergeProps(datePicker.getTableRowProps(tableProps2), props29);
    return (0, import_jsx_runtime99.jsx)(ark.tr, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTableRow.displayName = "DatePickerTableRow";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-trigger.js
var import_jsx_runtime100 = __toESM(require_jsx_runtime(), 1);
var import_react223 = __toESM(require_react(), 1);
var DatePickerTrigger = (0, import_react223.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getTriggerProps(), props29);
    return (0, import_jsx_runtime100.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerTrigger.displayName = "DatePickerTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view.js
var import_jsx_runtime101 = __toESM(require_jsx_runtime(), 1);
var import_react224 = __toESM(require_react(), 1);
var DatePickerView = (0, import_react224.forwardRef)((props29, ref2) => {
  const [viewProps2, localProps] = createSplitProps2()(props29, ["view"]);
  const datePicker = useDatePickerContext();
  return (0, import_jsx_runtime101.jsx)(DatePickerViewPropsProvider, { value: viewProps2, children: (0, import_jsx_runtime101.jsx)(
    ark.div,
    {
      hidden: datePicker.view !== viewProps2.view,
      ...anatomy13.build().view.attrs,
      ...localProps,
      ref: ref2
    }
  ) });
});
DatePickerView.displayName = "DatePickerView";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view-control.js
var import_jsx_runtime102 = __toESM(require_jsx_runtime(), 1);
var import_react226 = __toESM(require_react(), 1);
var DatePickerViewControl = (0, import_react226.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps(datePicker.getViewControlProps(viewProps2), props29);
    return (0, import_jsx_runtime102.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DatePickerViewControl.displayName = "DatePickerViewControl";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-view-trigger.js
var import_jsx_runtime103 = __toESM(require_jsx_runtime(), 1);
var import_react228 = __toESM(require_react(), 1);
var DatePickerViewTrigger = (0, import_react228.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const viewProps2 = useDatePickerViewPropsContext();
    const mergedProps = mergeProps(datePicker.getViewTriggerProps(viewProps2), props29);
    return (0, import_jsx_runtime103.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DatePickerViewTrigger.displayName = "DatePickerViewTrigger";

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker-year-select.js
var import_jsx_runtime104 = __toESM(require_jsx_runtime(), 1);
var import_react230 = __toESM(require_react(), 1);
var DatePickerYearSelect = (0, import_react230.forwardRef)(
  (props29, ref2) => {
    const datePicker = useDatePickerContext();
    const mergedProps = mergeProps(datePicker.getYearSelectProps(), props29);
    return (0, import_jsx_runtime104.jsx)(ark.select, { ...mergedProps, ref: ref2, children: getYearsRange({ from: 1e3, to: 4e3 }).map((year, i) => (0, import_jsx_runtime104.jsx)("option", { value: year, children: year }, i)) });
  }
);
DatePickerYearSelect.displayName = "DatePickerYearSelect";
function getYearsRange(range2) {
  const years = [];
  for (let year = range2.from; year <= range2.to; year += 1) {
    years.push(year);
  }
  return years;
}

// node_modules/@ark-ui/react/dist/components/date-picker/date-picker.js
var date_picker_exports = {};
__export(date_picker_exports, {
  ClearTrigger: () => DatePickerClearTrigger,
  Content: () => DatePickerContent,
  Context: () => DatePickerContext,
  Control: () => DatePickerControl,
  Input: () => DatePickerInput,
  Label: () => DatePickerLabel,
  MonthSelect: () => DatePickerMonthSelect,
  NextTrigger: () => DatePickerNextTrigger,
  Positioner: () => DatePickerPositioner,
  PresetTrigger: () => DatePickerPresetTrigger,
  PrevTrigger: () => DatePickerPrevTrigger,
  RangeText: () => DatePickerRangeText,
  Root: () => DatePickerRoot,
  RootProvider: () => DatePickerRootProvider,
  Table: () => DatePickerTable,
  TableBody: () => DatePickerTableBody,
  TableCell: () => DatePickerTableCell,
  TableCellTrigger: () => DatePickerTableCellTrigger,
  TableHead: () => DatePickerTableHead,
  TableHeader: () => DatePickerTableHeader,
  TableRow: () => DatePickerTableRow,
  Trigger: () => DatePickerTrigger,
  View: () => DatePickerView,
  ViewControl: () => DatePickerViewControl,
  ViewTrigger: () => DatePickerViewTrigger,
  YearSelect: () => DatePickerYearSelect
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var import_jsx_runtime105 = __toESM(require_jsx_runtime(), 1);
var import_react232 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog-context.js
var [DialogProvider, useDialogContext] = createContext({
  name: "DialogContext",
  hookName: "useDialogContext",
  providerName: "<DialogProvider />"
});

// node_modules/@ark-ui/react/dist/components/dialog/dialog-backdrop.js
var DialogBackdrop = (0, import_react232.forwardRef)((props29, ref2) => {
  const dialog = useDialogContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({ ...renderStrategyProps, present: dialog.open });
  const mergedProps = mergeProps(dialog.getBackdropProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime105.jsx)(ark.div, { ...mergedProps });
});
DialogBackdrop.displayName = "DialogBackdrop";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-close-trigger.js
var import_jsx_runtime106 = __toESM(require_jsx_runtime(), 1);
var import_react234 = __toESM(require_react(), 1);
var DialogCloseTrigger = (0, import_react234.forwardRef)(
  (props29, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps(dialog.getCloseTriggerProps(), props29);
    return (0, import_jsx_runtime106.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
DialogCloseTrigger.displayName = "DialogCloseTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-content.js
var import_jsx_runtime107 = __toESM(require_jsx_runtime(), 1);
var import_react236 = __toESM(require_react(), 1);
var DialogContent = (0, import_react236.forwardRef)((props29, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(dialog.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime107.jsx)(ark.div, { ...mergedProps });
});
DialogContent.displayName = "DialogContent";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-context.js
var DialogContext = (props29) => props29.children(useDialogContext());

// node_modules/@ark-ui/react/dist/components/dialog/dialog-description.js
var import_jsx_runtime108 = __toESM(require_jsx_runtime(), 1);
var import_react238 = __toESM(require_react(), 1);
var DialogDescription = (0, import_react238.forwardRef)(
  (props29, ref2) => {
    const dialog = useDialogContext();
    const mergedProps = mergeProps(dialog.getDescriptionProps(), props29);
    return (0, import_jsx_runtime108.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
DialogDescription.displayName = "DialogDescription";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-positioner.js
var import_jsx_runtime109 = __toESM(require_jsx_runtime(), 1);
var import_react240 = __toESM(require_react(), 1);
var DialogPositioner = (0, import_react240.forwardRef)((props29, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getPositionerProps(), props29);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime109.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
DialogPositioner.displayName = "DialogPositioner";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var import_jsx_runtime110 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/dialog/use-dialog.js
var import_react242 = __toESM(require_react(), 1);
var useDialog = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react242.useId)(),
    getRootNode: getRootNode2,
    dir,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29
  };
  const context = {
    ...initialContext,
    open: props29.open,
    onOpenChange: useEvent(props29.onOpenChange, { sync: true }),
    onEscapeKeyDown: useEvent(props29.onEscapeKeyDown),
    onInteractOutside: useEvent(props29.onInteractOutside)
  };
  const [state2, send] = useMachine(machine10(initialContext), { context });
  return connect10(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root.js
var DialogRoot = (props29) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props29);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const dialog = useDialog(localProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime110.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime110.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime110.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-root-provider.js
var import_jsx_runtime111 = __toESM(require_jsx_runtime(), 1);
var DialogRootProvider = (props29) => {
  const [presenceProps, { value: dialog, children }] = splitPresenceProps(props29);
  const [renderStrategyProps] = splitRenderStrategyProps(presenceProps);
  const presence = usePresence(mergeProps({ present: dialog.open }, presenceProps));
  return (0, import_jsx_runtime111.jsx)(DialogProvider, { value: dialog, children: (0, import_jsx_runtime111.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime111.jsx)(PresenceProvider, { value: presence, children }) }) });
};

// node_modules/@ark-ui/react/dist/components/dialog/dialog-title.js
var import_jsx_runtime112 = __toESM(require_jsx_runtime(), 1);
var import_react246 = __toESM(require_react(), 1);
var DialogTitle = (0, import_react246.forwardRef)((props29, ref2) => {
  const dialog = useDialogContext();
  const mergedProps = mergeProps(dialog.getTitleProps(), props29);
  return (0, import_jsx_runtime112.jsx)(ark.h2, { ...mergedProps, ref: ref2 });
});
DialogTitle.displayName = "DialogTitle";

// node_modules/@ark-ui/react/dist/components/dialog/dialog-trigger.js
var import_jsx_runtime113 = __toESM(require_jsx_runtime(), 1);
var import_react248 = __toESM(require_react(), 1);
var DialogTrigger = (0, import_react248.forwardRef)((props29, ref2) => {
  const dialog = useDialogContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...dialog.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : dialog.getTriggerProps()["aria-controls"]
    },
    props29
  );
  return (0, import_jsx_runtime113.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
DialogTrigger.displayName = "DialogTrigger";

// node_modules/@ark-ui/react/dist/components/dialog/dialog.js
var dialog_exports = {};
__export(dialog_exports, {
  Backdrop: () => DialogBackdrop,
  CloseTrigger: () => DialogCloseTrigger,
  Content: () => DialogContent,
  Context: () => DialogContext,
  Description: () => DialogDescription,
  Positioner: () => DialogPositioner,
  Root: () => DialogRoot,
  RootProvider: () => DialogRootProvider,
  Title: () => DialogTitle,
  Trigger: () => DialogTrigger
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var import_jsx_runtime114 = __toESM(require_jsx_runtime(), 1);
var import_react250 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable-context.js
var [EditableProvider, useEditableContext] = createContext({
  name: "EditableContext",
  hookName: "useEditableContext",
  providerName: "<EditableProvider />"
});

// node_modules/@ark-ui/react/dist/components/editable/editable-area.js
var EditableArea = (0, import_react250.forwardRef)((props29, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getAreaProps(), props29);
  return (0, import_jsx_runtime114.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableArea.displayName = "EditableArea";

// node_modules/@ark-ui/react/dist/components/editable/editable-cancel-trigger.js
var import_jsx_runtime115 = __toESM(require_jsx_runtime(), 1);
var import_react252 = __toESM(require_react(), 1);
var EditableCancelTrigger = (0, import_react252.forwardRef)(
  (props29, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps(editable.getCancelTriggerProps(), props29);
    return (0, import_jsx_runtime115.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableCancelTrigger.displayName = "EditableCancelTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-context.js
var EditableContext = (props29) => props29.children(useEditableContext());

// node_modules/@ark-ui/react/dist/components/editable/editable-control.js
var import_jsx_runtime116 = __toESM(require_jsx_runtime(), 1);
var import_react254 = __toESM(require_react(), 1);
var EditableControl = (0, import_react254.forwardRef)((props29, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getControlProps(), props29);
  return (0, import_jsx_runtime116.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
EditableControl.displayName = "EditableControl";

// node_modules/@ark-ui/react/dist/components/editable/editable-edit-trigger.js
var import_jsx_runtime117 = __toESM(require_jsx_runtime(), 1);
var import_react256 = __toESM(require_react(), 1);
var EditableEditTrigger = (0, import_react256.forwardRef)(
  (props29, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps(editable.getEditTriggerProps(), props29);
    return (0, import_jsx_runtime117.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableEditTrigger.displayName = "EditableEditTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable-input.js
var import_jsx_runtime118 = __toESM(require_jsx_runtime(), 1);
var import_react258 = __toESM(require_react(), 1);
var EditableInput = (0, import_react258.forwardRef)((props29, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getInputProps(), props29);
  return (0, import_jsx_runtime118.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
EditableInput.displayName = "EditableInput";

// node_modules/@ark-ui/react/dist/components/editable/editable-label.js
var import_jsx_runtime119 = __toESM(require_jsx_runtime(), 1);
var import_react260 = __toESM(require_react(), 1);
var EditableLabel = (0, import_react260.forwardRef)((props29, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getLabelProps(), props29);
  return (0, import_jsx_runtime119.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
EditableLabel.displayName = "EditableLabel";

// node_modules/@ark-ui/react/dist/components/editable/editable-preview.js
var import_jsx_runtime120 = __toESM(require_jsx_runtime(), 1);
var import_react262 = __toESM(require_react(), 1);
var EditablePreview = (0, import_react262.forwardRef)((props29, ref2) => {
  const editable = useEditableContext();
  const mergedProps = mergeProps(editable.getPreviewProps(), props29);
  return (0, import_jsx_runtime120.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
EditablePreview.displayName = "EditablePreview";

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var import_jsx_runtime121 = __toESM(require_jsx_runtime(), 1);
var import_react266 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/editable/use-editable.js
var import_react264 = __toESM(require_react(), 1);
var useEditable = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react264.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onEdit: useEvent(props29.onEdit),
    onValueCommit: useEvent(props29.onValueCommit),
    onValueRevert: useEvent(props29.onValueRevert)
  };
  const [state2, send] = useMachine(machine11(initialContext), { context });
  return connect11(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/editable/editable-root.js
var EditableRoot = (0, import_react266.forwardRef)((props29, ref2) => {
  const [useEditableProps, localProps] = createSplitProps2()(props29, [
    "activationMode",
    "autoResize",
    "defaultValue",
    "disabled",
    "finalFocusEl",
    "form",
    "id",
    "ids",
    "invalid",
    "maxLength",
    "name",
    "onEdit",
    "onFocusOutside",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueCommit",
    "onValueRevert",
    "placeholder",
    "readOnly",
    "selectOnFocus",
    "startWithEditView",
    "submitMode",
    "translations",
    "value"
  ]);
  const editable = useEditable(useEditableProps);
  const mergedProps = mergeProps(editable.getRootProps(), localProps);
  return (0, import_jsx_runtime121.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime121.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
EditableRoot.displayName = "EditableRoot";

// node_modules/@ark-ui/react/dist/components/editable/editable-root-provider.js
var import_jsx_runtime122 = __toESM(require_jsx_runtime(), 1);
var import_react268 = __toESM(require_react(), 1);
var EditableRootProvider = (0, import_react268.forwardRef)(
  (props29, ref2) => {
    const [{ value: editable }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(editable.getRootProps(), localProps);
    return (0, import_jsx_runtime122.jsx)(EditableProvider, { value: editable, children: (0, import_jsx_runtime122.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
EditableRootProvider.displayName = "EditableRootProvider";

// node_modules/@ark-ui/react/dist/components/editable/editable-submit-trigger.js
var import_jsx_runtime123 = __toESM(require_jsx_runtime(), 1);
var import_react270 = __toESM(require_react(), 1);
var EditableSubmitTrigger = (0, import_react270.forwardRef)(
  (props29, ref2) => {
    const editable = useEditableContext();
    const mergedProps = mergeProps(editable.getSubmitTriggerProps(), props29);
    return (0, import_jsx_runtime123.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
EditableSubmitTrigger.displayName = "EditableSubmitTrigger";

// node_modules/@ark-ui/react/dist/components/editable/editable.js
var editable_exports = {};
__export(editable_exports, {
  Area: () => EditableArea,
  CancelTrigger: () => EditableCancelTrigger,
  Context: () => EditableContext,
  Control: () => EditableControl,
  EditTrigger: () => EditableEditTrigger,
  Input: () => EditableInput,
  Label: () => EditableLabel,
  Preview: () => EditablePreview,
  Root: () => EditableRoot,
  RootProvider: () => EditableRootProvider,
  SubmitTrigger: () => EditableSubmitTrigger
});

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-context.js
var [FileUploadProvider, useFileUploadContext] = createContext({
  name: "FileUploadContext",
  hookName: "useFileUploadContext",
  providerName: "<FileUploadProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-context.js
var FileUploadContext = (props29) => props29.children(useFileUploadContext());

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-dropzone.js
var import_jsx_runtime124 = __toESM(require_jsx_runtime(), 1);
var import_react272 = __toESM(require_react(), 1);
var FileUploadDropzone = (0, import_react272.forwardRef)(
  (props29, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getDropzoneProps(), props29);
    return (0, import_jsx_runtime124.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
FileUploadDropzone.displayName = "FileUploadDropzone";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-hidden-input.js
var import_jsx_runtime125 = __toESM(require_jsx_runtime(), 1);
var import_react274 = __toESM(require_react(), 1);
var FileUploadHiddenInput = (0, import_react274.forwardRef)(
  (props29, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime125.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
FileUploadHiddenInput.displayName = "FileUploadHiddenInput";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var import_jsx_runtime126 = __toESM(require_jsx_runtime(), 1);
var import_react276 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload-item-props-context.js
var [FileUploadItemPropsProvider, useFileUploadItemPropsContext] = createContext({
  name: "FileUploadItemPropsContext",
  hookName: "useFileUploadItemPropsContext",
  providerName: "<FileUploadItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item.js
var FileUploadItem = (0, import_react276.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["file"]);
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps(fileUpload.getItemProps(itemProps10), localProps);
  return (0, import_jsx_runtime126.jsx)(FileUploadItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime126.jsx)(ark.li, { ...mergedProps, ref: ref2 }) });
});
FileUploadItem.displayName = "FileUploadItem";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-delete-trigger.js
var import_jsx_runtime127 = __toESM(require_jsx_runtime(), 1);
var import_react278 = __toESM(require_react(), 1);
var FileUploadItemDeleteTrigger = (0, import_react278.forwardRef)((props29, ref2) => {
  const fileUpload = useFileUploadContext();
  const itemProps10 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps(fileUpload.getItemDeleteTriggerProps(itemProps10), props29);
  return (0, import_jsx_runtime127.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
FileUploadItemDeleteTrigger.displayName = "FileUploadItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-group.js
var import_jsx_runtime128 = __toESM(require_jsx_runtime(), 1);
var import_react280 = __toESM(require_react(), 1);
var FileUploadItemGroup = (0, import_react280.forwardRef)(
  (props29, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getItemGroupProps(), props29);
    return (0, import_jsx_runtime128.jsx)(ark.ul, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemGroup.displayName = "FileUploadItemGroup";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-name.js
var import_jsx_runtime129 = __toESM(require_jsx_runtime(), 1);
var import_react282 = __toESM(require_react(), 1);
var FileUploadItemName = (0, import_react282.forwardRef)(
  (props29, ref2) => {
    const { children, ...rest } = props29;
    const fileUpload = useFileUploadContext();
    const itemProps10 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps(fileUpload.getItemNameProps(itemProps10), rest);
    return (0, import_jsx_runtime129.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || itemProps10.file.name });
  }
);
FileUploadItemName.displayName = "FileUploadItemName";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview.js
var import_jsx_runtime130 = __toESM(require_jsx_runtime(), 1);
var import_react284 = __toESM(require_react(), 1);
var FileUploadItemPreview = (0, import_react284.forwardRef)(
  (props29, ref2) => {
    const fileUpload = useFileUploadContext();
    const itemProps10 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps(fileUpload.getItemPreviewProps(itemProps10), props29);
    if (!itemProps10.file.type.match(props29.type ?? ".*"))
      return null;
    return (0, import_jsx_runtime130.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
FileUploadItemPreview.displayName = "FileUploadItemPreview";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-preview-image.js
var import_jsx_runtime131 = __toESM(require_jsx_runtime(), 1);
var import_react286 = __toESM(require_react(), 1);
var FileUploadItemPreviewImage = (0, import_react286.forwardRef)((props29, ref2) => {
  const [url, setUrl] = (0, import_react286.useState)("");
  const fileUpload = useFileUploadContext();
  const itemProps10 = useFileUploadItemPropsContext();
  const mergedProps = mergeProps(fileUpload.getItemPreviewImageProps({ ...itemProps10, url }), props29);
  (0, import_react286.useEffect)(() => {
    fileUpload.createFileUrl(itemProps10.file, (url2) => setUrl(url2));
  }, [itemProps10, fileUpload]);
  return (0, import_jsx_runtime131.jsx)(ark.img, { ...mergedProps, ref: ref2 });
});
FileUploadItemPreviewImage.displayName = "FileUploadItemPreviewImage";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-item-size-text.js
var import_jsx_runtime132 = __toESM(require_jsx_runtime(), 1);
var import_react288 = __toESM(require_react(), 1);
var FileUploadItemSizeText = (0, import_react288.forwardRef)(
  (props29, ref2) => {
    const { children, ...rest } = props29;
    const fileUpload = useFileUploadContext();
    const itemProps10 = useFileUploadItemPropsContext();
    const mergedProps = mergeProps(fileUpload.getItemSizeTextProps(itemProps10), rest);
    return (0, import_jsx_runtime132.jsx)(ark.div, { ...mergedProps, ref: ref2, children: children || fileUpload.getFileSize(itemProps10.file) });
  }
);
FileUploadItemSizeText.displayName = "FileUploadItemSizeText";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-label.js
var import_jsx_runtime133 = __toESM(require_jsx_runtime(), 1);
var import_react290 = __toESM(require_react(), 1);
var FileUploadLabel = (0, import_react290.forwardRef)((props29, ref2) => {
  const fileUpload = useFileUploadContext();
  const mergedProps = mergeProps(fileUpload.getLabelProps(), props29);
  return (0, import_jsx_runtime133.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
FileUploadLabel.displayName = "FileUploadLabel";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var import_jsx_runtime134 = __toESM(require_jsx_runtime(), 1);
var import_react294 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/file-upload/use-file-upload.js
var import_react292 = __toESM(require_react(), 1);
var useFileUpload = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react292.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props29
  };
  const context = {
    ...initialContext,
    onFileAccept: useEvent(props29.onFileAccept),
    onFileReject: useEvent(props29.onFileReject),
    onFileChange: useEvent(props29.onFileChange, { sync: true })
  };
  const [state2, send] = useMachine(machine12(initialContext), { context });
  return connect12(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root.js
var FileUploadRoot = (0, import_react294.forwardRef)((props29, ref2) => {
  const [useFileUploadProps, localProps] = createSplitProps2()(props29, [
    "accept",
    "allowDrop",
    "capture",
    "directory",
    "disabled",
    "id",
    "ids",
    "locale",
    "maxFiles",
    "maxFileSize",
    "minFileSize",
    "name",
    "onFileAccept",
    "onFileChange",
    "onFileReject",
    "translations",
    "validate"
  ]);
  const fileUpload = useFileUpload(useFileUploadProps);
  const mergedProps = mergeProps(fileUpload.getRootProps(), localProps);
  return (0, import_jsx_runtime134.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime134.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
FileUploadRoot.displayName = "FileUploadRoot";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-root-provider.js
var import_jsx_runtime135 = __toESM(require_jsx_runtime(), 1);
var import_react296 = __toESM(require_react(), 1);
var FileUploadRootProvider = (0, import_react296.forwardRef)(
  (props29, ref2) => {
    const [{ value: fileUpload }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(fileUpload.getRootProps(), localProps);
    return (0, import_jsx_runtime135.jsx)(FileUploadProvider, { value: fileUpload, children: (0, import_jsx_runtime135.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
FileUploadRootProvider.displayName = "FileUploadRootProvider";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload-trigger.js
var import_jsx_runtime136 = __toESM(require_jsx_runtime(), 1);
var import_react298 = __toESM(require_react(), 1);
var FileUploadTrigger = (0, import_react298.forwardRef)(
  (props29, ref2) => {
    const fileUpload = useFileUploadContext();
    const mergedProps = mergeProps(fileUpload.getTriggerProps(), props29);
    return (0, import_jsx_runtime136.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
FileUploadTrigger.displayName = "FileUploadTrigger";

// node_modules/@ark-ui/react/dist/components/file-upload/file-upload.js
var file_upload_exports = {};
__export(file_upload_exports, {
  Context: () => FileUploadContext,
  Dropzone: () => FileUploadDropzone,
  HiddenInput: () => FileUploadHiddenInput,
  Item: () => FileUploadItem,
  ItemDeleteTrigger: () => FileUploadItemDeleteTrigger,
  ItemGroup: () => FileUploadItemGroup,
  ItemName: () => FileUploadItemName,
  ItemPreview: () => FileUploadItemPreview,
  ItemPreviewImage: () => FileUploadItemPreviewImage,
  ItemSizeText: () => FileUploadItemSizeText,
  Label: () => FileUploadLabel,
  Root: () => FileUploadRoot,
  RootProvider: () => FileUploadRootProvider,
  Trigger: () => FileUploadTrigger
});

// node_modules/@ark-ui/react/dist/components/format/format-byte.js
var import_jsx_runtime137 = __toESM(require_jsx_runtime(), 1);
var import_react299 = __toESM(require_react(), 1);
var FormatByte = (props29) => {
  const { value, ...intlOptions } = props29;
  const { locale } = useLocaleContext();
  const text = (0, import_react299.useMemo)(() => formatBytes(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime137.jsx)(import_jsx_runtime137.Fragment, { children: text });
};
FormatByte.displayName = "FormatByte";

// node_modules/@ark-ui/react/dist/components/format/format-number.js
var import_jsx_runtime138 = __toESM(require_jsx_runtime(), 1);
var import_react300 = __toESM(require_react(), 1);
var FormatNumber = (props29) => {
  const { value, ...intlOptions } = props29;
  const { locale } = useLocaleContext();
  const text = (0, import_react300.useMemo)(() => formatNumber(value, locale, intlOptions), [value, locale, intlOptions]);
  return (0, import_jsx_runtime138.jsx)(import_jsx_runtime138.Fragment, { children: text });
};
FormatNumber.displayName = "FormatNumber";

// node_modules/@ark-ui/react/dist/components/format/format.js
var format_exports = {};
__export(format_exports, {
  Byte: () => FormatByte,
  Number: () => FormatNumber
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var import_jsx_runtime139 = __toESM(require_jsx_runtime(), 1);
var import_react302 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card-context.js
var [HoverCardProvider, useHoverCardContext] = createContext({
  name: "HoverCardContext",
  hookName: "useHoverCardContext",
  providerName: "<HoverCardProvider />"
});

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow.js
var HoverCardArrow = (0, import_react302.forwardRef)((props29, ref2) => {
  const hoverCard = useHoverCardContext();
  const mergedProps = mergeProps(hoverCard.getArrowProps(), props29);
  return (0, import_jsx_runtime139.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
HoverCardArrow.displayName = "HoverCardArrow";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-arrow-tip.js
var import_jsx_runtime140 = __toESM(require_jsx_runtime(), 1);
var import_react304 = __toESM(require_react(), 1);
var HoverCardArrowTip = (0, import_react304.forwardRef)(
  (props29, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps(hoverCard.getArrowTipProps(), props29);
    return (0, import_jsx_runtime140.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardArrowTip.displayName = "HoverCardArrowTip";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-content.js
var import_jsx_runtime141 = __toESM(require_jsx_runtime(), 1);
var import_react306 = __toESM(require_react(), 1);
var HoverCardContent = (0, import_react306.forwardRef)((props29, ref2) => {
  const hoverCard = useHoverCardContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(hoverCard.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime141.jsx)(ark.div, { ...mergedProps });
});
HoverCardContent.displayName = "HoverCardContent";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-context.js
var HoverCardContext = (props29) => props29.children(useHoverCardContext());

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-positioner.js
var import_jsx_runtime142 = __toESM(require_jsx_runtime(), 1);
var import_react308 = __toESM(require_react(), 1);
var HoverCardPositioner = (0, import_react308.forwardRef)(
  (props29, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps(hoverCard.getPositionerProps(), props29);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime142.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
HoverCardPositioner.displayName = "HoverCardPositioner";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var import_jsx_runtime143 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/hover-card/use-hover-card.js
var import_react310 = __toESM(require_react(), 1);
var useHoverCard = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react310.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29
  };
  const context = {
    ...initialContext,
    open: props29.open,
    onOpenChange: useEvent(props29.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine13(initialContext), { context });
  return connect13(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root.js
var HoverCardRoot = (props29) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props29);
  const hoverCard = useHoverCard(localProps);
  const presence = usePresence(mergeProps({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime143.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime143.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-root-provider.js
var import_jsx_runtime144 = __toESM(require_jsx_runtime(), 1);
var HoverCardRootProvider = (props29) => {
  const [presenceProps, { value: hoverCard, children }] = splitPresenceProps(props29);
  const presence = usePresence(mergeProps({ present: hoverCard.open }, presenceProps));
  return (0, import_jsx_runtime144.jsx)(HoverCardProvider, { value: hoverCard, children: (0, import_jsx_runtime144.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card-trigger.js
var import_jsx_runtime145 = __toESM(require_jsx_runtime(), 1);
var import_react314 = __toESM(require_react(), 1);
var HoverCardTrigger = (0, import_react314.forwardRef)(
  (props29, ref2) => {
    const hoverCard = useHoverCardContext();
    const mergedProps = mergeProps(hoverCard.getTriggerProps(), props29);
    return (0, import_jsx_runtime145.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
HoverCardTrigger.displayName = "HoverCardTrigger";

// node_modules/@ark-ui/react/dist/components/hover-card/hover-card.js
var hover_card_exports = {};
__export(hover_card_exports, {
  Arrow: () => HoverCardArrow,
  ArrowTip: () => HoverCardArrowTip,
  Content: () => HoverCardContent,
  Context: () => HoverCardContext,
  Positioner: () => HoverCardPositioner,
  Root: () => HoverCardRoot,
  RootProvider: () => HoverCardRootProvider,
  Trigger: () => HoverCardTrigger
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var import_jsx_runtime146 = __toESM(require_jsx_runtime(), 1);
var import_react316 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-context.js
var [MenuProvider, useMenuContext] = createContext({
  name: "MenuContext",
  hookName: "useMenuContext",
  providerName: "<MenuProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow.js
var MenuArrow = (0, import_react316.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getArrowProps(), props29);
  return (0, import_jsx_runtime146.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrow.displayName = "MenuArrow";

// node_modules/@ark-ui/react/dist/components/menu/menu-arrow-tip.js
var import_jsx_runtime147 = __toESM(require_jsx_runtime(), 1);
var import_react318 = __toESM(require_react(), 1);
var MenuArrowTip = (0, import_react318.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getArrowTipProps(), props29);
  return (0, import_jsx_runtime147.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuArrowTip.displayName = "MenuArrowTip";

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var import_jsx_runtime148 = __toESM(require_jsx_runtime(), 1);
var import_react320 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-context.js
var [MenuItemProvider, useMenuItemContext] = createContext({
  name: "MenuItemContext",
  hookName: "useMenuItemContext",
  providerName: "<MenuItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-option-item-props-context.js
var [MenuOptionItemPropsProvider, useMenuOptionItemPropsContext] = createContext({
  name: "MenuOptionItemPropsContext",
  hookName: "useMenuOptionItemPropsContext",
  providerName: "<MenuOptionItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-checkbox-item.js
var MenuCheckboxItem = (0, import_react320.forwardRef)((props29, ref2) => {
  const [partialOptionItemProps, localProps] = createSplitProps2()(props29, [
    "checked",
    "closeOnSelect",
    "disabled",
    "onCheckedChange",
    "value",
    "valueText"
  ]);
  const optionItemProps2 = {
    ...partialOptionItemProps,
    type: "checkbox"
  };
  const menu = useMenuContext();
  const item = menu.getOptionItemState(optionItemProps2);
  const mergedProps = mergeProps(menu.getOptionItemProps(optionItemProps2), localProps);
  return (0, import_jsx_runtime148.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime148.jsx)(MenuItemProvider, { value: item, children: (0, import_jsx_runtime148.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuCheckboxItem.displayName = "MenuCheckboxItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-content.js
var import_jsx_runtime149 = __toESM(require_jsx_runtime(), 1);
var import_react322 = __toESM(require_react(), 1);
var MenuContent = (0, import_react322.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(menu.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime149.jsx)(ark.div, { ...mergedProps });
});
MenuContent.displayName = "MenuContent";

// node_modules/@ark-ui/react/dist/components/menu/menu-context.js
var MenuContext = (props29) => props29.children(useMenuContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-context-trigger.js
var import_jsx_runtime150 = __toESM(require_jsx_runtime(), 1);
var import_react324 = __toESM(require_react(), 1);
var MenuContextTrigger = (0, import_react324.forwardRef)(
  (props29, ref2) => {
    const menu = useMenuContext();
    const mergedProps = mergeProps(menu.getContextTriggerProps(), props29);
    return (0, import_jsx_runtime150.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
MenuContextTrigger.displayName = "MenuContextTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-indicator.js
var import_jsx_runtime151 = __toESM(require_jsx_runtime(), 1);
var import_react326 = __toESM(require_react(), 1);
var MenuIndicator = (0, import_react326.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getIndicatorProps(), props29);
  return (0, import_jsx_runtime151.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuIndicator.displayName = "MenuIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item.js
var import_jsx_runtime152 = __toESM(require_jsx_runtime(), 1);
var import_react328 = __toESM(require_react(), 1);
var MenuItem = (0, import_react328.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getItemProps(itemProps10), localProps);
  const itemState = menu.getItemState(itemProps10);
  return (0, import_jsx_runtime152.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime152.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItem.displayName = "MenuItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-context.js
var MenuItemContext = (props29) => props29.children(useMenuItemContext());

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var import_jsx_runtime153 = __toESM(require_jsx_runtime(), 1);
var import_react330 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/menu/use-menu-item-group-context.js
var [MenuItemGroupProvider, useMenuItemGroupContext] = createContext({
  name: "MenuItemGroupContext",
  hookName: "useMenuItemGroupContext",
  providerName: "<MenuItemGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group.js
var MenuItemGroup = (0, import_react330.forwardRef)((props29, ref2) => {
  const [optionalItemGroupProps, localProps] = createSplitProps2()(props29, [
    "id"
  ]);
  const menu = useMenuContext();
  const id = (0, import_react330.useId)();
  const itemGroupProps3 = { id, ...optionalItemGroupProps };
  const mergedProps = mergeProps(menu.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime153.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime153.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
MenuItemGroup.displayName = "MenuItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-group-label.js
var import_jsx_runtime154 = __toESM(require_jsx_runtime(), 1);
var import_react332 = __toESM(require_react(), 1);
var MenuItemGroupLabel = (0, import_react332.forwardRef)(
  (props29, ref2) => {
    const menu = useMenuContext();
    const itemGroup = useMenuItemGroupContext();
    const mergedProps = mergeProps(menu.getItemGroupLabelProps({ htmlFor: itemGroup.id }), props29);
    return (0, import_jsx_runtime154.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemGroupLabel.displayName = "MenuItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-indicator.js
var import_jsx_runtime155 = __toESM(require_jsx_runtime(), 1);
var import_react334 = __toESM(require_react(), 1);
var MenuItemIndicator = (0, import_react334.forwardRef)(
  (props29, ref2) => {
    const menu = useMenuContext();
    const optionItemProps2 = useMenuOptionItemPropsContext();
    const mergedProps = mergeProps(menu.getItemIndicatorProps(optionItemProps2), props29);
    return (0, import_jsx_runtime155.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
MenuItemIndicator.displayName = "MenuItemIndicator";

// node_modules/@ark-ui/react/dist/components/menu/menu-item-text.js
var import_jsx_runtime156 = __toESM(require_jsx_runtime(), 1);
var import_react336 = __toESM(require_react(), 1);
var MenuItemText = (0, import_react336.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const optionItemProps2 = useMenuOptionItemPropsContext();
  const mergedProps = mergeProps(menu.getItemTextProps(optionItemProps2), props29);
  return (0, import_jsx_runtime156.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuItemText.displayName = "MenuItemText";

// node_modules/@ark-ui/react/dist/components/menu/menu-positioner.js
var import_jsx_runtime157 = __toESM(require_jsx_runtime(), 1);
var import_react338 = __toESM(require_react(), 1);
var MenuPositioner = (0, import_react338.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getPositionerProps(), props29);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime157.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuPositioner.displayName = "MenuPositioner";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item.js
var import_jsx_runtime158 = __toESM(require_jsx_runtime(), 1);
var import_react340 = __toESM(require_react(), 1);
var MenuRadioItem = (0, import_react340.forwardRef)((props29, ref2) => {
  const [partialItemProps, localProps] = createSplitProps2()(props29, [
    "closeOnSelect",
    "disabled",
    "value",
    "valueText"
  ]);
  const menu = useMenuContext();
  const itemGroup = useMenuItemGroupContext();
  const optionItemProps2 = {
    ...partialItemProps,
    checked: itemGroup.value === partialItemProps.value,
    type: "radio",
    onCheckedChange: () => {
      var _a;
      return (_a = itemGroup.onValueChange) == null ? void 0 : _a.call(itemGroup, { value: partialItemProps.value });
    }
  };
  const mergedProps = mergeProps(menu.getOptionItemProps(optionItemProps2), localProps);
  const itemState = menu.getItemState(optionItemProps2);
  return (0, import_jsx_runtime158.jsx)(MenuOptionItemPropsProvider, { value: optionItemProps2, children: (0, import_jsx_runtime158.jsx)(MenuItemProvider, { value: itemState, children: (0, import_jsx_runtime158.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
MenuRadioItem.displayName = "MenuRadioItem";

// node_modules/@ark-ui/react/dist/components/menu/menu-radio-item-group.js
var import_jsx_runtime159 = __toESM(require_jsx_runtime(), 1);
var import_react342 = __toESM(require_react(), 1);
var MenuRadioItemGroup = (0, import_react342.forwardRef)(
  (props29, ref2) => {
    const [optionalItemGroupProps, localProps] = createSplitProps2()(props29, ["id", "onValueChange", "value"]);
    const menu = useMenuContext();
    const id = (0, import_react342.useId)();
    const itemGroupProps3 = { id, ...optionalItemGroupProps };
    const mergedProps = mergeProps(menu.getItemGroupProps({ id: itemGroupProps3.id }), localProps);
    return (0, import_jsx_runtime159.jsx)(MenuItemGroupProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime159.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
MenuRadioItemGroup.displayName = "MenuRadioItemGroup";

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var import_jsx_runtime160 = __toESM(require_jsx_runtime(), 1);
var import_react347 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/use-effect-once.js
var import_react343 = __toESM(require_react(), 1);
var useEffectOnce = (cb) => {
  const savedCallback = (0, import_react343.useRef)(cb);
  const effectGuard = (0, import_react343.useRef)(false);
  (0, import_react343.useEffect)(() => {
    savedCallback.current = cb;
  });
  (0, import_react343.useEffect)(() => {
    if (effectGuard.current !== true) {
      effectGuard.current = true;
      savedCallback.current();
    }
  }, []);
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu.js
var import_react345 = __toESM(require_react(), 1);
var useMenu = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react345.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props29.onOpenChange),
    onSelect: useEvent(props29.onSelect)
  };
  const [state2, send, machine34] = useMachine(machine14(initialContext), { context });
  const api = connect14(state2, send, normalizeProps);
  return { api, machine: machine34 };
};

// node_modules/@ark-ui/react/dist/components/menu/use-menu-machine-context.js
var [MenuMachineProvider, useMenuMachineContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/use-menu-trigger-item-context.js
var [MenuTriggerItemProvider, useMenuTriggerItemContext] = createContext({
  name: "MenuMachineContext",
  hookName: "useMenuMachineContext",
  providerName: "<MenuMachineProvider />",
  strict: false
});

// node_modules/@ark-ui/react/dist/components/menu/menu-root.js
var MenuRoot = (props29) => {
  const [presenceProps, menuProps] = splitPresenceProps(props29);
  const [useMenuProps, localProps] = createSplitProps2()(menuProps, [
    "anchorPoint",
    "aria-label",
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "highlightedValue",
    "id",
    "ids",
    "loopFocus",
    "onEscapeKeyDown",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onSelect",
    "open",
    "positioning",
    "typeahead"
  ]);
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const { api, machine: machine34 } = useMenu(useMenuProps);
  const presence = usePresence(mergeProps({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine)
      return;
    if (!parentApi)
      return;
    parentApi.setChild(machine34);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react347.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime160.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime160.jsx)(MenuMachineProvider, { value: machine34, children: (0, import_jsx_runtime160.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime160.jsx)(PresenceProvider, { value: presence, ...localProps }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-root-provider.js
var import_jsx_runtime161 = __toESM(require_jsx_runtime(), 1);
var import_react349 = __toESM(require_react(), 1);
var MenuRootProvider = (props29) => {
  const parentApi = useMenuContext();
  const parentMachine = useMenuMachineContext();
  const [presenceProps, { value: menu, children }] = splitPresenceProps(props29);
  const { api, machine: machine34 } = menu;
  const presence = usePresence(mergeProps({ present: api.open }, presenceProps));
  useEffectOnce(() => {
    if (!parentMachine)
      return;
    if (!parentApi)
      return;
    parentApi.setChild(machine34);
    api.setParent(parentMachine);
  });
  const triggerItemContext = (0, import_react349.useCallback)(
    () => parentApi == null ? void 0 : parentApi.getTriggerItemProps(api),
    [api, parentApi]
  );
  return (0, import_jsx_runtime161.jsx)(MenuTriggerItemProvider, { value: triggerItemContext, children: (0, import_jsx_runtime161.jsx)(MenuMachineProvider, { value: machine34, children: (0, import_jsx_runtime161.jsx)(MenuProvider, { value: api, children: (0, import_jsx_runtime161.jsx)(PresenceProvider, { value: presence, children }) }) }) });
};

// node_modules/@ark-ui/react/dist/components/menu/menu-separator.js
var import_jsx_runtime162 = __toESM(require_jsx_runtime(), 1);
var import_react351 = __toESM(require_react(), 1);
var MenuSeparator = (0, import_react351.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const mergedProps = mergeProps(menu.getSeparatorProps(), props29);
  return (0, import_jsx_runtime162.jsx)(ark.hr, { ...mergedProps, ref: ref2 });
});
MenuSeparator.displayName = "MenuSeparator";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger.js
var import_jsx_runtime163 = __toESM(require_jsx_runtime(), 1);
var import_react353 = __toESM(require_react(), 1);
var MenuTrigger = (0, import_react353.forwardRef)((props29, ref2) => {
  const menu = useMenuContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...menu.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : menu.getTriggerProps()["aria-controls"]
    },
    props29
  );
  return (0, import_jsx_runtime163.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
MenuTrigger.displayName = "MenuTrigger";

// node_modules/@ark-ui/react/dist/components/menu/menu-trigger-item.js
var import_jsx_runtime164 = __toESM(require_jsx_runtime(), 1);
var import_react355 = __toESM(require_react(), 1);
var MenuTriggerItem = (0, import_react355.forwardRef)((props29, ref2) => {
  const getTriggerItemProps = useMenuTriggerItemContext();
  const mergedProps = mergeProps((getTriggerItemProps == null ? void 0 : getTriggerItemProps()) ?? {}, props29);
  return (0, import_jsx_runtime164.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
MenuTriggerItem.displayName = "MenuTriggerItem";

// node_modules/@ark-ui/react/dist/components/menu/menu.js
var menu_exports = {};
__export(menu_exports, {
  Arrow: () => MenuArrow,
  ArrowTip: () => MenuArrowTip,
  CheckboxItem: () => MenuCheckboxItem,
  Content: () => MenuContent,
  Context: () => MenuContext,
  ContextTrigger: () => MenuContextTrigger,
  Indicator: () => MenuIndicator,
  Item: () => MenuItem,
  ItemContext: () => MenuItemContext,
  ItemGroup: () => MenuItemGroup,
  ItemGroupLabel: () => MenuItemGroupLabel,
  ItemIndicator: () => MenuItemIndicator,
  ItemText: () => MenuItemText,
  Positioner: () => MenuPositioner,
  RadioItem: () => MenuRadioItem,
  RadioItemGroup: () => MenuRadioItemGroup,
  Root: () => MenuRoot,
  RootProvider: () => MenuRootProvider,
  Separator: () => MenuSeparator,
  Trigger: () => MenuTrigger,
  TriggerItem: () => MenuTriggerItem
});

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input-context.js
var [NumberInputProvider, useNumberInputContext] = createContext({
  name: "NumberInputContext",
  hookName: "useNumberInputContext",
  providerName: "<NumberInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/number-input/number-input-context.js
var NumberInputContext = (props29) => props29.children(useNumberInputContext());

// node_modules/@ark-ui/react/dist/components/number-input/number-input-control.js
var import_jsx_runtime165 = __toESM(require_jsx_runtime(), 1);
var import_react357 = __toESM(require_react(), 1);
var NumberInputControl = (0, import_react357.forwardRef)(
  (props29, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getControlProps(), props29);
    return (0, import_jsx_runtime165.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputControl.displayName = "NumberInputControl";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-decrement-trigger.js
var import_jsx_runtime166 = __toESM(require_jsx_runtime(), 1);
var import_react359 = __toESM(require_react(), 1);
var NumberInputDecrementTrigger = (0, import_react359.forwardRef)((props29, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getDecrementTriggerProps(), props29);
  return (0, import_jsx_runtime166.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputDecrementTrigger.displayName = "NumberInputDecrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-increment-trigger.js
var import_jsx_runtime167 = __toESM(require_jsx_runtime(), 1);
var import_react361 = __toESM(require_react(), 1);
var NumberInputIncrementTrigger = (0, import_react361.forwardRef)((props29, ref2) => {
  const numberInput = useNumberInputContext();
  const mergedProps = mergeProps(numberInput.getIncrementTriggerProps(), props29);
  return (0, import_jsx_runtime167.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
NumberInputIncrementTrigger.displayName = "NumberInputIncrementTrigger";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-input.js
var import_jsx_runtime168 = __toESM(require_jsx_runtime(), 1);
var import_react363 = __toESM(require_react(), 1);
var NumberInputInput = (0, import_react363.forwardRef)(
  (props29, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getInputProps(), props29);
    return (0, import_jsx_runtime168.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
NumberInputInput.displayName = "NumberInputInput";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-label.js
var import_jsx_runtime169 = __toESM(require_jsx_runtime(), 1);
var import_react365 = __toESM(require_react(), 1);
var NumberInputLabel = (0, import_react365.forwardRef)(
  (props29, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getLabelProps(), props29);
    return (0, import_jsx_runtime169.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
NumberInputLabel.displayName = "NumberInputLabel";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var import_jsx_runtime170 = __toESM(require_jsx_runtime(), 1);
var import_react369 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/number-input/use-number-input.js
var import_react367 = __toESM(require_react(), 1);
var useNumberInput = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react367.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props29.onValueInvalid),
    onFocusChange: useEvent(props29.onFocusChange)
  };
  const [state2, send] = useMachine(machine15(initialContext), { context });
  return connect15(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root.js
var NumberInputRoot = (0, import_react369.forwardRef)((props29, ref2) => {
  const [useNumberInputProps, localProps] = createSplitProps2()(props29, [
    "allowMouseWheel",
    "allowOverflow",
    "clampValueOnBlur",
    "defaultValue",
    "disabled",
    "focusInputOnChange",
    "form",
    "formatOptions",
    "id",
    "ids",
    "inputMode",
    "invalid",
    "locale",
    "max",
    "min",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueInvalid",
    "pattern",
    "readOnly",
    "spinOnPress",
    "step",
    "translations",
    "value"
  ]);
  const numberInput = useNumberInput(useNumberInputProps);
  const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
  return (0, import_jsx_runtime170.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime170.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
NumberInputRoot.displayName = "NumberInputRoot";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-root-provider.js
var import_jsx_runtime171 = __toESM(require_jsx_runtime(), 1);
var import_react371 = __toESM(require_react(), 1);
var NumberInputRootProvider = (0, import_react371.forwardRef)(
  (props29, ref2) => {
    const [{ value: numberInput }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(numberInput.getRootProps(), localProps);
    return (0, import_jsx_runtime171.jsx)(NumberInputProvider, { value: numberInput, children: (0, import_jsx_runtime171.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
NumberInputRootProvider.displayName = "NumberInputRootProvider";

// node_modules/@ark-ui/react/dist/components/number-input/number-input-scrubber.js
var import_jsx_runtime172 = __toESM(require_jsx_runtime(), 1);
var import_react373 = __toESM(require_react(), 1);
var NumberInputScrubber = (0, import_react373.forwardRef)(
  (props29, ref2) => {
    const numberInput = useNumberInputContext();
    const mergedProps = mergeProps(numberInput.getScrubberProps(), props29);
    return (0, import_jsx_runtime172.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
NumberInputScrubber.displayName = "NumberInputScrubber";

// node_modules/@ark-ui/react/dist/components/number-input/number-input.js
var number_input_exports = {};
__export(number_input_exports, {
  Context: () => NumberInputContext,
  Control: () => NumberInputControl,
  DecrementTrigger: () => NumberInputDecrementTrigger,
  IncrementTrigger: () => NumberInputIncrementTrigger,
  Input: () => NumberInputInput,
  Label: () => NumberInputLabel,
  Root: () => NumberInputRoot,
  Scrubber: () => NumberInputScrubber
});

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination-context.js
var [PaginationProvider, usePaginationContext] = createContext({
  name: "PaginationContext",
  hookName: "usePaginationContext",
  providerName: "<PaginationProvider />"
});

// node_modules/@ark-ui/react/dist/components/pagination/pagination-context.js
var PaginationContext = (props29) => props29.children(usePaginationContext());

// node_modules/@ark-ui/react/dist/components/pagination/pagination-ellipsis.js
var import_jsx_runtime173 = __toESM(require_jsx_runtime(), 1);
var import_react375 = __toESM(require_react(), 1);
var PaginationEllipsis = (0, import_react375.forwardRef)(
  (props29, ref2) => {
    const [ellipsisProps2, localProps] = createSplitProps2()(props29, ["index"]);
    const pagination = usePaginationContext();
    const mergedProps = mergeProps(pagination.getEllipsisProps(ellipsisProps2), localProps);
    return (0, import_jsx_runtime173.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PaginationEllipsis.displayName = "PaginationEllipsis";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-item.js
var import_jsx_runtime174 = __toESM(require_jsx_runtime(), 1);
var import_react377 = __toESM(require_react(), 1);
var PaginationItem = (0, import_react377.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["value", "type"]);
  const pagination = usePaginationContext();
  const mergedProps = mergeProps(pagination.getItemProps(itemProps10), localProps);
  return (0, import_jsx_runtime174.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PaginationItem.displayName = "PaginationItem";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-next-trigger.js
var import_jsx_runtime175 = __toESM(require_jsx_runtime(), 1);
var import_react379 = __toESM(require_react(), 1);
var PaginationNextTrigger = (0, import_react379.forwardRef)(
  (props29, ref2) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps(pagination.getNextTriggerProps(), props29);
    return (0, import_jsx_runtime175.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PaginationNextTrigger.displayName = "PaginationNextTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-prev-trigger.js
var import_jsx_runtime176 = __toESM(require_jsx_runtime(), 1);
var import_react381 = __toESM(require_react(), 1);
var PaginationPrevTrigger = (0, import_react381.forwardRef)(
  (props29, ref2) => {
    const pagination = usePaginationContext();
    const mergedProps = mergeProps(pagination.getPrevTriggerProps(), props29);
    return (0, import_jsx_runtime176.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PaginationPrevTrigger.displayName = "PaginationPrevTrigger";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var import_jsx_runtime177 = __toESM(require_jsx_runtime(), 1);
var import_react385 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/pagination/use-pagination.js
var import_react383 = __toESM(require_react(), 1);
var usePagination = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react383.useId)(),
    dir,
    getRootNode: getRootNode2,
    page: props29.defaultPage,
    ...props29
  };
  const context = {
    ...initialContext,
    page: props29.page,
    onPageChange: useEvent(props29.onPageChange, { sync: true })
  };
  const [state2, send] = useMachine(machine16(initialContext), { context });
  return connect16(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root.js
var PaginationRoot = (0, import_react385.forwardRef)((props29, ref2) => {
  const [paginationProps, localProps] = createSplitProps2()(props29, [
    "count",
    "defaultPage",
    "id",
    "ids",
    "onPageChange",
    "onPageSizeChange",
    "page",
    "pageSize",
    "siblingCount",
    "translations",
    "type"
  ]);
  const pagination = usePagination(paginationProps);
  const mergedProps = mergeProps(pagination.getRootProps(), localProps);
  return (0, import_jsx_runtime177.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime177.jsx)(ark.nav, { ...mergedProps, ref: ref2 }) });
});
PaginationRoot.displayName = "PaginationRoot";

// node_modules/@ark-ui/react/dist/components/pagination/pagination-root-provider.js
var import_jsx_runtime178 = __toESM(require_jsx_runtime(), 1);
var import_react387 = __toESM(require_react(), 1);
var PaginationRootProvider = (0, import_react387.forwardRef)(
  (props29, ref2) => {
    const [{ value: pagination }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(pagination.getRootProps(), localProps);
    return (0, import_jsx_runtime178.jsx)(PaginationProvider, { value: pagination, children: (0, import_jsx_runtime178.jsx)(ark.nav, { ...mergedProps, ref: ref2 }) });
  }
);
PaginationRootProvider.displayName = "PaginationRootProvider";

// node_modules/@ark-ui/react/dist/components/pagination/pagination.js
var pagination_exports = {};
__export(pagination_exports, {
  Context: () => PaginationContext,
  Ellipsis: () => PaginationEllipsis,
  Item: () => PaginationItem,
  NextTrigger: () => PaginationNextTrigger,
  PrevTrigger: () => PaginationPrevTrigger,
  Root: () => PaginationRoot,
  RootProvider: () => PaginationRootProvider
});

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input-context.js
var [PinInputProvider, usePinInputContext] = createContext({
  name: "PinInputContext",
  hookName: "usePinInputContext",
  providerName: "<PinInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-context.js
var PinInputContext = (props29) => props29.children(usePinInputContext());

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-control.js
var import_jsx_runtime179 = __toESM(require_jsx_runtime(), 1);
var import_react389 = __toESM(require_react(), 1);
var PinInputControl = (0, import_react389.forwardRef)((props29, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps(pinInput.getControlProps(), props29);
  return (0, import_jsx_runtime179.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PinInputControl.displayName = "PinInputControl";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-hidden-input.js
var import_jsx_runtime180 = __toESM(require_jsx_runtime(), 1);
var import_react391 = __toESM(require_react(), 1);
var PinInputHiddenInput = (0, import_react391.forwardRef)(
  (props29, ref2) => {
    const pinInput = usePinInputContext();
    const mergedProps = mergeProps(pinInput.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime180.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
PinInputHiddenInput.displayName = "PinInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-input.js
var import_jsx_runtime181 = __toESM(require_jsx_runtime(), 1);
var import_react393 = __toESM(require_react(), 1);
var PinInputInput = (0, import_react393.forwardRef)((props29, ref2) => {
  const [inputProps2, localProps] = createSplitProps2()(props29, ["index"]);
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps(pinInput.getInputProps(inputProps2), localProps);
  return (0, import_jsx_runtime181.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
PinInputInput.displayName = "PinInputInput";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-label.js
var import_jsx_runtime182 = __toESM(require_jsx_runtime(), 1);
var import_react395 = __toESM(require_react(), 1);
var PinInputLabel = (0, import_react395.forwardRef)((props29, ref2) => {
  const pinInput = usePinInputContext();
  const mergedProps = mergeProps(pinInput.getLabelProps(), props29);
  return (0, import_jsx_runtime182.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
PinInputLabel.displayName = "PinInputLabel";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var import_jsx_runtime183 = __toESM(require_jsx_runtime(), 1);
var import_react399 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/pin-input/use-pin-input.js
var import_react397 = __toESM(require_react(), 1);
var usePinInput = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react397.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onValueComplete: useEvent(props29.onValueComplete),
    onValueInvalid: useEvent(props29.onValueInvalid)
  };
  const [state2, send] = useMachine(machine17(initialContext), { context });
  return connect17(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root.js
var PinInputRoot = (0, import_react399.forwardRef)((props29, ref2) => {
  const [usePinInputProps, localProps] = createSplitProps2()(props29, [
    "autoFocus",
    "blurOnComplete",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "mask",
    "name",
    "onValueChange",
    "onValueComplete",
    "onValueInvalid",
    "otp",
    "pattern",
    "placeholder",
    "selectOnFocus",
    "translations",
    "type",
    "value"
  ]);
  const pinInput = usePinInput(usePinInputProps);
  const mergedProps = mergeProps(pinInput.getRootProps(), localProps);
  return (0, import_jsx_runtime183.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime183.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
PinInputRoot.displayName = "PinInputRoot";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input-root-provider.js
var import_jsx_runtime184 = __toESM(require_jsx_runtime(), 1);
var import_react401 = __toESM(require_react(), 1);
var PinInputRootProvider = (0, import_react401.forwardRef)(
  (props29, ref2) => {
    const [{ value: pinInput }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(pinInput.getRootProps(), localProps);
    return (0, import_jsx_runtime184.jsx)(PinInputProvider, { value: pinInput, children: (0, import_jsx_runtime184.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
PinInputRootProvider.displayName = "PinInputRootProvider";

// node_modules/@ark-ui/react/dist/components/pin-input/pin-input.js
var pin_input_exports = {};
__export(pin_input_exports, {
  Context: () => PinInputContext,
  Control: () => PinInputControl,
  HiddenInput: () => PinInputHiddenInput,
  Input: () => PinInputInput,
  Label: () => PinInputLabel,
  Root: () => PinInputRoot,
  RootProvider: () => PinInputRootProvider
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var import_jsx_runtime185 = __toESM(require_jsx_runtime(), 1);
var import_react403 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover-context.js
var [PopoverProvider, usePopoverContext] = createContext({
  name: "PopoverContext",
  hookName: "usePopoverContext",
  providerName: "<PopoverProvider />"
});

// node_modules/@ark-ui/react/dist/components/popover/popover-anchor.js
var PopoverAnchor = (0, import_react403.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getAnchorProps(), props29);
  return (0, import_jsx_runtime185.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverAnchor.displayName = "PopoverAnchor";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow.js
var import_jsx_runtime186 = __toESM(require_jsx_runtime(), 1);
var import_react405 = __toESM(require_react(), 1);
var PopoverArrow = (0, import_react405.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getArrowProps(), props29);
  return (0, import_jsx_runtime186.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrow.displayName = "PopoverArrow";

// node_modules/@ark-ui/react/dist/components/popover/popover-arrow-tip.js
var import_jsx_runtime187 = __toESM(require_jsx_runtime(), 1);
var import_react407 = __toESM(require_react(), 1);
var PopoverArrowTip = (0, import_react407.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getArrowTipProps(), props29);
  return (0, import_jsx_runtime187.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverArrowTip.displayName = "PopoverArrowTip";

// node_modules/@ark-ui/react/dist/components/popover/popover-close-trigger.js
var import_jsx_runtime188 = __toESM(require_jsx_runtime(), 1);
var import_react409 = __toESM(require_react(), 1);
var PopoverCloseTrigger = (0, import_react409.forwardRef)(
  (props29, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps(popover.getCloseTriggerProps(), props29);
    return (0, import_jsx_runtime188.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
PopoverCloseTrigger.displayName = "PopoverCloseTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover-content.js
var import_jsx_runtime189 = __toESM(require_jsx_runtime(), 1);
var import_react411 = __toESM(require_react(), 1);
var PopoverContent = (0, import_react411.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(popover.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime189.jsx)(ark.div, { ...mergedProps });
});
PopoverContent.displayName = "PopoverContent";

// node_modules/@ark-ui/react/dist/components/popover/popover-context.js
var PopoverContext = (props29) => props29.children(usePopoverContext());

// node_modules/@ark-ui/react/dist/components/popover/popover-description.js
var import_jsx_runtime190 = __toESM(require_jsx_runtime(), 1);
var import_react413 = __toESM(require_react(), 1);
var PopoverDescription = (0, import_react413.forwardRef)(
  (props29, ref2) => {
    const popover = usePopoverContext();
    const mergedProps = mergeProps(popover.getDescriptionProps(), props29);
    return (0, import_jsx_runtime190.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverDescription.displayName = "PopoverDescription";

// node_modules/@ark-ui/react/dist/components/popover/popover-indicator.js
var import_jsx_runtime191 = __toESM(require_jsx_runtime(), 1);
var import_react415 = __toESM(require_react(), 1);
var PopoverIndicator = (0, import_react415.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getIndicatorProps(), props29);
  return (0, import_jsx_runtime191.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverIndicator.displayName = "PopoverIndicator";

// node_modules/@ark-ui/react/dist/components/popover/popover-positioner.js
var import_jsx_runtime192 = __toESM(require_jsx_runtime(), 1);
var import_react417 = __toESM(require_react(), 1);
var PopoverPositioner = (0, import_react417.forwardRef)(
  (props29, ref2) => {
    const popover = usePopoverContext();
    const presence = usePresenceContext();
    const mergedProps = mergeProps(popover.getPositionerProps(), props29);
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime192.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
PopoverPositioner.displayName = "PopoverPositioner";

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var import_jsx_runtime193 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/popover/use-popover.js
var import_react419 = __toESM(require_react(), 1);
var usePopover = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react419.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29
  };
  const context = {
    ...initialContext,
    open: props29.open,
    onOpenChange: useEvent(props29.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine18(initialContext), { context });
  return connect18(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root.js
var PopoverRoot = (props29) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props29);
  const popover = usePopover(localProps);
  const presence = usePresence(mergeProps({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime193.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime193.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-root-provider.js
var import_jsx_runtime194 = __toESM(require_jsx_runtime(), 1);
var PopoverRootProvider = (props29) => {
  const [presenceProps, { value: popover, children }] = splitPresenceProps(props29);
  const presence = usePresence(mergeProps({ present: popover.open }, presenceProps));
  return (0, import_jsx_runtime194.jsx)(PopoverProvider, { value: popover, children: (0, import_jsx_runtime194.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/popover/popover-title.js
var import_jsx_runtime195 = __toESM(require_jsx_runtime(), 1);
var import_react423 = __toESM(require_react(), 1);
var PopoverTitle = (0, import_react423.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const mergedProps = mergeProps(popover.getTitleProps(), props29);
  return (0, import_jsx_runtime195.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
PopoverTitle.displayName = "PopoverTitle";

// node_modules/@ark-ui/react/dist/components/popover/popover-trigger.js
var import_jsx_runtime196 = __toESM(require_jsx_runtime(), 1);
var import_react425 = __toESM(require_react(), 1);
var PopoverTrigger = (0, import_react425.forwardRef)((props29, ref2) => {
  const popover = usePopoverContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(
    {
      ...popover.getTriggerProps(),
      "aria-controls": presence.unmounted ? void 0 : popover.getTriggerProps()["aria-controls"]
    },
    props29
  );
  return (0, import_jsx_runtime196.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
PopoverTrigger.displayName = "PopoverTrigger";

// node_modules/@ark-ui/react/dist/components/popover/popover.js
var popover_exports = {};
__export(popover_exports, {
  Anchor: () => PopoverAnchor,
  Arrow: () => PopoverArrow,
  ArrowTip: () => PopoverArrowTip,
  CloseTrigger: () => PopoverCloseTrigger,
  Content: () => PopoverContent,
  Context: () => PopoverContext,
  Description: () => PopoverDescription,
  Indicator: () => PopoverIndicator,
  Positioner: () => PopoverPositioner,
  Root: () => PopoverRoot,
  RootProvider: () => PopoverRootProvider,
  Title: () => PopoverTitle,
  Trigger: () => PopoverTrigger
});

// node_modules/@ark-ui/react/dist/components/portal/portal.js
var import_jsx_runtime197 = __toESM(require_jsx_runtime(), 1);
var import_react427 = __toESM(require_react(), 1);
var import_react_dom2 = __toESM(require_react_dom(), 1);

// node_modules/@ark-ui/react/dist/utils/use-is-server.js
var import_react426 = __toESM(require_react(), 1);
var useIsServer = () => {
  const [isServer, setServer] = (0, import_react426.useState)(true);
  (0, import_react426.useEffect)(() => {
    setServer(false);
  }, []);
  return isServer;
};

// node_modules/@ark-ui/react/dist/components/portal/portal.js
var Portal = (props29) => {
  const { children, container, disabled } = props29;
  const isServer = useIsServer();
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  if (isServer || disabled)
    return (0, import_jsx_runtime197.jsx)(import_jsx_runtime197.Fragment, { children });
  const doc = (getRootNode2 == null ? void 0 : getRootNode2().ownerDocument) ?? document;
  const mountNode = (container == null ? void 0 : container.current) ?? doc.body;
  return (0, import_jsx_runtime197.jsx)(import_jsx_runtime197.Fragment, { children: import_react427.Children.map(children, (child) => (0, import_react_dom2.createPortal)(child, mountNode)) });
};

// node_modules/@ark-ui/react/dist/components/presence/presence.js
var import_jsx_runtime198 = __toESM(require_jsx_runtime(), 1);
var import_react428 = __toESM(require_react(), 1);
var Presence = (0, import_react428.forwardRef)((props29, ref2) => {
  const [presenceProps, localProps] = splitPresenceProps(props29);
  const presence = usePresence(presenceProps);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime198.jsx)(
    ark.div,
    {
      ...localProps,
      ...presence.getPresenceProps(ref2),
      "data-scope": "presence",
      "data-part": "root"
    }
  );
});
Presence.displayName = "Presence";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var import_jsx_runtime199 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress-context.js
var [ProgressProvider, useProgressContext] = createContext({
  name: "ProgressContext",
  hookName: "useProgressContext",
  providerName: "<ProgressProvider />"
});

// node_modules/@ark-ui/react/dist/components/progress/progress-circle.js
var ProgressCircle = (props29) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getCircleProps(), props29);
  return (0, import_jsx_runtime199.jsx)(ark.svg, { ...mergedProps });
};
ProgressCircle.displayName = "ProgressCircle";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-range.js
var import_jsx_runtime200 = __toESM(require_jsx_runtime(), 1);
var ProgressCircleRange = (props29) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getCircleRangeProps(), props29);
  return (0, import_jsx_runtime200.jsx)(ark.circle, { ...mergedProps });
};
ProgressCircleRange.displayName = "ProgressCircleRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-circle-track.js
var import_jsx_runtime201 = __toESM(require_jsx_runtime(), 1);
var ProgressCircleTrack = (props29) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getCircleTrackProps(), props29);
  return (0, import_jsx_runtime201.jsx)(ark.circle, { ...mergedProps });
};
ProgressCircleTrack.displayName = "ProgressCircleTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-context.js
var ProgressContext = (props29) => props29.children(useProgressContext());

// node_modules/@ark-ui/react/dist/components/progress/progress-label.js
var import_jsx_runtime202 = __toESM(require_jsx_runtime(), 1);
var import_react433 = __toESM(require_react(), 1);
var ProgressLabel = (0, import_react433.forwardRef)((props29, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getLabelProps(), props29);
  return (0, import_jsx_runtime202.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
ProgressLabel.displayName = "ProgressLabel";

// node_modules/@ark-ui/react/dist/components/progress/progress-range.js
var import_jsx_runtime203 = __toESM(require_jsx_runtime(), 1);
var import_react435 = __toESM(require_react(), 1);
var ProgressRange = (0, import_react435.forwardRef)((props29, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getRangeProps(), props29);
  return (0, import_jsx_runtime203.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressRange.displayName = "ProgressRange";

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var import_jsx_runtime204 = __toESM(require_jsx_runtime(), 1);
var import_react439 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/progress/use-progress.js
var import_react437 = __toESM(require_react(), 1);
var useProgress = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react437.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value
  };
  const [state2, send] = useMachine(machine19(initialContext), { context });
  return connect19(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/progress/progress-root.js
var ProgressRoot = (0, import_react439.forwardRef)((props29, ref2) => {
  const [progressProps, localProps] = createSplitProps2()(props29, [
    "id",
    "ids",
    "max",
    "min",
    "orientation",
    "translations",
    "value"
  ]);
  const progress = useProgress(progressProps);
  const mergedProps = mergeProps(progress.getRootProps(), localProps);
  return (0, import_jsx_runtime204.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime204.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ProgressRoot.displayName = "ProgressRoot";

// node_modules/@ark-ui/react/dist/components/progress/progress-root-provider.js
var import_jsx_runtime205 = __toESM(require_jsx_runtime(), 1);
var import_react441 = __toESM(require_react(), 1);
var ProgressRootProvider = (0, import_react441.forwardRef)(
  (props29, ref2) => {
    const [{ value: progress }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(progress.getRootProps(), localProps);
    return (0, import_jsx_runtime205.jsx)(ProgressProvider, { value: progress, children: (0, import_jsx_runtime205.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ProgressRootProvider.displayName = "ProgressRootProvider";

// node_modules/@ark-ui/react/dist/components/progress/progress-track.js
var import_jsx_runtime206 = __toESM(require_jsx_runtime(), 1);
var import_react443 = __toESM(require_react(), 1);
var ProgressTrack = (0, import_react443.forwardRef)((props29, ref2) => {
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getTrackProps(), props29);
  return (0, import_jsx_runtime206.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ProgressTrack.displayName = "ProgressTrack";

// node_modules/@ark-ui/react/dist/components/progress/progress-value-text.js
var import_jsx_runtime207 = __toESM(require_jsx_runtime(), 1);
var import_react445 = __toESM(require_react(), 1);
var ProgressValueText = (0, import_react445.forwardRef)(
  (props29, ref2) => {
    const { children, ...rest } = props29;
    const progress = useProgressContext();
    const mergedProps = mergeProps(progress.getValueTextProps(), rest);
    return (0, import_jsx_runtime207.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || progress.valueAsString });
  }
);
ProgressValueText.displayName = "ProgressValueText";

// node_modules/@ark-ui/react/dist/components/progress/progress-view.js
var import_jsx_runtime208 = __toESM(require_jsx_runtime(), 1);
var import_react447 = __toESM(require_react(), 1);
var ProgressView = (0, import_react447.forwardRef)((props29, ref2) => {
  const [viewProps2, localProps] = createSplitProps2()(props29, ["state"]);
  const progress = useProgressContext();
  const mergedProps = mergeProps(progress.getViewProps(viewProps2), localProps);
  return (0, import_jsx_runtime208.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
ProgressView.displayName = "ProgressView";

// node_modules/@ark-ui/react/dist/components/progress/progress.js
var progress_exports = {};
__export(progress_exports, {
  Circle: () => ProgressCircle,
  CircleRange: () => ProgressCircleRange,
  CircleTrack: () => ProgressCircleTrack,
  Context: () => ProgressContext,
  Label: () => ProgressLabel,
  Range: () => ProgressRange,
  Root: () => ProgressRoot,
  RootProvider: () => ProgressRootProvider,
  Track: () => ProgressTrack,
  ValueText: () => ProgressValueText,
  View: () => ProgressView
});

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code-context.js
var [QrCodeProvider, useQrCodeContext] = createContext({
  name: "QrCodeContext",
  hookName: "useQrCodeContext",
  providerName: "<QrCodeProvider />"
});

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-context.js
var QrCodeContext = (props29) => props29.children(useQrCodeContext());

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-frame.js
var import_jsx_runtime209 = __toESM(require_jsx_runtime(), 1);
var import_react449 = __toESM(require_react(), 1);
var QrCodeFrame = (0, import_react449.forwardRef)((props29, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps(qrCode.getFrameProps(), props29);
  return (0, import_jsx_runtime209.jsx)(ark.svg, { ...mergedProps, ref: ref2 });
});
QrCodeFrame.displayName = "QrCodeFrame";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-overlay.js
var import_jsx_runtime210 = __toESM(require_jsx_runtime(), 1);
var import_react451 = __toESM(require_react(), 1);
var QrCodeOverlay = (0, import_react451.forwardRef)((props29, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps(qrCode.getOverlayProps(), props29);
  return (0, import_jsx_runtime210.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
QrCodeOverlay.displayName = "QrCodeOverlay";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-pattern.js
var import_jsx_runtime211 = __toESM(require_jsx_runtime(), 1);
var import_react453 = __toESM(require_react(), 1);
var QrCodePattern = (0, import_react453.forwardRef)((props29, ref2) => {
  const qrCode = useQrCodeContext();
  const mergedProps = mergeProps(qrCode.getPatternProps(), props29);
  return (0, import_jsx_runtime211.jsx)(ark.path, { ...mergedProps, ref: ref2 });
});
QrCodePattern.displayName = "QrCodePattern";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var import_jsx_runtime212 = __toESM(require_jsx_runtime(), 1);
var import_react457 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/qr-code/use-qr-code.js
var import_react455 = __toESM(require_react(), 1);
var useQrCode = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const context = {
    id: (0, import_react455.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props29
  };
  const [state2, send] = useMachine(machine20(context), { context });
  return connect20(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root.js
var QrCodeRoot = (0, import_react457.forwardRef)((props29, ref2) => {
  const [qrcodeProps, localProps] = createSplitProps2()(props29, [
    "encoding",
    "id",
    "ids",
    "value"
  ]);
  const qrCode = useQrCode(qrcodeProps);
  const mergedProps = mergeProps(qrCode.getRootProps(), localProps);
  return (0, import_jsx_runtime212.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime212.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
QrCodeRoot.displayName = "QrcodeRoot";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code-root-provider.js
var import_jsx_runtime213 = __toESM(require_jsx_runtime(), 1);
var import_react459 = __toESM(require_react(), 1);
var QrCodeRootProvider = (0, import_react459.forwardRef)(
  (props29, ref2) => {
    const [{ value: qrCode }, localProps] = createSplitProps2()(props29, ["value"]);
    const mergedProps = mergeProps(qrCode.getRootProps(), localProps);
    return (0, import_jsx_runtime213.jsx)(QrCodeProvider, { value: qrCode, children: (0, import_jsx_runtime213.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
QrCodeRootProvider.displayName = "QrCodeRootProvider";

// node_modules/@ark-ui/react/dist/components/qr-code/qr-code.js
var qr_code_exports = {};
__export(qr_code_exports, {
  Frame: () => QrCodeFrame,
  Overlay: () => QrCodeOverlay,
  Pattern: () => QrCodePattern,
  QrCodeContext: () => QrCodeContext,
  Root: () => QrCodeRoot,
  RootProvider: () => QrCodeRootProvider
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-context.js
var [RadioGroupProvider, useRadioGroupContext] = createContext({
  name: "RadioGroupContext",
  hookName: "useRadioGroupContext",
  providerName: "<RadioGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-context.js
var RadioGroupContext = (props29) => props29.children(useRadioGroupContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-indicator.js
var import_jsx_runtime214 = __toESM(require_jsx_runtime(), 1);
var import_react461 = __toESM(require_react(), 1);
var RadioGroupIndicator = (0, import_react461.forwardRef)(
  (props29, ref2) => {
    const radioGroup = useRadioGroupContext();
    const mergedProps = mergeProps(radioGroup.getIndicatorProps(), props29);
    return (0, import_jsx_runtime214.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupIndicator.displayName = "RadioGroupIndicator";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var import_jsx_runtime215 = __toESM(require_jsx_runtime(), 1);
var import_react463 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-context.js
var [RadioGroupItemProvider, useRadioGroupItemContext] = createContext({
  name: "RadioGroupItemContext",
  hookName: "useRadioGroupItemContext",
  providerName: "<RadioGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group-item-props-context.js
var [RadioGroupItemPropsProvider, useRadioGroupItemPropsContext] = createContext({
  name: "RadioGroupItemPropsContext",
  hookName: "useRadioGroupItemPropsContext",
  providerName: "<RadioGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item.js
var RadioGroupItem = (0, import_react463.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, [
    "value",
    "disabled",
    "invalid"
  ]);
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps(radioGroup.getItemProps(itemProps10), localProps);
  const itemState = radioGroup.getItemState(itemProps10);
  return (0, import_jsx_runtime215.jsx)(RadioGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime215.jsx)(RadioGroupItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime215.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
});
RadioGroupItem.displayName = "RadioGroupItem";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-context.js
var RadioGroupItemContext = (props29) => props29.children(useRadioGroupItemContext());

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-control.js
var import_jsx_runtime216 = __toESM(require_jsx_runtime(), 1);
var import_react465 = __toESM(require_react(), 1);
var RadioGroupItemControl = (0, import_react465.forwardRef)(
  (props29, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps10 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps(radioGroup.getItemControlProps(itemProps10), props29);
    return (0, import_jsx_runtime216.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemControl.displayName = "RadioGroupItemControl";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-hidden-input.js
var import_jsx_runtime217 = __toESM(require_jsx_runtime(), 1);
var import_react467 = __toESM(require_react(), 1);
var RadioGroupItemHiddenInput = (0, import_react467.forwardRef)((props29, ref2) => {
  const radioGroup = useRadioGroupContext();
  const itemProps10 = useRadioGroupItemPropsContext();
  const mergedProps = mergeProps(radioGroup.getItemHiddenInputProps(itemProps10), props29);
  return (0, import_jsx_runtime217.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
RadioGroupItemHiddenInput.displayName = "RadioGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-item-text.js
var import_jsx_runtime218 = __toESM(require_jsx_runtime(), 1);
var import_react469 = __toESM(require_react(), 1);
var RadioGroupItemText = (0, import_react469.forwardRef)(
  (props29, ref2) => {
    const radioGroup = useRadioGroupContext();
    const itemProps10 = useRadioGroupItemPropsContext();
    const mergedProps = mergeProps(radioGroup.getItemTextProps(itemProps10), props29);
    return (0, import_jsx_runtime218.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
RadioGroupItemText.displayName = "RadioGroupItemText";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-label.js
var import_jsx_runtime219 = __toESM(require_jsx_runtime(), 1);
var import_react471 = __toESM(require_react(), 1);
var RadioGroupLabel = (0, import_react471.forwardRef)((props29, ref2) => {
  const radioGroup = useRadioGroupContext();
  const mergedProps = mergeProps(radioGroup.getLabelProps(), props29);
  return (0, import_jsx_runtime219.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
RadioGroupLabel.displayName = "RadioGroupLabel";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var import_jsx_runtime220 = __toESM(require_jsx_runtime(), 1);
var import_react475 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/radio-group/use-radio-group.js
var import_react473 = __toESM(require_react(), 1);
var useRadioGroup = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react473.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine21(initialContext), {
    context
  });
  return connect21(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root.js
var RadioGroupRoot = (0, import_react475.forwardRef)((props29, ref2) => {
  const [useRadioGroupProps, localProps] = createSplitProps2()(props29, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const radioGroup = useRadioGroup(useRadioGroupProps);
  const mergedProps = mergeProps(radioGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime220.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime220.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RadioGroupRoot.displayName = "RadioGroupRoot";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group-root-provider.js
var import_jsx_runtime221 = __toESM(require_jsx_runtime(), 1);
var import_react477 = __toESM(require_react(), 1);
var RadioGroupRootProvider = (0, import_react477.forwardRef)(
  (props29, ref2) => {
    const [{ value: radioGroup }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(radioGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime221.jsx)(RadioGroupProvider, { value: radioGroup, children: (0, import_jsx_runtime221.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RadioGroupRootProvider.displayName = "RadioGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/radio-group/radio-group.js
var radio_group_exports = {};
__export(radio_group_exports, {
  Context: () => RadioGroupContext,
  Indicator: () => RadioGroupIndicator,
  Item: () => RadioGroupItem,
  ItemContext: () => RadioGroupItemContext,
  ItemControl: () => RadioGroupItemControl,
  ItemHiddenInput: () => RadioGroupItemHiddenInput,
  ItemText: () => RadioGroupItemText,
  Label: () => RadioGroupLabel,
  Root: () => RadioGroupRoot,
  RootProvider: () => RadioGroupRootProvider
});

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-context.js
var [RatingGroupProvider, useRatingGroupContext] = createContext({
  name: "RatingGroupContext",
  hookName: "useRatingGroupContext",
  providerName: "<RatingGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-context.js
var RatingGroupContext = (props29) => props29.children(useRatingGroupContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-control.js
var import_jsx_runtime222 = __toESM(require_jsx_runtime(), 1);
var import_react479 = __toESM(require_react(), 1);
var RatingGroupControl = (0, import_react479.forwardRef)(
  (props29, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps(ratingGroup.getControlProps(), props29);
    return (0, import_jsx_runtime222.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupControl.displayName = "RatingGroupControl";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-hidden-input.js
var import_jsx_runtime223 = __toESM(require_jsx_runtime(), 1);
var import_react481 = __toESM(require_react(), 1);
var RatingGroupHiddenInput = (0, import_react481.forwardRef)(
  (props29, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps(ratingGroup.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime223.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupHiddenInput.displayName = "RatingGroupHiddenInput";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var import_jsx_runtime224 = __toESM(require_jsx_runtime(), 1);
var import_react483 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group-item-context.js
var [RatingGroupItemProvider, useRatingGroupItemContext] = createContext({
  name: "RatingGroupItemContext",
  hookName: "useRatingGroupItemContext",
  providerName: "<RatingGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item.js
var RatingGroupItem = (0, import_react483.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["index"]);
  const ratingGroup = useRatingGroupContext();
  const mergedProps = mergeProps(ratingGroup.getItemProps(itemProps10), localProps);
  const itemState = ratingGroup.getItemState(itemProps10);
  return (0, import_jsx_runtime224.jsx)(RatingGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime224.jsx)(ark.span, { ...mergedProps, ref: ref2 }) });
});
RatingGroupItem.displayName = "RatingGroupItem";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-item-context.js
var RatingGroupItemContext = (props29) => props29.children(useRatingGroupItemContext());

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-label.js
var import_jsx_runtime225 = __toESM(require_jsx_runtime(), 1);
var import_react485 = __toESM(require_react(), 1);
var RatingGroupLabel = (0, import_react485.forwardRef)(
  (props29, ref2) => {
    const ratingGroup = useRatingGroupContext();
    const mergedProps = mergeProps(ratingGroup.getLabelProps(), props29);
    return (0, import_jsx_runtime225.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
RatingGroupLabel.displayName = "RatingGroupLabel";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var import_jsx_runtime226 = __toESM(require_jsx_runtime(), 1);
var import_react489 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/rating-group/use-rating-group.js
var import_react487 = __toESM(require_react(), 1);
var useRatingGroup = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react487.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onHoverChange: useEvent(props29.onHoverChange)
  };
  const [state2, send] = useMachine(machine22(initialContext), {
    context
  });
  return connect22(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root.js
var RatingGroupRoot = (0, import_react489.forwardRef)((props29, ref2) => {
  const [useRatingProps, localProps] = createSplitProps2()(props29, [
    "allowHalf",
    "autoFocus",
    "count",
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onHoverChange",
    "onValueChange",
    "readOnly",
    "translations",
    "value"
  ]);
  const ratingGroup = useRatingGroup(useRatingProps);
  const mergedProps = mergeProps(ratingGroup.getRootProps(), localProps);
  return (0, import_jsx_runtime226.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime226.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
RatingGroupRoot.displayName = "RatingGroupRoot";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group-root-provider.js
var import_jsx_runtime227 = __toESM(require_jsx_runtime(), 1);
var import_react491 = __toESM(require_react(), 1);
var RatingGroupRootProvider = (0, import_react491.forwardRef)(
  (props29, ref2) => {
    const [{ value: ratingGroup }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(ratingGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime227.jsx)(RatingGroupProvider, { value: ratingGroup, children: (0, import_jsx_runtime227.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
RatingGroupRootProvider.displayName = "RatingGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/rating-group/rating-group.js
var rating_group_exports = {};
__export(rating_group_exports, {
  Context: () => RatingGroupContext,
  Control: () => RatingGroupControl,
  HiddenInput: () => RatingGroupHiddenInput,
  Item: () => RatingGroupItem,
  ItemContext: () => RatingGroupItemContext,
  Label: () => RatingGroupLabel,
  Root: () => RatingGroupRoot
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-context.js
var [SegmentGroupProvider, useSegmentGroupContext] = createContext(
  {
    name: "SegmentGroupContext",
    hookName: "useSegmentGroupContext",
    providerName: "<SegmentGroupProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-context.js
var SegmentGroupContext = (props29) => props29.children(useSegmentGroupContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-indicator.js
var import_jsx_runtime228 = __toESM(require_jsx_runtime(), 1);
var import_react493 = __toESM(require_react(), 1);
var SegmentGroupIndicator = (0, import_react493.forwardRef)(
  (props29, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps(
      segmentGroup.getIndicatorProps(),
      anatomy27.build().indicator.attrs,
      props29
    );
    return (0, import_jsx_runtime228.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupIndicator.displayName = "SegmentGroupIndicator";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var import_jsx_runtime229 = __toESM(require_jsx_runtime(), 1);
var import_react495 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-context.js
var [SegmentGroupItemProvider, useSegmentGroupItemContext] = createContext({
  name: "SegmentGroupItemContext",
  hookName: "useSegmentGroupItemContext",
  providerName: "<SegmentGroupItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group-item-props-context.js
var [SegmentGroupItemPropsProvider, useSegmentGroupItemPropsContext] = createContext({
  name: "SegmentGroupItemPropsContext",
  hookName: "useSegmentGroupItemPropsContext",
  providerName: "<SegmentGroupItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item.js
var SegmentGroupItem = (0, import_react495.forwardRef)(
  (props29, ref2) => {
    const [itemProps10, localProps] = createSplitProps2()(props29, [
      "value",
      "disabled",
      "invalid"
    ]);
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps(
      segmentGroup.getItemProps(itemProps10),
      anatomy27.build().item.attrs,
      localProps
    );
    const itemState = segmentGroup.getItemState(itemProps10);
    return (0, import_jsx_runtime229.jsx)(SegmentGroupItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime229.jsx)(SegmentGroupItemProvider, { value: itemState, children: (0, import_jsx_runtime229.jsx)(ark.label, { ...mergedProps, ref: ref2 }) }) });
  }
);
SegmentGroupItem.displayName = "SegmentGroupItem";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-context.js
var SegmentGroupItemContext = (props29) => props29.children(useSegmentGroupItemContext());

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-control.js
var import_jsx_runtime230 = __toESM(require_jsx_runtime(), 1);
var import_react497 = __toESM(require_react(), 1);
var SegmentGroupItemControl = (0, import_react497.forwardRef)(
  (props29, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps10 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps(
      segmentGroup.getItemControlProps(itemProps10),
      anatomy27.build().itemControl.attrs,
      props29
    );
    return (0, import_jsx_runtime230.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemControl.displayName = "SegmentGroupItemControl";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-hidden-input.js
var import_jsx_runtime231 = __toESM(require_jsx_runtime(), 1);
var import_react499 = __toESM(require_react(), 1);
var SegmentGroupItemHiddenInput = (0, import_react499.forwardRef)((props29, ref2) => {
  const segmentGroup = useSegmentGroupContext();
  const itemProps10 = useSegmentGroupItemPropsContext();
  const mergedProps = mergeProps(segmentGroup.getItemHiddenInputProps(itemProps10), props29);
  return (0, import_jsx_runtime231.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
SegmentGroupItemHiddenInput.displayName = "SegmentGroupItemHiddenInput";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-item-text.js
var import_jsx_runtime232 = __toESM(require_jsx_runtime(), 1);
var import_react501 = __toESM(require_react(), 1);
var SegmentGroupItemText = (0, import_react501.forwardRef)(
  (props29, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const itemProps10 = useSegmentGroupItemPropsContext();
    const mergedProps = mergeProps(
      segmentGroup.getItemTextProps(itemProps10),
      anatomy27.build().itemText.attrs,
      props29
    );
    return (0, import_jsx_runtime232.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupItemText.displayName = "SegmentGroupItemText";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-label.js
var import_jsx_runtime233 = __toESM(require_jsx_runtime(), 1);
var import_react503 = __toESM(require_react(), 1);
var SegmentGroupLabel = (0, import_react503.forwardRef)(
  (props29, ref2) => {
    const segmentGroup = useSegmentGroupContext();
    const mergedProps = mergeProps(
      segmentGroup.getLabelProps(),
      anatomy27.build().label.attrs,
      props29
    );
    return (0, import_jsx_runtime233.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
SegmentGroupLabel.displayName = "SegmentGroupLabel";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var import_jsx_runtime234 = __toESM(require_jsx_runtime(), 1);
var import_react507 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/segment-group/use-segment-group.js
var import_react505 = __toESM(require_react(), 1);
var useSegmentGroup = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react505.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine21(initialContext), {
    context
  });
  return connect21(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root.js
var SegmentGroupRoot = (0, import_react507.forwardRef)((props29, ref2) => {
  const [useSegmentGroupProps, localProps] = createSplitProps2()(props29, [
    "defaultValue",
    "disabled",
    "form",
    "id",
    "ids",
    "name",
    "onValueChange",
    "orientation",
    "readOnly",
    "value"
  ]);
  const segmentGroup = useSegmentGroup(useSegmentGroupProps);
  const mergedProps = mergeProps(
    segmentGroup.getRootProps(),
    anatomy27.build().root.attrs,
    localProps
  );
  return (0, import_jsx_runtime234.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime234.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SegmentGroupRoot.displayName = "SegmentGroupRoot";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group-root-provider.js
var import_jsx_runtime235 = __toESM(require_jsx_runtime(), 1);
var import_react509 = __toESM(require_react(), 1);
var SegmentGroupRootProvider = (0, import_react509.forwardRef)(
  (props29, ref2) => {
    const [{ value: segmentGroup }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(
      segmentGroup.getRootProps(),
      anatomy27.build().root.attrs,
      localProps
    );
    return (0, import_jsx_runtime235.jsx)(SegmentGroupProvider, { value: segmentGroup, children: (0, import_jsx_runtime235.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SegmentGroupRootProvider.displayName = "SegmentGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/segment-group/segment-group.js
var segment_group_exports = {};
__export(segment_group_exports, {
  Context: () => SegmentGroupContext,
  Indicator: () => SegmentGroupIndicator,
  Item: () => SegmentGroupItem,
  ItemContext: () => SegmentGroupItemContext,
  ItemControl: () => SegmentGroupItemControl,
  ItemHiddenInput: () => SegmentGroupItemHiddenInput,
  ItemText: () => SegmentGroupItemText,
  Label: () => SegmentGroupLabel,
  Root: () => SegmentGroupRoot
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var import_jsx_runtime236 = __toESM(require_jsx_runtime(), 1);
var import_react511 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-context.js
var [SelectProvider, useSelectContext] = createContext({
  name: "SelectContext",
  hookName: "useSelectContext",
  providerName: "<SelectProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-clear-trigger.js
var SelectClearTrigger = (0, import_react511.forwardRef)(
  (props29, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps(select.getClearTriggerProps(), props29);
    return (0, import_jsx_runtime236.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
SelectClearTrigger.displayName = "SelectClearTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-content.js
var import_jsx_runtime237 = __toESM(require_jsx_runtime(), 1);
var import_react513 = __toESM(require_react(), 1);
var SelectContent = (0, import_react513.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(select.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime237.jsx)(ark.div, { ...mergedProps });
});
SelectContent.displayName = "SelectContent";

// node_modules/@ark-ui/react/dist/components/select/select-context.js
var SelectContext = (props29) => props29.children(useSelectContext());

// node_modules/@ark-ui/react/dist/components/select/select-control.js
var import_jsx_runtime238 = __toESM(require_jsx_runtime(), 1);
var import_react515 = __toESM(require_react(), 1);
var SelectControl = (0, import_react515.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getControlProps(), props29);
  return (0, import_jsx_runtime238.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectControl.displayName = "SelectControl";

// node_modules/@ark-ui/react/dist/components/select/select-hidden-select.js
var import_jsx_runtime239 = __toESM(require_jsx_runtime(), 1);
var import_react517 = __toESM(require_react(), 1);
var SelectHiddenSelect = (0, import_react517.forwardRef)(
  (props29, ref2) => {
    const select = useSelectContext();
    const mergedProps = mergeProps(select.getHiddenSelectProps(), props29);
    const isValueEmpty = select.value.length === 0;
    return (0, import_jsx_runtime239.jsxs)(ark.select, { ...mergedProps, ref: ref2, children: [
      isValueEmpty && (0, import_jsx_runtime239.jsx)("option", { value: "" }),
      select.collection.toArray().map((option) => (0, import_jsx_runtime239.jsx)("option", { value: option.value, children: option.label }, option.value))
    ] });
  }
);
SelectHiddenSelect.displayName = "SelectHiddenSelect";

// node_modules/@ark-ui/react/dist/components/select/select-indicator.js
var import_jsx_runtime240 = __toESM(require_jsx_runtime(), 1);
var import_react519 = __toESM(require_react(), 1);
var SelectIndicator = (0, import_react519.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getIndicatorProps(), props29);
  return (0, import_jsx_runtime240.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectIndicator.displayName = "SelectIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var import_jsx_runtime241 = __toESM(require_jsx_runtime(), 1);
var import_react521 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-context.js
var [SelectItemProvider, useSelectItemContext] = createContext({
  name: "SelectItemContext",
  hookName: "useSelectItemContext",
  providerName: "<SelectItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/use-select-item-props-context.js
var [SelectItemPropsProvider, useSelectItemPropsContext] = createContext({
  name: "SelectItemPropsContext",
  hookName: "useSelectItemPropsContext",
  providerName: "<SelectItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item.js
var SelectItem = (0, import_react521.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["item", "persistFocus"]);
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemProps(itemProps10), localProps);
  const itemState = select.getItemState(itemProps10);
  return (0, import_jsx_runtime241.jsx)(SelectItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime241.jsx)(SelectItemProvider, { value: itemState, children: (0, import_jsx_runtime241.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
SelectItem.displayName = "SelectItem";

// node_modules/@ark-ui/react/dist/components/select/select-item-context.js
var SelectItemContext = (props29) => props29.children(useSelectItemContext());

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var import_jsx_runtime242 = __toESM(require_jsx_runtime(), 1);
var import_react523 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select-item-group-props.js
var [SelectItemGroupPropsProvider, useSelectItemGroupPropsContext] = createContext({
  name: "SelectItemGroupPropsContext",
  hookName: "useSelectItemGroupPropsContext",
  providerName: "<SelectItemGroupPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/select/select-item-group.js
var SelectItemGroup = (0, import_react523.forwardRef)((props29, ref2) => {
  const id = (0, import_react523.useId)();
  const [_itemGroupProps, localProps] = createSplitProps2()(props29, ["id"]);
  const itemGroupProps3 = { id, ..._itemGroupProps };
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getItemGroupProps(itemGroupProps3), localProps);
  return (0, import_jsx_runtime242.jsx)(SelectItemGroupPropsProvider, { value: itemGroupProps3, children: (0, import_jsx_runtime242.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SelectItemGroup.displayName = "SelectItemGroup";

// node_modules/@ark-ui/react/dist/components/select/select-item-group-label.js
var import_jsx_runtime243 = __toESM(require_jsx_runtime(), 1);
var import_react525 = __toESM(require_react(), 1);
var SelectItemGroupLabel = (0, import_react525.forwardRef)(
  (props29, ref2) => {
    const select = useSelectContext();
    const itemGroupProps3 = useSelectItemGroupPropsContext();
    const mergedProps = mergeProps(
      select.getItemGroupLabelProps({ htmlFor: itemGroupProps3.id }),
      props29
    );
    return (0, import_jsx_runtime243.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemGroupLabel.displayName = "SelectItemGroupLabel";

// node_modules/@ark-ui/react/dist/components/select/select-item-indicator.js
var import_jsx_runtime244 = __toESM(require_jsx_runtime(), 1);
var import_react527 = __toESM(require_react(), 1);
var SelectItemIndicator = (0, import_react527.forwardRef)(
  (props29, ref2) => {
    const select = useSelectContext();
    const itemProps10 = useSelectItemPropsContext();
    const mergedProps = mergeProps(select.getItemIndicatorProps(itemProps10), props29);
    return (0, import_jsx_runtime244.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SelectItemIndicator.displayName = "SelectItemIndicator";

// node_modules/@ark-ui/react/dist/components/select/select-item-text.js
var import_jsx_runtime245 = __toESM(require_jsx_runtime(), 1);
var import_react529 = __toESM(require_react(), 1);
var SelectItemText = (0, import_react529.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const itemProps10 = useSelectItemPropsContext();
  const mergedProps = mergeProps(select.getItemTextProps(itemProps10), props29);
  return (0, import_jsx_runtime245.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SelectItemText.displayName = "SelectItemText";

// node_modules/@ark-ui/react/dist/components/select/select-label.js
var import_jsx_runtime246 = __toESM(require_jsx_runtime(), 1);
var import_react531 = __toESM(require_react(), 1);
var SelectLabel = (0, import_react531.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getLabelProps(), props29);
  return (0, import_jsx_runtime246.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SelectLabel.displayName = "SelectLabel";

// node_modules/@ark-ui/react/dist/components/select/select-list.js
var import_jsx_runtime247 = __toESM(require_jsx_runtime(), 1);
var import_react533 = __toESM(require_react(), 1);
var SelectList = (0, import_react533.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getListProps(), props29);
  return (0, import_jsx_runtime247.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectList.displayName = "SelectList";

// node_modules/@ark-ui/react/dist/components/select/select-positioner.js
var import_jsx_runtime248 = __toESM(require_jsx_runtime(), 1);
var import_react535 = __toESM(require_react(), 1);
var SelectPositioner = (0, import_react535.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getPositionerProps(), props29);
  const presence = usePresenceContext();
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime248.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SelectPositioner.displayName = "SelectPositioner";

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var import_jsx_runtime249 = __toESM(require_jsx_runtime(), 1);
var import_react539 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/select/use-select.js
var import_react537 = __toESM(require_react(), 1);
var useSelect = (props29) => {
  const [collectionOptions, selectProps] = createSplitProps2()(props29, [
    "isItemDisabled",
    "itemToValue",
    "itemToString",
    "items"
  ]);
  const collection3 = (0, import_react537.useMemo)(
    () => collection2(collectionOptions),
    Object.values(collectionOptions)
  );
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react537.useId)(),
    dir,
    getRootNode: getRootNode2,
    collection: collection3,
    open: props29.defaultOpen,
    value: props29.defaultValue,
    "open.controlled": props29.open !== void 0,
    ...selectProps
  };
  const context = {
    ...initialContext,
    collection: collection3,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onHighlightChange: useEvent(props29.onHighlightChange),
    onOpenChange: useEvent(props29.onOpenChange)
  };
  const [state2, send] = useMachine(machine23(initialContext), {
    context
  });
  return connect23(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/select/select-root.js
var SelectImpl = (props29, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props29);
  const [useSelectProps, localProps] = createSplitProps2()(selectProps, [
    "closeOnSelect",
    "composite",
    "defaultOpen",
    "defaultValue",
    "disabled",
    "form",
    "highlightedValue",
    "id",
    "ids",
    "invalid",
    "isItemDisabled",
    "items",
    "itemToString",
    "itemToValue",
    "loopFocus",
    "multiple",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInteractOutside",
    "onOpenChange",
    "onPointerDownOutside",
    "onValueChange",
    "open",
    "positioning",
    "readOnly",
    "scrollToIndexFn",
    "value"
  ]);
  const select = useSelect(useSelectProps);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return (0, import_jsx_runtime249.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime249.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime249.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRoot = (0, import_react539.forwardRef)(SelectImpl);

// node_modules/@ark-ui/react/dist/components/select/select-root-provider.js
var import_jsx_runtime250 = __toESM(require_jsx_runtime(), 1);
var import_react541 = __toESM(require_react(), 1);
var SelectImpl2 = (props29, ref2) => {
  const [presenceProps, selectProps] = splitPresenceProps(props29);
  const [{ value: select }, localProps] = createSplitProps2()(selectProps, [
    "value"
  ]);
  const presence = usePresence(mergeProps({ present: select.open }, presenceProps));
  const mergedProps = mergeProps(select.getRootProps(), localProps);
  return (0, import_jsx_runtime250.jsx)(SelectProvider, { value: select, children: (0, import_jsx_runtime250.jsx)(PresenceProvider, { value: presence, children: (0, import_jsx_runtime250.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
};
var SelectRootProvider = (0, import_react541.forwardRef)(SelectImpl2);

// node_modules/@ark-ui/react/dist/components/select/select-trigger.js
var import_jsx_runtime251 = __toESM(require_jsx_runtime(), 1);
var import_react543 = __toESM(require_react(), 1);
var SelectTrigger = (0, import_react543.forwardRef)((props29, ref2) => {
  const select = useSelectContext();
  const mergedProps = mergeProps(select.getTriggerProps(), props29);
  return (0, import_jsx_runtime251.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
SelectTrigger.displayName = "SelectTrigger";

// node_modules/@ark-ui/react/dist/components/select/select-value-text.js
var import_jsx_runtime252 = __toESM(require_jsx_runtime(), 1);
var import_react544 = __toESM(require_react(), 1);
var SelectValueText = (0, import_react544.forwardRef)((props29, ref2) => {
  const { children, placeholder, ...rest } = props29;
  const select = useSelectContext();
  return (0, import_jsx_runtime252.jsx)(ark.span, { ...anatomy29.build().valueText.attrs, ...rest, ref: ref2, children: children || select.valueAsString || placeholder });
});
SelectValueText.displayName = "SelectValueText";

// node_modules/@ark-ui/react/dist/components/select/select.js
var select_exports = {};
__export(select_exports, {
  ClearTrigger: () => SelectClearTrigger,
  Content: () => SelectContent,
  Context: () => SelectContext,
  Control: () => SelectControl,
  HiddenSelect: () => SelectHiddenSelect,
  Indicator: () => SelectIndicator,
  Item: () => SelectItem,
  ItemContext: () => SelectItemContext,
  ItemGroup: () => SelectItemGroup,
  ItemGroupLabel: () => SelectItemGroupLabel,
  ItemIndicator: () => SelectItemIndicator,
  ItemText: () => SelectItemText,
  Label: () => SelectLabel,
  List: () => SelectList,
  Positioner: () => SelectPositioner,
  Root: () => SelectRoot,
  RootProvider: () => SelectRootProvider,
  Trigger: () => SelectTrigger,
  ValueText: () => SelectValueText
});

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-clear-trigger.js
var import_jsx_runtime253 = __toESM(require_jsx_runtime(), 1);
var import_react546 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/signature-pad/use-signature-pad-context.js
var [SignaturePadProvider, useSignaturePadContext] = createContext(
  {
    name: "SignaturePadContext",
    hookName: "useSignaturePadContext",
    providerName: "<SignaturePadProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-clear-trigger.js
var SignaturePadClearTrigger = (0, import_react546.forwardRef)((props29, ref2) => {
  const signaturePad = useSignaturePadContext();
  const mergedProps = mergeProps(signaturePad.getClearTriggerProps(), props29);
  return (0, import_jsx_runtime253.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
SignaturePadClearTrigger.displayName = "SignaturePadClearTrigger";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-context.js
var SignaturePadContext = (props29) => props29.children(useSignaturePadContext());

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-control.js
var import_jsx_runtime254 = __toESM(require_jsx_runtime(), 1);
var import_react548 = __toESM(require_react(), 1);
var SignaturePadControl = (0, import_react548.forwardRef)(
  (props29, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps(signaturePad.getControlProps(), props29);
    return (0, import_jsx_runtime254.jsx)(ark.div, { role: "application", ...mergedProps, ref: ref2 });
  }
);
SignaturePadControl.displayName = "SignaturePadControl";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-guide.js
var import_jsx_runtime255 = __toESM(require_jsx_runtime(), 1);
var import_react550 = __toESM(require_react(), 1);
var SignaturePadGuide = (0, import_react550.forwardRef)(
  (props29, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps(signaturePad.getGuideProps(), props29);
    return (0, import_jsx_runtime255.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SignaturePadGuide.displayName = "SignaturePadGuide";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-label.js
var import_jsx_runtime256 = __toESM(require_jsx_runtime(), 1);
var import_react552 = __toESM(require_react(), 1);
var SignaturePadLabel = (0, import_react552.forwardRef)(
  (props29, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps(signaturePad.getLabelProps(), props29);
    return (0, import_jsx_runtime256.jsx)(ark.label, { ...mergedProps, ref: ref2 });
  }
);
SignaturePadLabel.displayName = "SignaturePadLabel";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root.js
var import_jsx_runtime257 = __toESM(require_jsx_runtime(), 1);
var import_react556 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/signature-pad/use-signature-pad.js
var import_react554 = __toESM(require_react(), 1);
var useSignaturePad = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react554.useId)(),
    dir,
    getRootNode: getRootNode2,
    ...props29
  };
  const context = {
    ...initialContext,
    drawing: props29.drawing,
    onDraw: useEvent(props29.onDraw),
    onDrawEnd: useEvent(props29.onDrawEnd)
  };
  const [state2, send] = useMachine(machine24(initialContext), { context });
  return connect24(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root.js
var SignaturePadRoot = (0, import_react556.forwardRef)((props29, ref2) => {
  const [useSignaturePadProps, localProps] = createSplitProps2()(props29, [
    "id",
    "ids",
    "drawing",
    "disabled",
    "readOnly",
    "name",
    "onDraw",
    "onDrawEnd"
  ]);
  const signaturePad = useSignaturePad(useSignaturePadProps);
  const mergedProps = mergeProps(signaturePad.getRootProps(), localProps);
  return (0, import_jsx_runtime257.jsx)(SignaturePadProvider, { value: signaturePad, children: (0, import_jsx_runtime257.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SignaturePadRoot.displayName = "SignaturePadRoot";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-root-provider.js
var import_jsx_runtime258 = __toESM(require_jsx_runtime(), 1);
var import_react558 = __toESM(require_react(), 1);
var SignaturePadRootProvider = (0, import_react558.forwardRef)(
  (props29, ref2) => {
    const [{ value: signaturePad }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(signaturePad.getRootProps(), localProps);
    return (0, import_jsx_runtime258.jsx)(SignaturePadProvider, { value: signaturePad, children: (0, import_jsx_runtime258.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SignaturePadRootProvider.displayName = "SignaturePadRootProvider";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad-segment.js
var import_jsx_runtime259 = __toESM(require_jsx_runtime(), 1);
var import_react560 = __toESM(require_react(), 1);
var SignaturePadSegment = (0, import_react560.forwardRef)(
  (props29, ref2) => {
    const signaturePad = useSignaturePadContext();
    const mergedProps = mergeProps(signaturePad.getSegmentProps(), props29);
    return (0, import_jsx_runtime259.jsxs)(ark.svg, { ...mergedProps, ref: ref2, children: [
      (0, import_jsx_runtime259.jsx)("title", { children: "Signature" }),
      signaturePad.paths.map((path, i) => (0, import_jsx_runtime259.jsx)("path", { ...signaturePad.getSegmentPathProps({ path }) }, i)),
      signaturePad.currentPath && (0, import_jsx_runtime259.jsx)("path", { ...signaturePad.getSegmentPathProps({ path: signaturePad.currentPath }) })
    ] });
  }
);
SignaturePadSegment.displayName = "SignaturePadSegment";

// node_modules/@ark-ui/react/dist/components/signature-pad/signature-pad.js
var signature_pad_exports = {};
__export(signature_pad_exports, {
  ClearTrigger: () => SignaturePadClearTrigger,
  Context: () => SignaturePadContext,
  Control: () => SignaturePadControl,
  Guide: () => SignaturePadGuide,
  Label: () => SignaturePadLabel,
  Root: () => SignaturePadRoot,
  RootProvider: () => SignaturePadRootProvider,
  Segment: () => SignaturePadSegment
});

// node_modules/@ark-ui/react/dist/components/slider/use-slider-context.js
var [SliderProvider, useSliderContext] = createContext({
  name: "SliderContext",
  hookName: "useSliderContext",
  providerName: "<SliderProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-context.js
var SliderContext = (props29) => props29.children(useSliderContext());

// node_modules/@ark-ui/react/dist/components/slider/slider-control.js
var import_jsx_runtime260 = __toESM(require_jsx_runtime(), 1);
var import_react562 = __toESM(require_react(), 1);
var SliderControl = (0, import_react562.forwardRef)((props29, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getControlProps(), props29);
  return (0, import_jsx_runtime260.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderControl.displayName = "SliderControl";

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var import_jsx_runtime261 = __toESM(require_jsx_runtime(), 1);
var import_react564 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider-thumb-props-context.js
var [SliderThumbPropsProvider, useSliderThumbPropsContext] = createContext({
  name: "SliderThumbPropsContext",
  hookName: "useSliderThumbPropsContext",
  providerName: "<SliderThumbPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/slider/slider-hidden-input.js
var SliderHiddenInput = (0, import_react564.forwardRef)(
  (props29, ref2) => {
    const slider = useSliderContext();
    const thumbProps2 = useSliderThumbPropsContext();
    const mergedProps = mergeProps(slider.getHiddenInputProps(thumbProps2), props29);
    return (0, import_jsx_runtime261.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
SliderHiddenInput.displayName = "SliderHiddenInput";

// node_modules/@ark-ui/react/dist/components/slider/slider-label.js
var import_jsx_runtime262 = __toESM(require_jsx_runtime(), 1);
var import_react566 = __toESM(require_react(), 1);
var SliderLabel = (0, import_react566.forwardRef)((props29, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getLabelProps(), props29);
  return (0, import_jsx_runtime262.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
SliderLabel.displayName = "SliderLabel";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker.js
var import_jsx_runtime263 = __toESM(require_jsx_runtime(), 1);
var import_react568 = __toESM(require_react(), 1);
var SliderMarker = (0, import_react568.forwardRef)((props29, ref2) => {
  const [markerProps, localProps] = createSplitProps2()(props29, ["value"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getMarkerProps(markerProps), localProps);
  return (0, import_jsx_runtime263.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SliderMarker.displayName = "SliderMarker";

// node_modules/@ark-ui/react/dist/components/slider/slider-marker-group.js
var import_jsx_runtime264 = __toESM(require_jsx_runtime(), 1);
var import_react570 = __toESM(require_react(), 1);
var SliderMarkerGroup = (0, import_react570.forwardRef)(
  (props29, ref2) => {
    const slider = useSliderContext();
    const mergedProps = mergeProps(slider.getMarkerGroupProps(), props29);
    return (0, import_jsx_runtime264.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
SliderMarkerGroup.displayName = "SliderMarkerGroup";

// node_modules/@ark-ui/react/dist/components/slider/slider-range.js
var import_jsx_runtime265 = __toESM(require_jsx_runtime(), 1);
var import_react572 = __toESM(require_react(), 1);
var SliderRange = (0, import_react572.forwardRef)((props29, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getRangeProps(), props29);
  return (0, import_jsx_runtime265.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderRange.displayName = "SliderRange";

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var import_jsx_runtime266 = __toESM(require_jsx_runtime(), 1);
var import_react576 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/slider/use-slider.js
var import_react574 = __toESM(require_react(), 1);
var useSlider = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react574.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onValueChangeEnd: useEvent(props29.onValueChangeEnd),
    onFocusChange: useEvent(props29.onFocusChange)
  };
  const [state2, send] = useMachine(machine25(initialContext), {
    context
  });
  return connect25(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/slider/slider-root.js
var SliderRoot = (0, import_react576.forwardRef)((props29, ref2) => {
  const [useSliderProps, localProps] = createSplitProps2()(props29, [
    "aria-label",
    "aria-labelledby",
    "defaultValue",
    "disabled",
    "form",
    "getAriaValueText",
    "id",
    "ids",
    "invalid",
    "max",
    "min",
    "minStepsBetweenThumbs",
    "name",
    "onFocusChange",
    "onValueChange",
    "onValueChangeEnd",
    "orientation",
    "origin",
    "readOnly",
    "step",
    "thumbAlignment",
    "thumbAlignment",
    "thumbSize",
    "value"
  ]);
  const slider = useSlider(useSliderProps);
  const mergedProps = mergeProps(slider.getRootProps(), localProps);
  return (0, import_jsx_runtime266.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime266.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderRoot.displayName = "SliderRoot";

// node_modules/@ark-ui/react/dist/components/slider/slider-root-provider.js
var import_jsx_runtime267 = __toESM(require_jsx_runtime(), 1);
var import_react578 = __toESM(require_react(), 1);
var SliderRootProvider = (0, import_react578.forwardRef)(
  (props29, ref2) => {
    const [{ value: slider }, localProps] = createSplitProps2()(props29, ["value"]);
    const mergedProps = mergeProps(slider.getRootProps(), localProps);
    return (0, import_jsx_runtime267.jsx)(SliderProvider, { value: slider, children: (0, import_jsx_runtime267.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SliderRootProvider.displayName = "SliderRootProvider";

// node_modules/@ark-ui/react/dist/components/slider/slider-thumb.js
var import_jsx_runtime268 = __toESM(require_jsx_runtime(), 1);
var import_react580 = __toESM(require_react(), 1);
var SliderThumb = (0, import_react580.forwardRef)((props29, ref2) => {
  const [thumbProps2, localProps] = createSplitProps2()(props29, ["index", "name"]);
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getThumbProps(thumbProps2), localProps);
  return (0, import_jsx_runtime268.jsx)(SliderThumbPropsProvider, { value: thumbProps2, children: (0, import_jsx_runtime268.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SliderThumb.displayName = "SliderThumb";

// node_modules/@ark-ui/react/dist/components/slider/slider-track.js
var import_jsx_runtime269 = __toESM(require_jsx_runtime(), 1);
var import_react582 = __toESM(require_react(), 1);
var SliderTrack = (0, import_react582.forwardRef)((props29, ref2) => {
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getTrackProps(), props29);
  return (0, import_jsx_runtime269.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SliderTrack.displayName = "SliderTrack";

// node_modules/@ark-ui/react/dist/components/slider/slider-value-text.js
var import_jsx_runtime270 = __toESM(require_jsx_runtime(), 1);
var import_react584 = __toESM(require_react(), 1);
var SliderValueText = (0, import_react584.forwardRef)((props29, ref2) => {
  const { children, ...rest } = props29;
  const slider = useSliderContext();
  const mergedProps = mergeProps(slider.getValueTextProps(), rest);
  return (0, import_jsx_runtime270.jsx)(ark.span, { ...mergedProps, ref: ref2, children: children || slider.value.join(", ") });
});
SliderValueText.displayName = "SliderValueText";

// node_modules/@ark-ui/react/dist/components/slider/slider.js
var slider_exports = {};
__export(slider_exports, {
  Context: () => SliderContext,
  Control: () => SliderControl,
  HiddenInput: () => SliderHiddenInput,
  Label: () => SliderLabel,
  Marker: () => SliderMarker,
  MarkerGroup: () => SliderMarkerGroup,
  Range: () => SliderRange,
  Root: () => SliderRoot,
  RootProvider: () => SliderRootProvider,
  Thumb: () => SliderThumb,
  Track: () => SliderTrack,
  ValueText: () => SliderValueText
});

// node_modules/@ark-ui/react/dist/components/splitter/use-splitter-context.js
var [SplitterProvider, useSplitterContext] = createContext({
  name: "SplitterContext",
  hookName: "useSplitterContext",
  providerName: "<SplitterProvider />"
});

// node_modules/@ark-ui/react/dist/components/splitter/splitter-context.js
var SplitterContext = (props29) => props29.children(useSplitterContext());

// node_modules/@ark-ui/react/dist/components/splitter/splitter-panel.js
var import_jsx_runtime271 = __toESM(require_jsx_runtime(), 1);
var import_react586 = __toESM(require_react(), 1);
var SplitterPanel = (0, import_react586.forwardRef)((props29, ref2) => {
  const [splitterPanelProps, localProps] = createSplitProps2()(props29, ["id", "snapSize"]);
  const splitter = useSplitterContext();
  const mergedProps = mergeProps(splitter.getPanelProps(splitterPanelProps), localProps);
  return (0, import_jsx_runtime271.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
SplitterPanel.displayName = "SplitterPanel";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-resize-trigger.js
var import_jsx_runtime272 = __toESM(require_jsx_runtime(), 1);
var import_react588 = __toESM(require_react(), 1);
var SplitterResizeTrigger = (0, import_react588.forwardRef)(
  (props29, ref2) => {
    const [triggerProps2, localProps] = createSplitProps2()(props29, [
      "disabled",
      "id",
      "step"
    ]);
    const splitter = useSplitterContext();
    const mergedProps = mergeProps(splitter.getResizeTriggerProps(triggerProps2), localProps);
    return (0, import_jsx_runtime272.jsx)(ark.button, { ref: ref2, ...mergedProps });
  }
);
SplitterResizeTrigger.displayName = "SplitterResizeTrigger";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root.js
var import_jsx_runtime273 = __toESM(require_jsx_runtime(), 1);
var import_react592 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/splitter/use-splitter.js
var import_react590 = __toESM(require_react(), 1);
var useSplitter = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react590.useId)(),
    dir,
    getRootNode: getRootNode2,
    size: props29.defaultSize,
    ...props29
  };
  const context = {
    ...initialContext,
    size: props29.size,
    onSizeChange: useEvent(props29.onSizeChange, { sync: true }),
    onSizeChangeEnd: useEvent(props29.onSizeChangeEnd)
  };
  const [state2, send] = useMachine(machine26(initialContext), { context });
  return connect26(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root.js
var SplitterRoot = (0, import_react592.forwardRef)((props29, ref2) => {
  const [useSplitterProps, localProps] = createSplitProps2()(props29, [
    "defaultSize",
    "id",
    "ids",
    "onSizeChange",
    "onSizeChangeEnd",
    "orientation",
    "size"
  ]);
  const splitter = useSplitter(useSplitterProps);
  const mergedProps = mergeProps(splitter.getRootProps(), localProps);
  return (0, import_jsx_runtime273.jsx)(SplitterProvider, { value: splitter, children: (0, import_jsx_runtime273.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
SplitterRoot.displayName = "SplitterRoot";

// node_modules/@ark-ui/react/dist/components/splitter/splitter-root-provider.js
var import_jsx_runtime274 = __toESM(require_jsx_runtime(), 1);
var import_react594 = __toESM(require_react(), 1);
var SplitterRootProvider = (0, import_react594.forwardRef)(
  (props29, ref2) => {
    const [{ value: splitter }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(splitter.getRootProps(), localProps);
    return (0, import_jsx_runtime274.jsx)(SplitterProvider, { value: splitter, children: (0, import_jsx_runtime274.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
SplitterRootProvider.displayName = "SplitterRootProvider";

// node_modules/@ark-ui/react/dist/components/splitter/splitter.js
var splitter_exports = {};
__export(splitter_exports, {
  Context: () => SplitterContext,
  Panel: () => SplitterPanel,
  ResizeTrigger: () => SplitterResizeTrigger,
  Root: () => SplitterRoot,
  RootProvider: () => SplitterRootProvider
});

// node_modules/@ark-ui/react/dist/components/switch/use-switch-context.js
var [SwitchProvider, useSwitchContext] = createContext({
  name: "SwitchContext",
  hookName: "useSwitchContext",
  providerName: "<SwitchProvider />"
});

// node_modules/@ark-ui/react/dist/components/switch/switch-context.js
var SwitchContext = (props29) => props29.children(useSwitchContext());

// node_modules/@ark-ui/react/dist/components/switch/switch-control.js
var import_jsx_runtime275 = __toESM(require_jsx_runtime(), 1);
var import_react596 = __toESM(require_react(), 1);
var SwitchControl = (0, import_react596.forwardRef)((props29, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getControlProps(), props29);
  return (0, import_jsx_runtime275.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchControl.displayName = "SwitchControl";

// node_modules/@ark-ui/react/dist/components/switch/switch-hidden-input.js
var import_jsx_runtime276 = __toESM(require_jsx_runtime(), 1);
var import_react598 = __toESM(require_react(), 1);
var SwitchHiddenInput = (0, import_react598.forwardRef)(
  (props29, ref2) => {
    const switchContext = useSwitchContext();
    const mergedProps = mergeProps(switchContext.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime276.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
SwitchHiddenInput.displayName = "SwitchHiddenInput";

// node_modules/@ark-ui/react/dist/components/switch/switch-label.js
var import_jsx_runtime277 = __toESM(require_jsx_runtime(), 1);
var import_react600 = __toESM(require_react(), 1);
var SwitchLabel = (0, import_react600.forwardRef)((props29, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getLabelProps(), props29);
  return (0, import_jsx_runtime277.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchLabel.displayName = "SwitchLabel";

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var import_jsx_runtime278 = __toESM(require_jsx_runtime(), 1);
var import_react604 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/switch/use-switch.js
var import_react602 = __toESM(require_react(), 1);
var useSwitch = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react602.useId)(),
    dir,
    getRootNode: getRootNode2,
    checked: props29.defaultChecked,
    ...props29
  };
  const context = {
    ...initialContext,
    checked: props29.checked,
    onCheckedChange: useEvent(props29.onCheckedChange, { sync: true })
  };
  const [state2, send] = useMachine(machine27(initialContext), { context });
  return connect27(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/switch/switch-root.js
var SwitchRoot = (0, import_react604.forwardRef)((props29, ref2) => {
  const [switchProps, localProps] = createSplitProps2()(props29, [
    "checked",
    "defaultChecked",
    "disabled",
    "form",
    "id",
    "ids",
    "invalid",
    "label",
    "name",
    "onCheckedChange",
    "readOnly",
    "required",
    "value"
  ]);
  const switchContext = useSwitch(switchProps);
  const mergedProps = mergeProps(switchContext.getRootProps(), localProps);
  return (0, import_jsx_runtime278.jsx)(SwitchProvider, { value: switchContext, children: (0, import_jsx_runtime278.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
});
SwitchRoot.displayName = "SwitchRoot";

// node_modules/@ark-ui/react/dist/components/switch/switch-root-provider.js
var import_jsx_runtime279 = __toESM(require_jsx_runtime(), 1);
var import_react606 = __toESM(require_react(), 1);
var SwitchRootProvider = (0, import_react606.forwardRef)(
  (props29, ref2) => {
    const [{ value: api }, localProps] = createSplitProps2()(props29, ["value"]);
    const mergedProps = mergeProps(api.getRootProps(), localProps);
    return (0, import_jsx_runtime279.jsx)(SwitchProvider, { value: api, children: (0, import_jsx_runtime279.jsx)(ark.label, { ...mergedProps, ref: ref2 }) });
  }
);
SwitchRootProvider.displayName = "SwitchRootProvider";

// node_modules/@ark-ui/react/dist/components/switch/switch-thumb.js
var import_jsx_runtime280 = __toESM(require_jsx_runtime(), 1);
var import_react608 = __toESM(require_react(), 1);
var SwitchThumb = (0, import_react608.forwardRef)((props29, ref2) => {
  const switchContext = useSwitchContext();
  const mergedProps = mergeProps(switchContext.getThumbProps(), props29);
  return (0, import_jsx_runtime280.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
SwitchThumb.displayName = "SwitchThumb";

// node_modules/@ark-ui/react/dist/components/switch/switch.js
var switch_exports = {};
__export(switch_exports, {
  Context: () => SwitchContext,
  Control: () => SwitchControl,
  HiddenInput: () => SwitchHiddenInput,
  Label: () => SwitchLabel,
  Root: () => SwitchRoot,
  RootProvider: () => SwitchRootProvider,
  Thumb: () => SwitchThumb
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var import_jsx_runtime281 = __toESM(require_jsx_runtime(), 1);
var import_react610 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs-context.js
var [TabsProvider, useTabsContext] = createContext({
  name: "TabsContext",
  hookName: "useTabsContext",
  providerName: "<TabsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tabs/tab-content.js
var TabContent = (0, import_react610.forwardRef)((props29, ref2) => {
  const [contentProps2, localProps] = createSplitProps2()(props29, ["value"]);
  const tabs = useTabsContext();
  const renderStrategyProps = useRenderStrategyPropsContext();
  const presence = usePresence({
    ...renderStrategyProps,
    present: tabs.value === props29.value,
    immediate: true
  });
  const mergedProps = mergeProps(
    tabs.getContentProps(contentProps2),
    presence.getPresenceProps(ref2),
    localProps
  );
  return (0, import_jsx_runtime281.jsx)(PresenceProvider, { value: presence, children: presence.unmounted ? null : (0, import_jsx_runtime281.jsx)(ark.div, { ...mergedProps }) });
});
TabContent.displayName = "TabContent";

// node_modules/@ark-ui/react/dist/components/tabs/tab-indicator.js
var import_jsx_runtime282 = __toESM(require_jsx_runtime(), 1);
var import_react612 = __toESM(require_react(), 1);
var TabIndicator = (0, import_react612.forwardRef)((props29, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getIndicatorProps(), props29);
  return (0, import_jsx_runtime282.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TabIndicator.displayName = "TabIndicator";

// node_modules/@ark-ui/react/dist/components/tabs/tab-list.js
var import_jsx_runtime283 = __toESM(require_jsx_runtime(), 1);
var import_react614 = __toESM(require_react(), 1);
var TabList = (0, import_react614.forwardRef)((props29, ref2) => {
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getListProps(), props29);
  return (0, import_jsx_runtime283.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TabList.displayName = "TabList";

// node_modules/@ark-ui/react/dist/components/tabs/tab-trigger.js
var import_jsx_runtime284 = __toESM(require_jsx_runtime(), 1);
var import_react616 = __toESM(require_react(), 1);
var TabTrigger = (0, import_react616.forwardRef)((props29, ref2) => {
  const [tabProps, localProps] = createSplitProps2()(props29, ["disabled", "value"]);
  const tabs = useTabsContext();
  const mergedProps = mergeProps(tabs.getTriggerProps(tabProps), localProps);
  return (0, import_jsx_runtime284.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TabTrigger.displayName = "TabTrigger";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-context.js
var TabsContext = (props29) => props29.children(useTabsContext());

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var import_jsx_runtime285 = __toESM(require_jsx_runtime(), 1);
var import_react620 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tabs/use-tabs.js
var import_react618 = __toESM(require_react(), 1);
var useTabs = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react618.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onFocusChange: useEvent(props29.onFocusChange)
  };
  const [state2, send] = useMachine(machine28(initialContext), { context });
  return connect28(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root.js
var TabsRoot = (0, import_react620.forwardRef)((props29, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props29);
  const [useTabsProps, localprops] = createSplitProps2()(tabsProps, [
    "activationMode",
    "composite",
    "defaultValue",
    "id",
    "ids",
    "loopFocus",
    "onFocusChange",
    "onValueChange",
    "orientation",
    "translations",
    "value"
  ]);
  const tabs = useTabs(useTabsProps);
  const mergedProps = mergeProps(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime285.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime285.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime285.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRoot.displayName = "TabsRoot";

// node_modules/@ark-ui/react/dist/components/tabs/tabs-root-provider.js
var import_jsx_runtime286 = __toESM(require_jsx_runtime(), 1);
var import_react622 = __toESM(require_react(), 1);
var TabsRootProvider = (0, import_react622.forwardRef)((props29, ref2) => {
  const [renderStrategyProps, tabsProps] = splitRenderStrategyProps(props29);
  const [{ value: tabs }, localprops] = createSplitProps2()(tabsProps, ["value"]);
  const mergedProps = mergeProps(tabs.getRootProps(), localprops);
  return (0, import_jsx_runtime286.jsx)(TabsProvider, { value: tabs, children: (0, import_jsx_runtime286.jsx)(RenderStrategyPropsProvider, { value: renderStrategyProps, children: (0, import_jsx_runtime286.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TabsRootProvider.displayName = "TabsRootProvider";

// node_modules/@ark-ui/react/dist/components/tabs/tabs.js
var tabs_exports = {};
__export(tabs_exports, {
  Content: () => TabContent,
  Context: () => TabsContext,
  Indicator: () => TabIndicator,
  List: () => TabList,
  Root: () => TabsRoot,
  RootProvider: () => TabsRootProvider,
  Trigger: () => TabTrigger
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-clear-trigger.js
var import_jsx_runtime287 = __toESM(require_jsx_runtime(), 1);
var import_react624 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-context.js
var [TagsInputProvider, useTagsInputContext] = createContext({
  name: "TagsInputContext",
  hookName: "useTagsInputContext",
  providerName: "<TagsInputProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-clear-trigger.js
var TagsInputClearTrigger = (0, import_react624.forwardRef)(
  (props29, ref2) => {
    const tagsInput = useTagsInputContext();
    const mergedProps = mergeProps(tagsInput.getClearTriggerProps(), props29);
    return (0, import_jsx_runtime287.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
TagsInputClearTrigger.displayName = "TagsInputClearTrigger";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-context.js
var TagsInputContext = (props29) => props29.children(useTagsInputContext());

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-control.js
var import_jsx_runtime288 = __toESM(require_jsx_runtime(), 1);
var import_react626 = __toESM(require_react(), 1);
var TagsInputControl = (0, import_react626.forwardRef)((props29, ref2) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps(tagsInput.getControlProps(), props29);
  return (0, import_jsx_runtime288.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TagsInputControl.displayName = "TagsInputControl";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-hidden-input.js
var import_jsx_runtime289 = __toESM(require_jsx_runtime(), 1);
var import_react628 = __toESM(require_react(), 1);
var TagsInputHiddenInput = (0, import_react628.forwardRef)(
  (props29, ref2) => {
    const tagsInput = useTagsInputContext();
    const mergedProps = mergeProps(tagsInput.getHiddenInputProps(), props29);
    return (0, import_jsx_runtime289.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
TagsInputHiddenInput.displayName = "TagsInputHiddenInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-input.js
var import_jsx_runtime290 = __toESM(require_jsx_runtime(), 1);
var import_react630 = __toESM(require_react(), 1);
var TagsInputInput = (0, import_react630.forwardRef)((props29, ref2) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps(tagsInput.getInputProps(), props29);
  return (0, import_jsx_runtime290.jsx)(ark.input, { ...mergedProps, ref: ref2 });
});
TagsInputInput.displayName = "TagsInputInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item.js
var import_jsx_runtime291 = __toESM(require_jsx_runtime(), 1);
var import_react632 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-item-context.js
var [TagsInputItemProvider, useTagsInputItemContext] = createContext({
  name: "TagsInputItemContext",
  hookName: "useTagsInputItemContext",
  providerName: "<TagsInputItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input-item-props-context.js
var [TagsInputItemPropsProvider, useTagsInputItemPropsContext] = createContext({
  name: "TagsInputItemPropsContext",
  hookName: "useTagsInputItemPropsContext",
  providerName: "<TagsInputItemPropsProvider />"
});

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item.js
var TagsInputItem = (0, import_react632.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, [
    "index",
    "disabled",
    "value"
  ]);
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps(tagsInput.getItemProps(itemProps10), localProps);
  const tagsInputItem = tagsInput.getItemState(itemProps10);
  return (0, import_jsx_runtime291.jsx)(TagsInputItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime291.jsx)(TagsInputItemProvider, { value: tagsInputItem, children: (0, import_jsx_runtime291.jsx)(ark.div, { ...mergedProps, ref: ref2 }) }) });
});
TagsInputItem.displayName = "TagsInputItem";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-context.js
var TagsInputItemContext = (props29) => props29.children(useTagsInputItemContext());

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-delete-trigger.js
var import_jsx_runtime292 = __toESM(require_jsx_runtime(), 1);
var import_react634 = __toESM(require_react(), 1);
var TagsInputItemDeleteTrigger = (0, import_react634.forwardRef)((props29, ref2) => {
  const tagsInput = useTagsInputContext();
  const itemProps10 = useTagsInputItemPropsContext();
  const mergedProps = mergeProps(tagsInput.getItemDeleteTriggerProps(itemProps10), props29);
  return (0, import_jsx_runtime292.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TagsInputItemDeleteTrigger.displayName = "TagsInputItemDeleteTrigger";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-input.js
var import_jsx_runtime293 = __toESM(require_jsx_runtime(), 1);
var import_react636 = __toESM(require_react(), 1);
var TagsInputItemInput = (0, import_react636.forwardRef)(
  (props29, ref2) => {
    const tagsInput = useTagsInputContext();
    const itemProps10 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps(tagsInput.getItemInputProps(itemProps10), props29);
    return (0, import_jsx_runtime293.jsx)(ark.input, { ...mergedProps, ref: ref2 });
  }
);
TagsInputItemInput.displayName = "TagsInputItemInput";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-preview.js
var import_jsx_runtime294 = __toESM(require_jsx_runtime(), 1);
var import_react638 = __toESM(require_react(), 1);
var TagsInputItemPreview = (0, import_react638.forwardRef)(
  (props29, ref2) => {
    const tagsInput = useTagsInputContext();
    const itemProps10 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps(tagsInput.getItemPreviewProps(itemProps10), props29);
    return (0, import_jsx_runtime294.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TagsInputItemPreview.displayName = "TagsInputItemPreview";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-item-text.js
var import_jsx_runtime295 = __toESM(require_jsx_runtime(), 1);
var import_react640 = __toESM(require_react(), 1);
var TagsInputItemText = (0, import_react640.forwardRef)(
  (props29, ref2) => {
    const tagsInput = useTagsInputContext();
    const itemProps10 = useTagsInputItemPropsContext();
    const mergedProps = mergeProps(tagsInput.getItemTextProps(itemProps10), props29);
    return (0, import_jsx_runtime295.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
TagsInputItemText.displayName = "TagsInputItemText";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-label.js
var import_jsx_runtime296 = __toESM(require_jsx_runtime(), 1);
var import_react642 = __toESM(require_react(), 1);
var TagsInputLabel = (0, import_react642.forwardRef)((props29, ref2) => {
  const tagsInput = useTagsInputContext();
  const mergedProps = mergeProps(tagsInput.getLabelProps(), props29);
  return (0, import_jsx_runtime296.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
TagsInputLabel.displayName = "TagsInputLabel";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root.js
var import_jsx_runtime297 = __toESM(require_jsx_runtime(), 1);
var import_react646 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tags-input/use-tags-input.js
var import_react644 = __toESM(require_react(), 1);
var useTagsInput = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react644.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true }),
    onValueInvalid: useEvent(props29.onValueInvalid),
    onHighlightChange: useEvent(props29.onHighlightChange)
  };
  const [state2, send] = useMachine(machine29(initialContext), { context });
  return connect29(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root.js
var TagsInputRoot = (0, import_react646.forwardRef)((props29, ref2) => {
  const [useTagsInputProps, localProps] = createSplitProps2()(props29, [
    "addOnPaste",
    "allowOverflow",
    "autoFocus",
    "blurBehavior",
    "defaultValue",
    "delimiter",
    "disabled",
    "editable",
    "form",
    "id",
    "ids",
    "inputValue",
    "invalid",
    "max",
    "maxLength",
    "name",
    "onFocusOutside",
    "onHighlightChange",
    "onInputValueChange",
    "onInteractOutside",
    "onPointerDownOutside",
    "onValueChange",
    "onValueInvalid",
    "readOnly",
    "translations",
    "validate",
    "value"
  ]);
  const tagsInput = useTagsInput(useTagsInputProps);
  const mergedProps = mergeProps(tagsInput.getRootProps(), localProps);
  return (0, import_jsx_runtime297.jsx)(TagsInputProvider, { value: tagsInput, children: (0, import_jsx_runtime297.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
TagsInputRoot.displayName = "TagsInputRoot";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input-root-provider.js
var import_jsx_runtime298 = __toESM(require_jsx_runtime(), 1);
var import_react648 = __toESM(require_react(), 1);
var TagsInputRootProvider = (0, import_react648.forwardRef)(
  (props29, ref2) => {
    const [{ value: tagsInput }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(tagsInput.getRootProps(), localProps);
    return (0, import_jsx_runtime298.jsx)(TagsInputProvider, { value: tagsInput, children: (0, import_jsx_runtime298.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
TagsInputRootProvider.displayName = "TagsInputRootProvider";

// node_modules/@ark-ui/react/dist/components/tags-input/tags-input.js
var tags_input_exports = {};
__export(tags_input_exports, {
  ClearTrigger: () => TagsInputClearTrigger,
  Context: () => TagsInputContext,
  Control: () => TagsInputControl,
  HiddenInput: () => TagsInputHiddenInput,
  Input: () => TagsInputInput,
  Item: () => TagsInputItem,
  ItemContext: () => TagsInputItemContext,
  ItemDeleteTrigger: () => TagsInputItemDeleteTrigger,
  ItemInput: () => TagsInputItemInput,
  ItemPreview: () => TagsInputItemPreview,
  ItemText: () => TagsInputItemText,
  Label: () => TagsInputLabel,
  Root: () => TagsInputRoot,
  RootProvider: () => TagsInputRootProvider
});

// node_modules/@ark-ui/react/dist/components/toast/create-toaster.js
var createToaster = (props29) => {
  const machine34 = group.machine({ id: "1", ...props29 });
  const api = group.connect(machine34, machine34.send, normalizeProps);
  return { ...api, machine: machine34 };
};

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var import_jsx_runtime299 = __toESM(require_jsx_runtime(), 1);
var import_react651 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toast/use-toast-context.js
var [ToastProvider, useToastContext] = createContext({
  name: "ToastContext",
  hookName: "useToastContext",
  providerName: "<ToastProvider />"
});

// node_modules/@ark-ui/react/dist/components/toast/toast-action-trigger.js
var ToastActionTrigger = (0, import_react651.forwardRef)(
  (props29, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps(toast.getActionTriggerProps(), props29);
    return (0, import_jsx_runtime299.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastActionTrigger.displayName = "ToastActionTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-close-trigger.js
var import_jsx_runtime300 = __toESM(require_jsx_runtime(), 1);
var import_react653 = __toESM(require_react(), 1);
var ToastCloseTrigger = (0, import_react653.forwardRef)(
  (props29, ref2) => {
    const toast = useToastContext();
    const mergedProps = mergeProps(toast.getCloseTriggerProps(), props29);
    return (0, import_jsx_runtime300.jsx)(ark.button, { ...mergedProps, ref: ref2 });
  }
);
ToastCloseTrigger.displayName = "ToastCloseTrigger";

// node_modules/@ark-ui/react/dist/components/toast/toast-context.js
var ToastContext = (props29) => props29.children(useToastContext());

// node_modules/@ark-ui/react/dist/components/toast/toast-description.js
var import_jsx_runtime301 = __toESM(require_jsx_runtime(), 1);
var import_react655 = __toESM(require_react(), 1);
var ToastDescription = (0, import_react655.forwardRef)((props29, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getDescriptionProps(), props29);
  return (0, import_jsx_runtime301.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ToastDescription.displayName = "ToastDescription";

// node_modules/@ark-ui/react/dist/components/toast/toast-root.js
var import_jsx_runtime302 = __toESM(require_jsx_runtime(), 1);
var import_react657 = __toESM(require_react(), 1);
var ToastRoot = (0, import_react657.forwardRef)((props29, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getRootProps(), props29);
  return (0, import_jsx_runtime302.jsxs)("div", { ...mergedProps, ref: ref2, children: [
    (0, import_jsx_runtime302.jsx)("div", { ...toast.getGhostBeforeProps() }),
    props29.children,
    (0, import_jsx_runtime302.jsx)("div", { ...toast.getGhostAfterProps() })
  ] });
});
ToastRoot.displayName = "ToastRoot";

// node_modules/@ark-ui/react/dist/components/toast/toast-title.js
var import_jsx_runtime303 = __toESM(require_jsx_runtime(), 1);
var import_react659 = __toESM(require_react(), 1);
var ToastTitle = (0, import_react659.forwardRef)((props29, ref2) => {
  const toast = useToastContext();
  const mergedProps = mergeProps(toast.getTitleProps(), props29);
  return (0, import_jsx_runtime303.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
ToastTitle.displayName = "ToastTitle";

// node_modules/@ark-ui/react/dist/components/toast/toaster.js
var import_jsx_runtime304 = __toESM(require_jsx_runtime(), 1);
var import_react661 = __toESM(require_react(), 1);
var Toaster = (0, import_react661.forwardRef)((props29, ref2) => {
  const { toaster, children, ...rest } = props29;
  const [state2, send] = useMachine(toaster.machine);
  const placement = state2.context.placement;
  const api = group.connect(state2, send, normalizeProps);
  const toasts = api.getToastsByPlacement(placement);
  const mergedProps = mergeProps(api.getGroupProps({ placement }), rest);
  return (0, import_jsx_runtime304.jsx)(ark.div, { ...mergedProps, ref: ref2, children: toasts.map((toast2) => (0, import_jsx_runtime304.jsx)(ToastActor, { value: toast2, children: (ctx) => children(ctx) }, toast2.id)) });
});
Toaster.displayName = "Toaster";
var ToastActor = (props29) => {
  const [state2, send] = useActor(props29.value);
  const api = connect30(state2, send, normalizeProps);
  return (0, import_jsx_runtime304.jsx)(ToastProvider, { value: api, children: props29.children(state2.context) });
};

// node_modules/@ark-ui/react/dist/components/toast/toast.js
var toast_exports = {};
__export(toast_exports, {
  ActionTrigger: () => ToastActionTrigger,
  CloseTrigger: () => ToastCloseTrigger,
  Context: () => ToastContext,
  Description: () => ToastDescription,
  Root: () => ToastRoot,
  Title: () => ToastTitle
});

// node_modules/@ark-ui/react/dist/components/toggle-group/use-toggle-group-context.js
var [ToggleGroupProvider, useToggleGroupContext] = createContext({
  name: "ToggleGroupContext",
  hookName: "useToggleGroupContext",
  providerName: "<ToggleGroupProvider />"
});

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-context.js
var ToggleGroupContext = (props29) => props29.children(useToggleGroupContext());

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-item.js
var import_jsx_runtime305 = __toESM(require_jsx_runtime(), 1);
var import_react663 = __toESM(require_react(), 1);
var ToggleGroupItem = (0, import_react663.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["value", "disabled"]);
  const toggleGroup = useToggleGroupContext();
  const mergedProps = mergeProps(toggleGroup.getItemProps(itemProps10), localProps);
  return (0, import_jsx_runtime305.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
ToggleGroupItem.displayName = "ToggleGroupItem";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root.js
var import_jsx_runtime306 = __toESM(require_jsx_runtime(), 1);
var import_react667 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/toggle-group/use-toggle-group.js
var import_react665 = __toESM(require_react(), 1);
var useToggleGroup = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react665.useId)(),
    dir,
    getRootNode: getRootNode2,
    value: props29.defaultValue,
    ...props29
  };
  const context = {
    ...initialContext,
    value: props29.value,
    onValueChange: useEvent(props29.onValueChange, { sync: true })
  };
  const [state2, send] = useMachine(machine30(initialContext), {
    context
  });
  return connect31(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root.js
var ToggleGroupRoot = (0, import_react667.forwardRef)((props29, ref2) => {
  const [useToggleGroupProps, localProps] = createSplitProps2()(props29, [
    "defaultValue",
    "disabled",
    "id",
    "ids",
    "loopFocus",
    "multiple",
    "onValueChange",
    "orientation",
    "rovingFocus",
    "value"
  ]);
  const togglegroup = useToggleGroup(useToggleGroupProps);
  const mergedProps = mergeProps(togglegroup.getRootProps(), localProps);
  return (0, import_jsx_runtime306.jsx)(ToggleGroupProvider, { value: togglegroup, children: (0, import_jsx_runtime306.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
ToggleGroupRoot.displayName = "ToggleGroupRoot";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group-root-provider.js
var import_jsx_runtime307 = __toESM(require_jsx_runtime(), 1);
var import_react669 = __toESM(require_react(), 1);
var ToggleGroupRootProvider = (0, import_react669.forwardRef)(
  (props29, ref2) => {
    const [{ value: toggleGroup }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(toggleGroup.getRootProps(), localProps);
    return (0, import_jsx_runtime307.jsx)(ToggleGroupProvider, { value: toggleGroup, children: (0, import_jsx_runtime307.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
ToggleGroupRootProvider.displayName = "ToggleGroupRootProvider";

// node_modules/@ark-ui/react/dist/components/toggle-group/toggle-group.js
var toggle_group_exports = {};
__export(toggle_group_exports, {
  Context: () => ToggleGroupContext,
  Item: () => ToggleGroupItem,
  Root: () => ToggleGroupRoot
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var import_jsx_runtime308 = __toESM(require_jsx_runtime(), 1);
var import_react671 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip-context.js
var [TooltipProvider, useTooltipContext] = createContext({
  name: "TooltipContext",
  hookName: "useTooltipContext",
  providerName: "<TooltipProvider />"
});

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow.js
var TooltipArrow = (0, import_react671.forwardRef)((props29, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowProps(), props29);
  return (0, import_jsx_runtime308.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrow.displayName = "TooltipArrow";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-arrow-tip.js
var import_jsx_runtime309 = __toESM(require_jsx_runtime(), 1);
var import_react673 = __toESM(require_react(), 1);
var TooltipArrowTip = (0, import_react673.forwardRef)((props29, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getArrowTipProps(), props29);
  return (0, import_jsx_runtime309.jsx)(ark.div, { ...mergedProps, ref: ref2 });
});
TooltipArrowTip.displayName = "TooltipArrowTip";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-content.js
var import_jsx_runtime310 = __toESM(require_jsx_runtime(), 1);
var import_react675 = __toESM(require_react(), 1);
var TooltipContent = (0, import_react675.forwardRef)((props29, ref2) => {
  const tooltip = useTooltipContext();
  const presence = usePresenceContext();
  const mergedProps = mergeProps(tooltip.getContentProps(), presence.getPresenceProps(ref2), props29);
  if (presence.unmounted) {
    return null;
  }
  return (0, import_jsx_runtime310.jsx)(ark.div, { ...mergedProps });
});
TooltipContent.displayName = "TooltipContent";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-context.js
var TooltipContext = (props29) => props29.children(useTooltipContext());

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-positioner.js
var import_jsx_runtime311 = __toESM(require_jsx_runtime(), 1);
var import_react677 = __toESM(require_react(), 1);
var TooltipPositioner = (0, import_react677.forwardRef)(
  (props29, ref2) => {
    const tooltip = useTooltipContext();
    const mergedProps = mergeProps(tooltip.getPositionerProps(), props29);
    const presence = usePresenceContext();
    if (presence.unmounted) {
      return null;
    }
    return (0, import_jsx_runtime311.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TooltipPositioner.displayName = "TooltipPositioner";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var import_jsx_runtime312 = __toESM(require_jsx_runtime(), 1);

// node_modules/@ark-ui/react/dist/components/tooltip/use-tooltip.js
var import_react679 = __toESM(require_react(), 1);
var useTooltip = (props29) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react679.useId)(),
    dir,
    getRootNode: getRootNode2,
    open: props29.defaultOpen,
    "open.controlled": props29.open !== void 0,
    ...props29
  };
  const context = {
    ...initialContext,
    onOpenChange: useEvent(props29.onOpenChange, { sync: true })
  };
  const [state2, send] = useMachine(machine31(initialContext), { context });
  return connect32(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root.js
var TooltipRoot = (props29) => {
  const [presenceProps, { children, ...localProps }] = splitPresenceProps(props29);
  const tooltip = useTooltip(localProps);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime312.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime312.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-root-provider.js
var import_jsx_runtime313 = __toESM(require_jsx_runtime(), 1);
var TooltipRootProvider = (props29) => {
  const [presenceProps, { value: tooltip, children }] = splitPresenceProps(props29);
  const presence = usePresence(mergeProps({ present: tooltip.open }, presenceProps));
  return (0, import_jsx_runtime313.jsx)(TooltipProvider, { value: tooltip, children: (0, import_jsx_runtime313.jsx)(PresenceProvider, { value: presence, children }) });
};

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip-trigger.js
var import_jsx_runtime314 = __toESM(require_jsx_runtime(), 1);
var import_react683 = __toESM(require_react(), 1);
var TooltipTrigger = (0, import_react683.forwardRef)((props29, ref2) => {
  const tooltip = useTooltipContext();
  const mergedProps = mergeProps(tooltip.getTriggerProps(), props29);
  return (0, import_jsx_runtime314.jsx)(ark.button, { ...mergedProps, ref: ref2 });
});
TooltipTrigger.displayName = "TooltipTrigger";

// node_modules/@ark-ui/react/dist/components/tooltip/tooltip.js
var tooltip_exports = {};
__export(tooltip_exports, {
  Arrow: () => TooltipArrow,
  ArrowTip: () => TooltipArrowTip,
  Content: () => TooltipContent,
  Context: () => TooltipContext,
  Positioner: () => TooltipPositioner,
  Root: () => TooltipRoot,
  RootProvider: () => TooltipRootProvider,
  Trigger: () => TooltipTrigger
});

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch.js
var import_jsx_runtime315 = __toESM(require_jsx_runtime(), 1);
var import_react685 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-branch-context.js
var [TreeViewBranchProvider, useTreeViewBranchContext] = createContext({
  name: "TreeViewBranchContext",
  hookName: "useTreeViewBranchContext",
  providerName: "<TreeViewBranchProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-context.js
var [TreeViewProvider, useTreeViewContext] = createContext({
  name: "TreeViewContext",
  hookName: "useTreeViewContext",
  providerName: "<TreeViewProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-depth-context.js
var [TreeViewDepthProvider, useTreeViewDepthContext] = createContext({
  name: "TreeViewDepthContext",
  hookName: "useTreeViewDepthContext",
  providerName: "<TreeViewDepthProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch.js
var TreeViewBranch = (0, import_react685.forwardRef)((props29, ref2) => {
  const [itemProps10, localProps] = createSplitProps2()(props29, ["disabled", "value"]);
  const treeView = useTreeViewContext();
  const depth = useTreeViewDepthContext();
  const branchContext = { ...itemProps10, depth };
  const mergedProps = mergeProps(treeView.getBranchProps(branchContext), localProps);
  return (0, import_jsx_runtime315.jsx)(TreeViewDepthProvider, { value: depth + 1, children: (0, import_jsx_runtime315.jsx)(TreeViewBranchProvider, { value: branchContext, children: (0, import_jsx_runtime315.jsx)(ark.li, { ...mergedProps, ref: ref2 }) }) });
});
TreeViewBranch.displayName = "TreeViewBranch";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-content.js
var import_jsx_runtime316 = __toESM(require_jsx_runtime(), 1);
var import_react687 = __toESM(require_react(), 1);
var TreeViewBranchContent = (0, import_react687.forwardRef)(
  (props29, ref2) => {
    const treeView = useTreeViewContext();
    const branchContext = useTreeViewBranchContext();
    const mergedProps = mergeProps(treeView.getBranchContentProps(branchContext), props29);
    return (0, import_jsx_runtime316.jsx)(ark.ul, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchContent.displayName = "TreeViewBranchContent";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-control.js
var import_jsx_runtime317 = __toESM(require_jsx_runtime(), 1);
var import_react689 = __toESM(require_react(), 1);
var TreeViewBranchControl = (0, import_react689.forwardRef)(
  (props29, ref2) => {
    const treeView = useTreeViewContext();
    const branchContext = useTreeViewBranchContext();
    const mergedProps = mergeProps(treeView.getBranchControlProps(branchContext), props29);
    return (0, import_jsx_runtime317.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchControl.displayName = "TreeViewBranchControl";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-indicator.js
var import_jsx_runtime318 = __toESM(require_jsx_runtime(), 1);
var import_react691 = __toESM(require_react(), 1);
var TreeViewBranchIndicator = (0, import_react691.forwardRef)(
  (props29, ref2) => {
    const treeView = useTreeViewContext();
    const branchContext = useTreeViewBranchContext();
    const mergedProps = mergeProps(treeView.getBranchIndicatorProps(branchContext), props29);
    return (0, import_jsx_runtime318.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchIndicator.displayName = "TreeViewBranchIndicator";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-text.js
var import_jsx_runtime319 = __toESM(require_jsx_runtime(), 1);
var import_react693 = __toESM(require_react(), 1);
var TreeViewBranchText = (0, import_react693.forwardRef)(
  (props29, ref2) => {
    const treeView = useTreeViewContext();
    const branchContext = useTreeViewBranchContext();
    const mergedProps = mergeProps(treeView.getBranchTextProps(branchContext), props29);
    return (0, import_jsx_runtime319.jsx)(ark.span, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchText.displayName = "TreeViewBranchText";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-branch-trigger.js
var import_jsx_runtime320 = __toESM(require_jsx_runtime(), 1);
var import_react695 = __toESM(require_react(), 1);
var TreeViewBranchTrigger = (0, import_react695.forwardRef)(
  (props29, ref2) => {
    const treeView = useTreeViewContext();
    const branchContext = useTreeViewBranchContext();
    const mergedProps = mergeProps(treeView.getBranchTriggerProps(branchContext), props29);
    return (0, import_jsx_runtime320.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewBranchTrigger.displayName = "TreeViewBranchTrigger";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-context.js
var TreeViewContext = (props29) => props29.children(useTreeViewContext());

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item.js
var import_jsx_runtime321 = __toESM(require_jsx_runtime(), 1);
var import_react697 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-item-context.js
var [TreeViewItemProvider, useTreeViewItemContext] = createContext(
  {
    name: "TreeViewItemContext",
    hookName: "useTreeViewItemContext",
    providerName: "<TreeViewItemProvider />"
  }
);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view-item-props-context.js
var [TreeViewItemPropsProvider, useTreeViewItemPropsContext] = createContext({
  name: "TreeViewItemPropsContext",
  hookName: "useTreeViewItemPropsContext",
  providerName: "<TreeViewItemProvider />"
});

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item.js
var TreeViewItem = (0, import_react697.forwardRef)((props29, ref2) => {
  const [{ value, disabled }, localProps] = createSplitProps2()(props29, [
    "disabled",
    "value"
  ]);
  const treeView = useTreeViewContext();
  const depth = useTreeViewDepthContext();
  const itemProps10 = { value, disabled, depth };
  const mergedProps = mergeProps(treeView.getItemProps(itemProps10), localProps);
  const itemState = treeView.getItemState(itemProps10);
  return (0, import_jsx_runtime321.jsx)(TreeViewItemPropsProvider, { value: itemProps10, children: (0, import_jsx_runtime321.jsx)(TreeViewItemProvider, { value: itemState, children: (0, import_jsx_runtime321.jsx)(ark.li, { ...mergedProps, ref: ref2 }) }) });
});
TreeViewItem.displayName = "TreeViewItem";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-context.js
var TreeViewItemContext = (props29) => props29.children(useTreeViewItemContext());

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-indicator.js
var import_jsx_runtime322 = __toESM(require_jsx_runtime(), 1);
var import_react699 = __toESM(require_react(), 1);
var TreeViewItemIndicator = (0, import_react699.forwardRef)(
  (props29, ref2) => {
    const treeView = useTreeViewContext();
    const itemProps10 = useTreeViewItemPropsContext();
    const mergedProps = mergeProps(treeView.getItemIndicatorProps(itemProps10), props29);
    return (0, import_jsx_runtime322.jsx)(ark.div, { ...mergedProps, ref: ref2 });
  }
);
TreeViewItemIndicator.displayName = "TreeViewItemIndicator";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-item-text.js
var import_jsx_runtime323 = __toESM(require_jsx_runtime(), 1);
var import_react701 = __toESM(require_react(), 1);
var TreeViewItemText = (0, import_react701.forwardRef)((props29, ref2) => {
  const treeView = useTreeViewContext();
  const itemProps10 = useTreeViewItemPropsContext();
  const mergedProps = mergeProps(treeView.getItemTextProps(itemProps10), props29);
  return (0, import_jsx_runtime323.jsx)(ark.span, { ...mergedProps, ref: ref2 });
});
TreeViewItemText.displayName = "TreeViewItemText";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-label.js
var import_jsx_runtime324 = __toESM(require_jsx_runtime(), 1);
var import_react703 = __toESM(require_react(), 1);
var TreeViewLabel = (0, import_react703.forwardRef)((props29, ref2) => {
  const treeView = useTreeViewContext();
  const mergedProps = mergeProps(treeView.getLabelProps(), props29);
  return (0, import_jsx_runtime324.jsx)(ark.label, { ...mergedProps, ref: ref2 });
});
TreeViewLabel.displayName = "TreeViewLabel";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root.js
var import_jsx_runtime325 = __toESM(require_jsx_runtime(), 1);
var import_react707 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/components/tree-view/use-tree-view.js
var import_react705 = __toESM(require_react(), 1);
var useTreeView = (props29 = {}) => {
  const { getRootNode: getRootNode2 } = useEnvironmentContext();
  const { dir } = useLocaleContext();
  const initialContext = {
    id: (0, import_react705.useId)(),
    dir,
    getRootNode: getRootNode2,
    selectedValue: props29.defaultSelectedValue,
    expandedValue: props29.defaultExpandedValue,
    ...props29
  };
  const context = {
    ...initialContext,
    selectedValue: props29.selectedValue,
    expandedValue: props29.expandedValue,
    onFocusChange: useEvent(props29.onFocusChange, { sync: true }),
    onExpandedChange: useEvent(props29.onExpandedChange),
    onSelectionChange: useEvent(props29.onSelectionChange)
  };
  const [state2, send] = useMachine(machine32(initialContext), { context });
  return connect33(state2, send, normalizeProps);
};

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root.js
var TreeViewRoot = (0, import_react707.forwardRef)((props29, ref2) => {
  const [useTreeViewProps, localProps] = createSplitProps2()(props29, [
    "defaultExpandedValue",
    "defaultSelectedValue",
    "expandedValue",
    "expandOnClick",
    "focusedValue",
    "id",
    "ids",
    "onExpandedChange",
    "onFocusChange",
    "onSelectionChange",
    "selectedValue",
    "selectionMode",
    "typeahead"
  ]);
  const treeView = useTreeView(useTreeViewProps);
  const mergedProps = mergeProps(treeView.getRootProps(), localProps);
  return (0, import_jsx_runtime325.jsx)(TreeViewProvider, { value: treeView, children: (0, import_jsx_runtime325.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
});
TreeViewRoot.displayName = "TreeViewRoot";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-root-provider.js
var import_jsx_runtime326 = __toESM(require_jsx_runtime(), 1);
var import_react709 = __toESM(require_react(), 1);
var TreeViewRootProvider = (0, import_react709.forwardRef)(
  (props29, ref2) => {
    const [{ value: treeView }, localProps] = createSplitProps2()(props29, [
      "value"
    ]);
    const mergedProps = mergeProps(treeView.getRootProps(), localProps);
    return (0, import_jsx_runtime326.jsx)(TreeViewProvider, { value: treeView, children: (0, import_jsx_runtime326.jsx)(ark.div, { ...mergedProps, ref: ref2 }) });
  }
);
TreeViewRootProvider.displayName = "TreeViewRootProvider";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view-tree.js
var import_jsx_runtime327 = __toESM(require_jsx_runtime(), 1);
var import_react711 = __toESM(require_react(), 1);
var TreeViewTree = (0, import_react711.forwardRef)((props29, ref2) => {
  const treeView = useTreeViewContext();
  const mergedProps = mergeProps(treeView.getTreeProps(), props29);
  return (0, import_jsx_runtime327.jsx)(TreeViewDepthProvider, { value: 1, children: (0, import_jsx_runtime327.jsx)(ark.ul, { ...mergedProps, ref: ref2 }) });
});
TreeViewTree.displayName = "TreeViewTree";

// node_modules/@ark-ui/react/dist/components/tree-view/tree-view.js
var tree_view_exports = {};
__export(tree_view_exports, {
  Branch: () => TreeViewBranch,
  BranchContent: () => TreeViewBranchContent,
  BranchControl: () => TreeViewBranchControl,
  BranchIndicator: () => TreeViewBranchIndicator,
  BranchText: () => TreeViewBranchText,
  BranchTrigger: () => TreeViewBranchTrigger,
  Context: () => TreeViewContext,
  Item: () => TreeViewItem,
  ItemContext: () => TreeViewItemContext,
  ItemIndicator: () => TreeViewItemIndicator,
  ItemText: () => TreeViewItemText,
  Label: () => TreeViewLabel,
  Root: () => TreeViewRoot,
  RootProvider: () => TreeViewRootProvider,
  Tree: () => TreeViewTree
});

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var import_jsx_runtime328 = __toESM(require_jsx_runtime(), 1);
var import_react712 = __toESM(require_react(), 1);

// node_modules/@ark-ui/react/dist/utils/run-if-fn.js
var isFunction3 = (value) => typeof value === "function";
var runIfFn3 = (valueOrFn, ...args) => isFunction3(valueOrFn) ? valueOrFn(...args) : valueOrFn;

// node_modules/@ark-ui/react/dist/providers/environment/environment-provider.js
var EnvironmentProvider = (props29) => {
  const { value, children } = props29;
  const [spanRef, setSpanRef] = (0, import_react712.useState)();
  const getRootNode2 = (0, import_react712.useMemo)(() => {
    return () => runIfFn3(value) ?? (spanRef == null ? void 0 : spanRef.ownerDocument) ?? document;
  }, [value, spanRef]);
  const environment = (0, import_react712.useMemo)(
    () => ({
      getRootNode: getRootNode2,
      getWindow: () => getWindow(getRootNode2()),
      getDocument: () => getDocument(getRootNode2())
    }),
    [getRootNode2]
  );
  return (0, import_jsx_runtime328.jsxs)(EnvironmentContextProvider, { value: environment, children: [
    children,
    !value && (0, import_jsx_runtime328.jsx)("span", { hidden: true, ref: setSpanRef })
  ] });
};

// node_modules/@ark-ui/react/dist/providers/locale/locale-provider.js
var import_jsx_runtime329 = __toESM(require_jsx_runtime(), 1);
var LocaleProvider = (props29) => {
  const { children, locale } = props29;
  const context = {
    locale,
    dir: isRTL2(locale) ? "rtl" : "ltr"
  };
  return (0, import_jsx_runtime329.jsx)(LocaleContextProvider, { value: context, children });
};
export {
  accordion_exports as Accordion,
  AccordionContext,
  AccordionItem,
  AccordionItemContent,
  AccordionItemContext,
  AccordionItemIndicator,
  AccordionItemTrigger,
  AccordionRoot,
  AccordionRootProvider,
  avatar_exports as Avatar,
  AvatarContext,
  AvatarFallback,
  AvatarImage,
  AvatarRoot,
  AvatarRootProvider,
  carousel_exports as Carousel,
  CarouselContext,
  CarouselControl,
  CarouselIndicator,
  CarouselIndicatorGroup,
  CarouselItem,
  CarouselItemGroup,
  CarouselNextTrigger,
  CarouselPrevTrigger,
  CarouselRoot,
  CarouselRootProvider,
  CarouselViewport,
  checkbox_exports as Checkbox,
  CheckboxContext,
  CheckboxControl,
  CheckboxGroup,
  CheckboxHiddenInput,
  CheckboxIndicator,
  CheckboxLabel,
  CheckboxRoot,
  CheckboxRootProvider,
  clipboard_exports as Clipboard,
  ClipboardContext,
  ClipboardControl,
  ClipboardIndicator,
  ClipboardInput,
  ClipboardLabel,
  ClipboardRoot,
  ClipboardRootProvider,
  ClipboardTrigger,
  collapsible_exports as Collapsible,
  CollapsibleContent,
  CollapsibleContext,
  CollapsibleRoot,
  CollapsibleRootProvider,
  CollapsibleTrigger,
  color_picker_exports as ColorPicker,
  ColorPickerArea,
  ColorPickerAreaBackground,
  ColorPickerAreaThumb,
  ColorPickerChannelInput,
  ColorPickerChannelSlider,
  ColorPickerChannelSliderThumb,
  ColorPickerChannelSliderTrack,
  ColorPickerContent,
  ColorPickerContext,
  ColorPickerControl,
  ColorPickerEyeDropperTrigger,
  ColorPickerFormatSelect,
  ColorPickerFormatTrigger,
  ColorPickerHiddenInput,
  ColorPickerLabel,
  ColorPickerPositioner,
  ColorPickerRoot,
  ColorPickerRootProvider,
  ColorPickerSwatch,
  ColorPickerSwatchGroup,
  ColorPickerSwatchIndicator,
  ColorPickerSwatchTrigger,
  ColorPickerTransparencyGrid,
  ColorPickerTrigger,
  ColorPickerValueText,
  ColorPickerView,
  combobox_exports as Combobox,
  ComboboxClearTrigger,
  ComboboxContent,
  ComboboxContext,
  ComboboxControl,
  ComboboxInput,
  ComboboxItem,
  ComboboxItemContext,
  ComboboxItemGroup,
  ComboboxItemGroupLabel,
  ComboboxItemIndicator,
  ComboboxItemText,
  ComboboxLabel,
  ComboboxList,
  ComboboxPositioner,
  ComboboxRoot,
  ComboboxRootProvider,
  ComboboxTrigger,
  date_picker_exports as DatePicker,
  DatePickerClearTrigger,
  DatePickerContent,
  DatePickerContext,
  DatePickerControl,
  DatePickerInput,
  DatePickerLabel,
  DatePickerMonthSelect,
  DatePickerNextTrigger,
  DatePickerPositioner,
  DatePickerPresetTrigger,
  DatePickerPrevTrigger,
  DatePickerRangeText,
  DatePickerRoot,
  DatePickerRootProvider,
  DatePickerTable,
  DatePickerTableBody,
  DatePickerTableCell,
  DatePickerTableCellTrigger,
  DatePickerTableHead,
  DatePickerTableHeader,
  DatePickerTableRow,
  DatePickerTrigger,
  DatePickerView,
  DatePickerViewControl,
  DatePickerViewTrigger,
  DatePickerYearSelect,
  dialog_exports as Dialog,
  DialogBackdrop,
  DialogCloseTrigger,
  DialogContent,
  DialogContext,
  DialogDescription,
  DialogPositioner,
  DialogRoot,
  DialogRootProvider,
  DialogTitle,
  DialogTrigger,
  editable_exports as Editable,
  EditableArea,
  EditableCancelTrigger,
  EditableContext,
  EditableControl,
  EditableEditTrigger,
  EditableInput,
  EditableLabel,
  EditablePreview,
  EditableRoot,
  EditableRootProvider,
  EditableSubmitTrigger,
  EnvironmentProvider,
  file_upload_exports as FileUpload,
  FileUploadContext,
  FileUploadDropzone,
  FileUploadHiddenInput,
  FileUploadItem,
  FileUploadItemDeleteTrigger,
  FileUploadItemGroup,
  FileUploadItemName,
  FileUploadItemPreview,
  FileUploadItemPreviewImage,
  FileUploadItemSizeText,
  FileUploadLabel,
  FileUploadRoot,
  FileUploadRootProvider,
  FileUploadTrigger,
  format_exports as Format,
  FormatByte,
  FormatNumber,
  hover_card_exports as HoverCard,
  HoverCardArrow,
  HoverCardArrowTip,
  HoverCardContent,
  HoverCardContext,
  HoverCardPositioner,
  HoverCardRoot,
  HoverCardRootProvider,
  HoverCardTrigger,
  LocaleProvider,
  menu_exports as Menu,
  MenuArrow,
  MenuArrowTip,
  MenuCheckboxItem,
  MenuContent,
  MenuContext,
  MenuContextTrigger,
  MenuIndicator,
  MenuItem,
  MenuItemContext,
  MenuItemGroup,
  MenuItemGroupLabel,
  MenuItemIndicator,
  MenuItemText,
  MenuPositioner,
  MenuRadioItem,
  MenuRadioItemGroup,
  MenuRoot,
  MenuRootProvider,
  MenuSeparator,
  MenuTrigger,
  MenuTriggerItem,
  number_input_exports as NumberInput,
  NumberInputContext,
  NumberInputControl,
  NumberInputDecrementTrigger,
  NumberInputIncrementTrigger,
  NumberInputInput,
  NumberInputLabel,
  NumberInputRoot,
  NumberInputRootProvider,
  NumberInputScrubber,
  pagination_exports as Pagination,
  PaginationContext,
  PaginationEllipsis,
  PaginationItem,
  PaginationNextTrigger,
  PaginationPrevTrigger,
  PaginationRoot,
  PaginationRootProvider,
  pin_input_exports as PinInput,
  PinInputContext,
  PinInputControl,
  PinInputHiddenInput,
  PinInputInput,
  PinInputLabel,
  PinInputRoot,
  PinInputRootProvider,
  popover_exports as Popover,
  PopoverAnchor,
  PopoverArrow,
  PopoverArrowTip,
  PopoverCloseTrigger,
  PopoverContent,
  PopoverContext,
  PopoverDescription,
  PopoverIndicator,
  PopoverPositioner,
  PopoverRoot,
  PopoverRootProvider,
  PopoverTitle,
  PopoverTrigger,
  Portal,
  Presence,
  PresenceProvider,
  progress_exports as Progress,
  ProgressCircle,
  ProgressCircleRange,
  ProgressCircleTrack,
  ProgressContext,
  ProgressLabel,
  ProgressRange,
  ProgressRoot,
  ProgressRootProvider,
  ProgressTrack,
  ProgressValueText,
  ProgressView,
  qr_code_exports as QrCode,
  QrCodeContext,
  QrCodeFrame,
  QrCodeOverlay,
  QrCodePattern,
  QrCodeRoot,
  QrCodeRootProvider,
  radio_group_exports as RadioGroup,
  RadioGroupContext,
  RadioGroupIndicator,
  RadioGroupItem,
  RadioGroupItemContext,
  RadioGroupItemControl,
  RadioGroupItemHiddenInput,
  RadioGroupItemText,
  RadioGroupLabel,
  RadioGroupRoot,
  RadioGroupRootProvider,
  rating_group_exports as RatingGroup,
  RatingGroupContext,
  RatingGroupControl,
  RatingGroupHiddenInput,
  RatingGroupItem,
  RatingGroupItemContext,
  RatingGroupLabel,
  RatingGroupRoot,
  RatingGroupRootProvider,
  segment_group_exports as SegmentGroup,
  SegmentGroupContext,
  SegmentGroupIndicator,
  SegmentGroupItem,
  SegmentGroupItemContext,
  SegmentGroupItemControl,
  SegmentGroupItemHiddenInput,
  SegmentGroupItemText,
  SegmentGroupLabel,
  SegmentGroupRoot,
  SegmentGroupRootProvider,
  select_exports as Select,
  SelectClearTrigger,
  SelectContent,
  SelectContext,
  SelectControl,
  SelectHiddenSelect,
  SelectIndicator,
  SelectItem,
  SelectItemContext,
  SelectItemGroup,
  SelectItemGroupLabel,
  SelectItemIndicator,
  SelectItemText,
  SelectLabel,
  SelectList,
  SelectPositioner,
  SelectRoot,
  SelectRootProvider,
  SelectTrigger,
  SelectValueText,
  signature_pad_exports as SignaturePad,
  SignaturePadClearTrigger,
  SignaturePadContext,
  SignaturePadControl,
  SignaturePadGuide,
  SignaturePadLabel,
  SignaturePadRoot,
  SignaturePadRootProvider,
  SignaturePadSegment,
  slider_exports as Slider,
  SliderContext,
  SliderControl,
  SliderHiddenInput,
  SliderLabel,
  SliderMarker,
  SliderMarkerGroup,
  SliderRange,
  SliderRoot,
  SliderRootProvider,
  SliderThumb,
  SliderTrack,
  SliderValueText,
  splitter_exports as Splitter,
  SplitterContext,
  SplitterPanel,
  SplitterResizeTrigger,
  SplitterRoot,
  SplitterRootProvider,
  switch_exports as Switch,
  SwitchContext,
  SwitchControl,
  SwitchHiddenInput,
  SwitchLabel,
  SwitchRoot,
  SwitchRootProvider,
  SwitchThumb,
  TabContent,
  TabIndicator,
  TabList,
  TabTrigger,
  tabs_exports as Tabs,
  TabsContext,
  TabsRoot,
  TabsRootProvider,
  tags_input_exports as TagsInput,
  TagsInputClearTrigger,
  TagsInputContext,
  TagsInputControl,
  TagsInputHiddenInput,
  TagsInputInput,
  TagsInputItem,
  TagsInputItemContext,
  TagsInputItemDeleteTrigger,
  TagsInputItemInput,
  TagsInputItemPreview,
  TagsInputItemText,
  TagsInputLabel,
  TagsInputRoot,
  TagsInputRootProvider,
  toast_exports as Toast,
  ToastActionTrigger,
  ToastCloseTrigger,
  ToastContext,
  ToastDescription,
  ToastRoot,
  ToastTitle,
  Toaster,
  toggle_group_exports as ToggleGroup,
  ToggleGroupContext,
  ToggleGroupItem,
  ToggleGroupRoot,
  ToggleGroupRootProvider,
  tooltip_exports as Tooltip,
  TooltipArrow,
  TooltipArrowTip,
  TooltipContent,
  TooltipContext,
  TooltipPositioner,
  TooltipRoot,
  TooltipRootProvider,
  TooltipTrigger,
  tree_view_exports as TreeView,
  TreeViewBranch,
  TreeViewBranchContent,
  TreeViewBranchControl,
  TreeViewBranchIndicator,
  TreeViewBranchText,
  TreeViewBranchTrigger,
  TreeViewContext,
  TreeViewItem,
  TreeViewItemContext,
  TreeViewItemIndicator,
  TreeViewItemText,
  TreeViewLabel,
  TreeViewRoot,
  TreeViewRootProvider,
  TreeViewTree,
  ark,
  createToaster,
  jsxFactory,
  splitPresenceProps,
  useAccordion,
  useAccordionContext,
  useAccordionItemContext,
  useAvatar,
  useAvatarContext,
  useCarousel,
  useCarouselContext,
  useCheckbox,
  useCheckboxContext,
  useCheckboxGroup,
  useCheckboxGroupContext,
  useClipboard,
  useClipboardContext,
  useCollapsible,
  useCollapsibleContext,
  useColorPicker,
  useColorPickerContext,
  useCombobox,
  useComboboxContext,
  useComboboxItemContext,
  useDatePicker,
  useDatePickerContext,
  useDialog,
  useDialogContext,
  useEditable,
  useEditableContext,
  useEnvironmentContext,
  useFileUpload,
  useFileUploadContext,
  useHoverCard,
  useHoverCardContext,
  useLocaleContext,
  useMenu,
  useMenuContext,
  useMenuItemContext,
  useNumberInput,
  useNumberInputContext,
  usePagination,
  usePaginationContext,
  usePinInput,
  usePinInputContext,
  usePopover,
  usePopoverContext,
  usePresence,
  usePresenceContext,
  useProgress,
  useProgressContext,
  useQrCode,
  useQrCodeContext,
  useRadioGroup,
  useRadioGroupContext,
  useRadioGroupItemContext,
  useRatingGroup,
  useRatingGroupContext,
  useRatingGroupItemContext,
  useSegmentGroup,
  useSegmentGroupContext,
  useSegmentGroupItemContext,
  useSelect,
  useSelectContext,
  useSelectItemContext,
  useSignaturePad,
  useSignaturePadContext,
  useSlider,
  useSliderContext,
  useSplitter,
  useSplitterContext,
  useSwitch,
  useSwitchContext,
  useTabs,
  useTabsContext,
  useTagsInput,
  useTagsInputContext,
  useTagsInputItemContext,
  useToastContext,
  useToggleGroup,
  useToggleGroupContext,
  useTooltip,
  useTooltipContext,
  useTreeView,
  useTreeViewContext,
  useTreeViewItemContext
};
/*! Bundled license information:

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.5.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/
//# sourceMappingURL=@ark-ui_react.js.map
